<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>软件设计师例题精讲</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:30em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
/* table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7} */
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#9e9e9e}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}

/* 自定义输出 HTML 样式 */
/* 固定按钮在左上角 */
#toggleButton {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 1000;
    /*background-color: lightgrey;*/
    color: #AB2C21;
    border: none;
    /*padding: 6px 10px;*/
    cursor: pointer;
}
/*#toc.toc2{width:40em}*/
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:85em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}

body.toc2.toc-right {
    padding-left: 0;
    padding-right: 0em;
}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.pygments .hll { background-color: #ffffcc }
pre.pygments { background: #f8f8f8; }
pre.pygments .tok-c { color: #3D7B7B; font-style: italic } /* Comment */
pre.pygments .tok-err { border: 1px solid #FF0000 } /* Error */
pre.pygments .tok-k { color: #008000; font-weight: bold } /* Keyword */
pre.pygments .tok-o { color: #666666 } /* Operator */
pre.pygments .tok-ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
pre.pygments .tok-cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
pre.pygments .tok-cp { color: #9C6500 } /* Comment.Preproc */
pre.pygments .tok-cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
pre.pygments .tok-c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
pre.pygments .tok-cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
pre.pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
pre.pygments .tok-ge { font-style: italic } /* Generic.Emph */
pre.pygments .tok-ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
pre.pygments .tok-gr { color: #E40000 } /* Generic.Error */
pre.pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
pre.pygments .tok-gi { color: #008400 } /* Generic.Inserted */
pre.pygments .tok-go { color: #717171 } /* Generic.Output */
pre.pygments .tok-gp { color: #000080; font-weight: bold } /* Generic.Prompt */
pre.pygments .tok-gs { font-weight: bold } /* Generic.Strong */
pre.pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
pre.pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
pre.pygments .tok-kc { color: #008000; font-weight: bold } /* Keyword.Constant */
pre.pygments .tok-kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
pre.pygments .tok-kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
pre.pygments .tok-kp { color: #008000 } /* Keyword.Pseudo */
pre.pygments .tok-kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
pre.pygments .tok-kt { color: #B00040 } /* Keyword.Type */
pre.pygments .tok-m { color: #666666 } /* Literal.Number */
pre.pygments .tok-s { color: #BA2121 } /* Literal.String */
pre.pygments .tok-na { color: #687822 } /* Name.Attribute */
pre.pygments .tok-nb { color: #008000 } /* Name.Builtin */
pre.pygments .tok-nc { color: #0000FF; font-weight: bold } /* Name.Class */
pre.pygments .tok-no { color: #880000 } /* Name.Constant */
pre.pygments .tok-nd { color: #AA22FF } /* Name.Decorator */
pre.pygments .tok-ni { color: #717171; font-weight: bold } /* Name.Entity */
pre.pygments .tok-ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
pre.pygments .tok-nf { color: #0000FF } /* Name.Function */
pre.pygments .tok-nl { color: #767600 } /* Name.Label */
pre.pygments .tok-nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
pre.pygments .tok-nt { color: #008000; font-weight: bold } /* Name.Tag */
pre.pygments .tok-nv { color: #19177C } /* Name.Variable */
pre.pygments .tok-ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
pre.pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
pre.pygments .tok-mb { color: #666666 } /* Literal.Number.Bin */
pre.pygments .tok-mf { color: #666666 } /* Literal.Number.Float */
pre.pygments .tok-mh { color: #666666 } /* Literal.Number.Hex */
pre.pygments .tok-mi { color: #666666 } /* Literal.Number.Integer */
pre.pygments .tok-mo { color: #666666 } /* Literal.Number.Oct */
pre.pygments .tok-sa { color: #BA2121 } /* Literal.String.Affix */
pre.pygments .tok-sb { color: #BA2121 } /* Literal.String.Backtick */
pre.pygments .tok-sc { color: #BA2121 } /* Literal.String.Char */
pre.pygments .tok-dl { color: #BA2121 } /* Literal.String.Delimiter */
pre.pygments .tok-sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
pre.pygments .tok-s2 { color: #BA2121 } /* Literal.String.Double */
pre.pygments .tok-se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
pre.pygments .tok-sh { color: #BA2121 } /* Literal.String.Heredoc */
pre.pygments .tok-si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
pre.pygments .tok-sx { color: #008000 } /* Literal.String.Other */
pre.pygments .tok-sr { color: #A45A77 } /* Literal.String.Regex */
pre.pygments .tok-s1 { color: #BA2121 } /* Literal.String.Single */
pre.pygments .tok-ss { color: #19177C } /* Literal.String.Symbol */
pre.pygments .tok-bp { color: #008000 } /* Name.Builtin.Pseudo */
pre.pygments .tok-fm { color: #0000FF } /* Name.Function.Magic */
pre.pygments .tok-vc { color: #19177C } /* Name.Variable.Class */
pre.pygments .tok-vg { color: #19177C } /* Name.Variable.Global */
pre.pygments .tok-vi { color: #19177C } /* Name.Variable.Instance */
pre.pygments .tok-vm { color: #19177C } /* Name.Variable.Magic */
pre.pygments .tok-il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body class="article toc2 toc-right">
<div id="header">
<h1>软件设计师例题精讲</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_1_数据表示">1 数据表示</a>
<ul class="sectlevel2">
<li><a href="#_1_1_原码反码补码移码">1.1 原码反码补码移码</a>
<ul class="sectlevel3">
<li><a href="#_根据补码计算真值">根据补码计算真值</a></li>
</ul>
</li>
<li><a href="#_1_2_浮点数格式">1.2 浮点数格式</a></li>
<li><a href="#_1_3_校验码在osi的数据链路层">1.3 校验码（在OSI的数据链路层）</a>
<ul class="sectlevel3">
<li><a href="#_1_3_1_奇偶校验">1.3.1 奇偶校验</a></li>
<li><a href="#_1_3_2_循环冗余校验码crc校验">1.3.2 循环冗余校验码‌（CRC校验）</a></li>
<li><a href="#_1_3_3_海明码">1.3.3 海明码</a>
<ul class="sectlevel4">
<li><a href="#_1_3_3_1_example1_计算海明码">1.3.3.1 Example1 计算海明码</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_2_数据结构">2 数据结构</a>
<ul class="sectlevel2">
<li><a href="#_2_1_二叉树遍历先序_中序_后序">2.1 二叉树遍历先序-中序-后序</a>
<ul class="sectlevel3">
<li><a href="#_2_1_1_先序遍历">2.1.1 先序遍历</a></li>
<li><a href="#_2_1_2_中序遍历">2.1.2 中序遍历</a></li>
<li><a href="#_2_1_3_后序遍历">2.1.3 后序遍历</a></li>
</ul>
</li>
<li><a href="#_2_2_二叉排序树关键码序列">2.2 二叉排序树关键码序列</a></li>
<li><a href="#_2_3_二叉树最小高度">2.3 二叉树最小高度</a></li>
<li><a href="#_2_4_二叉树结点数">2.4 二叉树结点数</a></li>
<li><a href="#_2_5_二叉树小根堆">2.5 二叉树小根堆</a></li>
<li><a href="#_2_6_二叉树遍历顺序">2.6 二叉树遍历顺序</a></li>
<li><a href="#_2_7_二叉树哪个效率最差">2.7 二叉树哪个效率最差</a></li>
<li><a href="#_2_8_满二叉树判定左右孩子">2.8 满二叉树判定左右孩子</a></li>
<li><a href="#_2_9_哈夫曼树最优二叉树公式">2.9 哈夫曼树(最优二叉树)公式</a></li>
<li><a href="#_2_10_哈夫曼树编码">2.10 哈夫曼树编码</a></li>
<li><a href="#_2_11_哈夫曼树编码计算">2.11 哈夫曼树编码计算</a></li>
<li><a href="#_2_12_无向图顶点度数之和">2.12 无向图顶点度数之和</a></li>
<li><a href="#_2_13_无向连通图顶点和边数">2.13 无向连通图顶点和边数</a></li>
<li><a href="#_2_14_有向图邻接矩阵">2.14 有向图邻接矩阵</a></li>
<li><a href="#_2_15_某个度的节点数">2.15 某个度的节点数</a></li>
<li><a href="#_2_16_拓扑排序">2.16 拓扑排序</a></li>
<li><a href="#_2_17_进栈出栈">2.17 进栈出栈</a></li>
<li><a href="#_2_18_栈的大小计算">2.18 栈的大小计算</a></li>
<li><a href="#_2_19_两栈共享空间">2.19 两栈共享空间</a>
<ul class="sectlevel3">
<li><a href="#_2_19_1_先弄懂两个栈都空时_top1_1top2_n">2.19.1 先弄懂：两个栈都空时 top[1] = 1、top[2] = n</a></li>
<li><a href="#_2_19_2_再弄懂栈1的底在_v1栈_2_的底在_vn">2.19.2 再弄懂：栈1的底在 V[1]，栈 2 的底在 V[n]</a></li>
</ul>
</li>
<li><a href="#_2_20_队列长度">2.20 队列长度</a></li>
<li><a href="#_2_21_线性探查法解决冲突构造哈希表">2.21 线性探查法解决冲突构造哈希表</a></li>
<li><a href="#_2_22_三对角矩阵">2.22 三对角矩阵</a></li>
</ul>
</li>
<li><a href="#_3_算法">3 算法</a>
<ul class="sectlevel2">
<li><a href="#_3_1_算法策略和时间复杂度">3.1 算法策略和时间复杂度</a>
<ul class="sectlevel3">
<li><a href="#_3_1_1_插入排序算法时间和空间复杂度">3.1.1 插入排序算法时间和空间复杂度</a>
<ul class="sectlevel4">
<li><a href="#_3_1_1_1_python_插入排序源代码">3.1.1.1 python 插入排序&#8212;&#8203;源代码</a></li>
<li><a href="#_3_1_1_2_python_插入排序活动图">3.1.1.2 python 插入排序&#8212;&#8203;活动图</a></li>
</ul>
</li>
<li><a href="#_3_1_2_快速排序算法时间和空间复杂度">3.1.2 快速排序算法时间和空间复杂度</a>
<ul class="sectlevel4">
<li><a href="#_3_1_2_1_python_快速排序源代码">3.1.2.1 python 快速排序&#8212;&#8203;源代码</a></li>
<li><a href="#_3_1_2_2_python_快速排序活动图">3.1.2.2 python 快速排序&#8212;&#8203;活动图</a></li>
</ul>
</li>
<li><a href="#_3_1_3_根据代码求时间复杂度">3.1.3 根据代码求时间复杂度</a></li>
</ul>
</li>
<li><a href="#_3_2_排序">3.2 排序</a>
<ul class="sectlevel3">
<li><a href="#_3_2_1_简单选择排序selection_sort">3.2.1 简单选择排序（Selection Sort）</a></li>
<li><a href="#_3_2_2_快速排序初始排列">3.2.2 快速排序初始排列</a></li>
<li><a href="#_3_2_3_猜排序算法">3.2.3 猜排序算法</a></li>
</ul>
</li>
<li><a href="#_3_3_背包问题">3.3 背包问题</a></li>
</ul>
</li>
<li><a href="#_4_状态转换机">4 状态转换机</a>
<ul class="sectlevel2">
<li><a href="#_4_1_正规集识别字符种类个数">4.1 正规集识别字符种类个数</a></li>
<li><a href="#_4_2_文法推导正规集">4.2 文法推导正规集</a></li>
</ul>
</li>
<li><a href="#_5_存储系统与寻址结构">5 存储系统与寻址结构</a>
<ul class="sectlevel2">
<li><a href="#_5_1_存储单元地址宽度">5.1 存储单元地址宽度</a></li>
<li><a href="#_5_2_寻址范围计算">5.2 寻址范围计算</a></li>
<li><a href="#_5_3_寻址单元数计算">5.3 寻址单元数计算</a></li>
<li><a href="#_5_4_存储体系位示图_第几个字多少字">5.4 存储体系位示图 (第几个字)(多少字)</a></li>
<li><a href="#_5_5_存储地址编号">5.5 存储地址编号</a></li>
<li><a href="#_5_6_存储时间计算">5.6 存储时间计算</a></li>
<li><a href="#_5_7_存储器分类方式">5.7 存储器分类方式</a></li>
<li><a href="#_5_8_存储分页系统">5.8 存储分页系统</a>
<ul class="sectlevel3">
<li><a href="#_5_8_1_求物理地址">5.8.1 求物理地址</a></li>
<li><a href="#_5_8_2_求淘汰页">5.8.2 求淘汰页</a></li>
<li><a href="#_5_8_3_求页帧号接上题淘汰页">5.8.3 求页帧号（接上题淘汰页）</a></li>
</ul>
</li>
<li><a href="#_5_9_存储磁盘块计算">5.9 存储磁盘块计算</a></li>
<li><a href="#_5_10_存储磁盘读取文件时间计算">5.10 存储磁盘读取文件时间计算</a></li>
<li><a href="#_5_11_磁盘块与缓冲区读取时间计算">5.11 磁盘块与缓冲区读取时间计算</a></li>
<li><a href="#_5_12_存储图片需光盘张数">5.12 存储图片需光盘张数</a></li>
<li><a href="#_5_13_地址范围转字节数">5.13 地址范围转字节数</a></li>
<li><a href="#_5_14_页式虚拟存储缺页中断分析">5.14 页式虚拟存储缺页中断分析</a></li>
<li><a href="#_5_15_多级索引文件最大长度">5.15 多级索引文件最大长度</a></li>
<li><a href="#_5_16_数字音频存储大小">5.16 数字音频存储大小</a></li>
</ul>
</li>
<li><a href="#_6_指令流水线">6 指令流水线</a>
<ul class="sectlevel2">
<li><a href="#_6_1_指令之扩展操作码">6.1 指令之扩展操作码</a></li>
</ul>
</li>
<li><a href="#_7_程序优化加速比">7 程序优化加速比</a></li>
<li><a href="#_8_操作系统">8 操作系统</a>
<ul class="sectlevel2">
<li><a href="#_8_1_进程同步与互斥pv_操作">8.1 进程同步与互斥（PV 操作）</a>
<ul class="sectlevel3">
<li><a href="#_8_1_1_前趋图">8.1.1 前趋图</a></li>
<li><a href="#_8_1_2_pv_操作">8.1.2 PV 操作</a></li>
<li><a href="#_8_1_3_example_信号量初值等于_0">8.1.3 Example 信号量初值等于 0</a></li>
<li><a href="#_8_1_4_example_信号量初值不等于_0">8.1.4 Example 信号量初值不等于 0</a></li>
<li><a href="#_8_1_5_信号量s的取值范围">8.1.5 信号量S的取值范围</a></li>
</ul>
</li>
<li><a href="#_8_2_资源分配图resource_allocation_graph_rag">8.2 资源分配图（Resource Allocation Graph, RAG）</a>
<ul class="sectlevel3">
<li><a href="#_8_2_1_example_阻塞节点和死锁">8.2.1 Example 阻塞节点和死锁</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_9_数据库">9 数据库</a>
<ul class="sectlevel2">
<li><a href="#_9_1_关系模式">9.1 关系模式</a>
<ul class="sectlevel3">
<li><a href="#_9_1_1_求候选键">9.1.1 求候选键</a></li>
<li><a href="#_9_1_2_无损连接分解">9.1.2 无损连接分解</a></li>
<li><a href="#_9_1_3_保持函数依赖">9.1.3 保持函数依赖</a></li>
</ul>
</li>
<li><a href="#_9_2_关系代数表达式">9.2 关系代数表达式</a>
<ul class="sectlevel3">
<li><a href="#_9_2_1_问题1">9.2.1 问题1</a></li>
<li><a href="#_9_2_2_问题2">9.2.2 问题2</a></li>
<li><a href="#_9_2_3_举一个具体例子">9.2.3 举一个具体例子‌</a></li>
</ul>
</li>
<li><a href="#_9_3_数据库模式">9.3 数据库模式</a></li>
<li><a href="#_9_4_数据库设计">9.4 数据库设计</a></li>
<li><a href="#_9_5_数据库锁">9.5 数据库锁</a></li>
<li><a href="#_9_6_not_exists">9.6 NOT EXISTS</a>
<ul class="sectlevel3">
<li><a href="#_9_6_1_如何理解该_sql">9.6.1 如何理解该 SQL</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_10_网络模型">10 网络模型</a>
<ul class="sectlevel2">
<li><a href="#_10_1_osi_七层模型与_tcpip_四层模型">10.1 OSI 七层模型与 TCP/IP 四层模型</a>
<ul class="sectlevel3">
<li><a href="#_10_1_1_example">10.1.1 Example</a></li>
</ul>
</li>
<li><a href="#_10_2_网络层">10.2 网络层</a>
<ul class="sectlevel3">
<li><a href="#_10_2_1_ip_数据报分片">10.2.1 IP 数据报分片</a>
<ul class="sectlevel4">
<li><a href="#_10_2_1_1_example1">10.2.1.1 Example1</a></li>
<li><a href="#_10_2_1_2_example2">10.2.1.2 Example2</a></li>
<li><a href="#_10_2_1_3_example3">10.2.1.3 Example3</a></li>
<li><a href="#_10_2_1_4_example4">10.2.1.4 Example4</a></li>
</ul>
</li>
<li><a href="#_10_2_2_ip_地址分类">10.2.2 IP 地址分类</a></li>
<li><a href="#_10_2_3_ip_地址特殊情况">10.2.3 IP 地址特殊情况</a></li>
<li><a href="#_10_2_4_子网掩码计算子网号">10.2.4 子网掩码计算子网号</a>
<ul class="sectlevel4">
<li><a href="#_10_2_4_1_子网数计算_1">10.2.4.1 子网数计算 1</a></li>
<li><a href="#_10_2_4_2_子网数计算_2">10.2.4.2 子网数计算 2</a></li>
</ul>
</li>
<li><a href="#_10_2_5_ipv6_协议">10.2.5 IPv6 协议</a></li>
<li><a href="#_10_2_6_rip_协议">10.2.6 RIP 协议</a>
<ul class="sectlevel4">
<li><a href="#_10_2_6_1_example">10.2.6.1 Example</a></li>
</ul>
</li>
<li><a href="#_10_2_7_bgp_协议">10.2.7 BGP 协议</a></li>
<li><a href="#_10_2_8_ip_确定主机范围">10.2.8 IP 确定主机范围</a></li>
<li><a href="#_10_2_9_子网掩码">10.2.9 子网掩码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_11_编程语言">11 编程语言</a>
<ul class="sectlevel2">
<li><a href="#_11_1_c_语言">11.1 C 语言</a></li>
</ul>
</li>
<li><a href="#_12_软件测试">12 软件测试</a>
<ul class="sectlevel2">
<li><a href="#_12_1_example_mccabe度量法计算其环路复杂度">12.1 Example McCabe度量法计算其环路复杂度</a></li>
<li><a href="#_12_2_等价类划分测">12.2 等价类划分测</a></li>
</ul>
</li>
<li><a href="#_13_设计模式">13 设计模式</a>
<ul class="sectlevel2">
<li><a href="#_13_1_软件过程模型">13.1 软件过程模型</a></li>
</ul>
</li>
<li><a href="#_14_uml_图">14 UML 图</a>
<ul class="sectlevel2">
<li><a href="#_14_1_类图符号">14.1 类图符号</a></li>
<li><a href="#_14_2_活动图">14.2 活动图</a>
<ul class="sectlevel3">
<li><a href="#_14_2_1_复杂的例子">14.2.1 复杂的例子</a></li>
</ul>
</li>
<li><a href="#_14_3_用例图">14.3 用例图</a></li>
<li><a href="#_14_4_uml面向对象建模">14.4 UML面向对象建模</a></li>
</ul>
</li>
<li><a href="#_15_信息安全">15 信息安全</a></li>
<li><a href="#_16_专业英语">16 专业英语</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<button id="toggleButton">Table of Contents</button>
<script>
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () => {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
</script>
</div>
</div>
<div class="sect1">
<h2 id="_1_数据表示">1 数据表示</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_1_1_原码反码补码移码">1.1 原码反码补码移码</h3>
<div class="sect3">
<h4 id="_根据补码计算真值">根据补码计算真值</h4>
<div class="paragraph">
<p>如果“2x”的补码是“90H”，那么x的真值是（B）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 72
B -56
C 56
D 111</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>首先判断符号位（最高位），为 0，表示该数为正数，正数的原码、反码、补码不变；</p>
</div>
<div class="paragraph">
<p>为1，则该数为负数，负数的补码为其原码的符号位不变，数值部分的按位取反，然后整个数加1。</p>
</div>
<div class="paragraph">
<p>90H = 1001 0000B，补码为：1001 0000 则原码为 1111 0000，其中最高位代表符号位，1110000 代表数值，即-112，2X=-112，所以 X=-56。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_1_2_浮点数格式">1.2 浮点数格式</h3>
<div class="paragraph">
<p><mark>下面的题是 IEEE 754标准（符号位 + 阶码 + 尾数） 以前的考试内容，应该是不会再考了，了解即可。</mark></p>
</div>
<div class="paragraph">
<p>某种机器的浮点数表示格式如下(允许非规格化表示)。若阶码以补码表示，尾数以原码表示，则 1000100000000001 表示的浮点数是（ ）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1位      4位      1位      10位
 ↑        ↑       ↑        ↑
阶符     阶码     数符      尾数</pre>
</div>
</div>
<div class="paragraph">
<p>单选：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 2^-16 × 2^-10
B 2^-15 × 2^-10
C 2^-16 ×（1-2^-10）
D 2^-15 ×（1-2^-10）</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>题干尾数是原码为：0000000001，数符是 0，这表示该尾数是正数为 2^-10 。</p>
</div>
<div class="paragraph">
<p>阶码是 0001 是补码，转换成原码是 1111，是十进制的 15，这里注意阶符是 1（是单独的，没有与阶码混在一起），这表示阶码是负数，因此该浮点数是 2^-15 ×2^-10 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这个题用到了负数的补码。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_1_3_校验码在osi的数据链路层">1.3 校验码（在OSI的数据链路层）</h3>
<div class="sect3">
<h4 id="_1_3_1_奇偶校验">1.3.1 奇偶校验</h4>
<div class="paragraph">
<p>奇校验：原始数据增加一个校验位，使 1 的个数为奇数。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>原始数据    校验位
10010100    0   -&gt; 1 的个数为奇数，所以校验位为 0</pre>
</div>
</div>
<div class="paragraph">
<p>偶校验：原始数据增加一个校验位，使 1 的个数为偶数。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>原始数据    校验位
10010100    1   -&gt; 1 的个数为奇数，所以校验位为 1</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>奇偶校验只有在出错二进制位个数是 <mark>奇数</mark> 的情况下才有效。</p>
</li>
<li>
<p>奇偶校验只能检错，不能纠错。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>码字：编码后的信息单元，由若干个二进制位组成。</p>
</div>
<div class="paragraph">
<p>距离：将两个码字逐位进行对比，具有不相同的位的个数称为两个码字间的距离。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1011101 和 1001001 之间的距离是 2。</p>
<div class="literalblock">
<div class="content">
<pre>1011101
1001001
  x x   -&gt; 2 位不同</pre>
</div>
</div>
</li>
<li>
<p>奇偶校验的码距为 2</p>
<div class="ulist">
<ul>
<li>
<p>以奇校验为例：如下面完整码字的任意两个奇数个 1 的码字之间，至少要改两个比特才能从一个合法码字变成另一个合法码字。所以码距是 2。</p>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">举例说明奇校验码距为 2</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">数据位</th>
<th class="tableblock halign-left valign-top">校验位（奇校验）</th>
<th class="tableblock halign-left valign-top">完整码字</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0001</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">001</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0010</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">010</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0100</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">011</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0111</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">101</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1011</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">110</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1101</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">111</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1110</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>码距：一种编码方案可能有若干个合法码字，各合法码字间的 <mark>最小距离</mark> 称为“码距”。</p>
</div>
<div class="paragraph">
<p>计算（偶校验为例）：各信息位进行异或（模2加）运算，得到的结果即为「偶校验位」。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如 1001101 异或结果为 0，所以偶校验位为 0。</p>
</li>
<li>
<p>则最后发送的数据为 10011010（假设将校验位放在最后面）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>验证（偶校验为例）：收到方验证数据</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将收到的数据 10011010 按位异或结果为 0，说明数据正确。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://www.bilibili.com/video/BV1qp421D7B3" class="bare">https://www.bilibili.com/video/BV1qp421D7B3</a>  0:00 &#8594; 02:44</p>
</div>
</div>
<div class="sect3">
<h4 id="_1_3_2_循环冗余校验码crc校验">1.3.2 循环冗余校验码‌（CRC校验）</h4>
<div class="paragraph">
<p>给定待发送的数据为: 101001</p>
</div>
<div class="paragraph">
<p>要求的校验码多项式为: \(G(x) = x^3 + x^2 + 1\)</p>
</div>
<hr>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>根据多项式确定 CRC 校验码位数</p>
<div class="ulist">
<ul>
<li>
<p>因为多项式最高次幂为 3，所以校验码位数为 3。</p>
</li>
</ul>
</div>
</li>
<li>
<p>数据左移校验码位数</p>
<div class="ulist">
<ul>
<li>
<p>数据补 3 个 0 为: 101001000</p>
</li>
</ul>
</div>
</li>
<li>
<p>确定多项式的值</p>
<div class="ulist">
<ul>
<li>
<p>根据多项式确定
\(G(x) = x^3 + x^2 + 1\) &#8594;
\(1 \cdot x^3 + 1 \cdot x^2 + 0 \cdot x^1 + 1 \cdot x^0\)
&#8594; 1101</p>
</li>
</ul>
</div>
</li>
<li>
<p>计算 CRC 值（除法异或运算）</p>
<div class="literalblock">
<div class="content">
<pre>1010 01000 ÷ 1101
1101        (生成多项式)
----
01110 1000  (第一步 XOR 结果)
 1101
 ----
 001110 00  (第二步 XOR 结果)
   1101
   -----
   001100   (第三步 XOR 结果)
     1101
     ----
     0001   (CRC 余数为 1，则 3 位校验位为 001)</pre>
</div>
</div>
</li>
<li>
<p>生成发送数据 = 传输数据 + CRC校验码</p>
<div class="ulist">
<ul>
<li>
<p>101001+001 &#8594; 101001001</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<hr>
<div class="paragraph">
<p><a href="https://www.bilibili.com/video/BV1qp421D7B3" class="bare">https://www.bilibili.com/video/BV1qp421D7B3</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>从低到高举例 12:27 &#8594; end</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_1_3_3_海明码">1.3.3 海明码</h4>
<div class="ulist">
<ul>
<li>
<p>可检错和纠错，海明码的标准码距是 3</p>
</li>
<li>
<p>可发现 2 位错，纠正 1 位错</p>
</li>
<li>
<p>用到了奇偶校验中的偶校验。</p>
</li>
<li>
<p><mark>计算 k 位数公式：\(2^k \geq n + k + 1\)</mark></p>
<div class="ulist">
<ul>
<li>
<p>n 为信息码长度</p>
</li>
<li>
<p>k 为校验码长度（需要通过上面公式，自己代出来即可）</p>
</li>
<li>
<p><mark>校验码位置：\(2^{i-1}\) ( i 从 1 &#8594; k，如1、2、4、8 )</mark></p>
</li>
</ul>
</div>
</li>
<li>
<p><mark>异或校验整个海明码，都为 0 正确。</mark></p>
</li>
</ul>
</div>
<hr>
<div class="paragraph">
<p>视频教学</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=5it44QcOtQQ" class="bare">https://www.youtube.com/watch?v=5it44QcOtQQ</a> 从高到低举例</p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/BV1qp421D7B3" class="bare">https://www.bilibili.com/video/BV1qp421D7B3</a> 从低到高举例 02:44 &#8594; 12:27</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_1_3_3_1_example1_计算海明码">1.3.3.1 Example1 计算海明码</h5>
<div class="paragraph">
<p>例如: 信息码 101101100，采用海明码校验，问最终海明码是多少?</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>确定校验位数量 k，原信息码位数为 n=9，代入公式:</p>
<div class="ulist">
<ul>
<li>
<p>\(2^k \geq n+k+1\)，得 \(2^k \geq 9+k+1\)</p>
</li>
<li>
<p>若 k=4，则 \(2^4 \geq 9+4+1\)，即 16&gt;14，满足公式。</p>
</li>
<li>
<p>确定校验位数量为 4 位</p>
</li>
</ul>
</div>
</li>
<li>
<p>确定校验码位置: 代入公式 \(2^{i-1}\) ( i 从 1&#8594; k=4，得 1、2、4、8 )，即下面 k1、k2、k4、k8 的 4 个位置。</p>
<div class="imageblock">
<div class="content">
<img src="img/diagram-haimingcode1.png" alt="diagram haimingcode1" width="736" height="134">
</div>
</div>
</li>
<li>
<p>确定校验位与数据位对应关系</p>
<div class="ulist">
<ul>
<li>
<p>即 kx 分别对应哪些数据位</p>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle" colspan="2" rowspan="2"><p class="tableblock">校验位对应数据位表 (为1则对应)</p></td>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">4个校验位</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">k8 (9,10,11,12,13)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">k4 (5,6,7,12,13)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">k2 (3,6,7,10,11)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">k1 (3,5,7,9,11,13)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-middle" rowspan="9"><p class="tableblock">9个数据位对应校验位关系</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3 &#8594; 0011 &#8594; k1, k2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5 &#8594; 0101 &#8594; k1, k4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6 &#8594; 0110 &#8594; k2, k4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">7 &#8594; 0111 &#8594; k1, k2, k4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">9 &#8594; 1001 &#8594; k1, k8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 &#8594; 1010 &#8594; k2, k8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">11 &#8594; 1011 &#8594; k1, k2, k8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">12 &#8594; 1100 &#8594; k4, k8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">13 &#8594; 1101 &#8594; k1, k4, k8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
</li>
<li>
<p>计算校验位的值</p>
<div class="ulist">
<ul>
<li>
<p>异或结果为 kx 的值</p>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">k1 对应位</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">异或结果为 k1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">信息码对应值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">k2 对应位</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">异或结果为 k2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">信息码对应值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">k4 对应位</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">异或结果为 k3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">信息码对应值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">k8 对应位</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">异或结果为 k4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">信息码对应值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">0</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
</li>
<li>
<p>插入校验位 k1 k2 k4 k8</p>
<div class="imageblock">
<div class="content">
<img src="img/diagram-haimingcode2.png" alt="diagram haimingcode2" width="784" height="261">
</div>
</div>
</li>
<li>
<p>接收方检错和纠错判断</p>
<div class="ulist">
<ul>
<li>
<p>接收方接收正确数据时: 1110011001100，按《4. 计算校验位的值》中的表进行异或（含 kx 值），都为 0 为正确。</p>
</li>
<li>
<p>接收方接收错误数据时: 1110111001100，按《4. 计算校验位的值》中的表进行异或（含 kx 值），若有 1 为错误。</p>
<div class="ulist">
<ul>
<li>
<p>此例为数值位 5 由 0 变成了 1</p>
</li>
<li>
<p>如何知道是数据位 5 发生了变化？ &#8594; <mark>将异或结果由 k8 k4 k2 k1 排序为 0 1 0 1，即是十进制的位置 5。</mark></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">k1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">异或结果</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 &#8594; 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 错</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">k2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">异或结果</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">k4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">异或结果</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 &#8594; 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 错</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">k8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">异或结果</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
</tbody>
</table>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_2_数据结构">2 数据结构</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_2_1_二叉树遍历先序_中序_后序">2.1 二叉树遍历先序-中序-后序</h3>
<div class="paragraph">
<p>写出下面二叉树的先序、中序、后序遍历的关键码序列。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>      46
    /    \
  13      54
 /  \       \
4   38       98
    /        /
  25       62
              \
              91
             /
           79</pre>
</div>
</div>
<div class="sect3">
<h4 id="_2_1_1_先序遍历">2.1.1 先序遍历</h4>
<div class="paragraph">
<p>先序遍历的规则：根节点 → 左子树 → 右子树</p>
</div>
<div class="paragraph">
<p>也就是说：每到一个节点，先访问自己，然后访问左边子树，再访问右边子树。</p>
</div>
<div class="paragraph">
<p>逐步先序遍历（根 &#8594; 左 &#8594; 右）</p>
</div>
<hr>
<div class="paragraph">
<p>从根节点 46 开始： [46]</p>
</div>
<div class="paragraph">
<p>访问 46，左子是 13</p>
</div>
<div class="paragraph">
<p>访问 13 [46, 13]</p>
</div>
<div class="ulist">
<ul>
<li>
<p>左子是 4 → 访问 4  [46, 13, 4]</p>
</li>
<li>
<p>右子是 38  [46, 13, 4, 38]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>访问 38</p>
</div>
<div class="ulist">
<ul>
<li>
<p>左子是 25 → 访问 25 [46, 13, 4, 38, 25]</p>
</li>
<li>
<p>（38 无右子）</p>
</li>
</ul>
</div>
<hr>
<div class="paragraph">
<p>回到 46，处理右子：54</p>
</div>
<div class="ulist">
<ul>
<li>
<p>54 无左 → 访问 54 [46, 13, 4, 38, 25, 54]</p>
</li>
<li>
<p>右子是 98 [46, 13, 4, 38, 25, 54, 98]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>访问 98</p>
</div>
<div class="ulist">
<ul>
<li>
<p>左子是 62 [46, 13, 4, 38, 25, 54, 98， 62]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>访问 62</p>
</div>
<div class="ulist">
<ul>
<li>
<p>没有左子</p>
</li>
<li>
<p>右子是 91 [46, 13, 4, 38, 25, 54, 98， 62, 91]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>访问 91</p>
</div>
<div class="ulist">
<ul>
<li>
<p>左子是 79 → 访问 79 [46, 13, 4, 38, 25, 54, 98， 62, 91, 79]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最终先序遍历结果：[46, 13, 4, 38, 25, 54, 98, 62, 91, 79]</p>
</div>
<div class="paragraph">
<p>口诀记忆：根左右 —— 一来先访问自己，接着左走到底，最后右处理</p>
</div>
</div>
<div class="sect3">
<h4 id="_2_1_2_中序遍历">2.1.2 中序遍历</h4>
<div class="paragraph">
<p>中序遍历的定义：左子树 → 根 → 右子树</p>
</div>
<div class="paragraph">
<p>也就是说：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>每到一个节点，先去它的左边（如果有）。</p>
</li>
<li>
<p>左边没有了就访问这个节点。</p>
</li>
<li>
<p>然后再去它的右边。</p>
</li>
</ol>
</div>
<hr>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>从 <code>46</code> 开始：先访问左子树：到 <code>13</code></p>
</li>
<li>
<p>到 <code>13</code>：先访问左子树：到 <code>4</code></p>
<div class="ulist">
<ul>
<li>
<p><code>4</code> 没有左 → 访问 <code>4</code> ✅</p>
</li>
<li>
<p>回到 <code>13</code> → 访问 <code>13</code> ✅</p>
</li>
<li>
<p>接着访问右子树：到 <code>38</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>到 <code>38</code>：先访问左子树：到 <code>25</code></p>
<div class="ulist">
<ul>
<li>
<p><code>25</code> 没有左 → 访问 <code>25</code> ✅</p>
</li>
<li>
<p>回到 <code>38</code> → 访问 <code>38</code> ✅</p>
</li>
</ul>
</div>
</li>
<li>
<p>回到根节点：46 → 访问 46 ✅</p>
<div class="ulist">
<ul>
<li>
<p><mark>此时为 [4, 13, 25, 38, 46]</mark></p>
</li>
</ul>
</div>
</li>
<li>
<p>去右子树：到 54</p>
<div class="ulist">
<ul>
<li>
<p>54 没有左 → 访问 54 ✅</p>
</li>
<li>
<p>去右子树：到 98</p>
</li>
</ul>
</div>
</li>
<li>
<p>到 98</p>
<div class="ulist">
<ul>
<li>
<p>先访问左子树：到 62</p>
</li>
<li>
<p>62 没有左 → 访问 62 ✅</p>
</li>
<li>
<p>去右子树：到 91</p>
</li>
</ul>
</div>
</li>
<li>
<p>到 91</p>
<div class="ulist">
<ul>
<li>
<p>先访问左子树：到 79</p>
</li>
<li>
<p>79 没有左 → 访问 79 ✅</p>
</li>
<li>
<p>回到 91 → 访问 91 ✅</p>
</li>
<li>
<p>回到 98 → 访问 98 ✅</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>所有访问顺序：[4, 13, 25, 38, 46, 54, 62, 79, 91, 98]</p>
</div>
<div class="paragraph">
<p>小总结技巧：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>把每个节点当成你“走”到的房间。</p>
</li>
<li>
<p>永远先去左边的房间，一直走到尽头。</p>
</li>
<li>
<p>回头访问自己。</p>
</li>
<li>
<p>然后去右边房间。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_2_1_3_后序遍历">2.1.3 后序遍历</h4>
<div class="paragraph">
<p>后序遍历的规则：左子树 → 右子树 → 根节点</p>
</div>
<div class="paragraph">
<p>也就是说每访问一个节点，先处理它的左边，然后处理右边，最后才访问它自己。</p>
</div>
<div class="paragraph">
<p>我们从根 46 开始：</p>
</div>
<hr>
<div class="paragraph">
<p>左子树（13）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>左（4）：无左右 → 访问 4，序列为 [4]</p>
</li>
<li>
<p>右（38）：</p>
<div class="ulist">
<ul>
<li>
<p>左（25）：无左右 → 访问 25，序列为 [4, 25]</p>
</li>
<li>
<p>右：无 → 访问 38，序列为 [4, 25, 38]</p>
</li>
</ul>
</div>
</li>
<li>
<p>最后访问 13，序列为 [4, 25, 38, 13]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>根节点 46 现在先不访问，要去右子树</strong></p>
</div>
<hr>
<div class="paragraph">
<p>右子树（54）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>左：无</p>
</li>
<li>
<p>访问右子树（98）：</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>→ 98 的左子（62）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>左：无</p>
</li>
<li>
<p>右（91）：</p>
<div class="ulist">
<ul>
<li>
<p>左（79）：访问 <code>79</code></p>
</li>
<li>
<p>没有右 → 访问 <code>91</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>回来访问 <code>62</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后访问 <code>98</code></p>
</div>
<div class="paragraph">
<p>右子树结果是：[79, 91, 62, 98, 54]</p>
</div>
<div class="paragraph">
<p><strong>最后访问根节点 46</strong></p>
</div>
<div class="paragraph">
<p>总结：最终后序遍历顺序是 [4, 25, 38, 13, 79, 91, 62, 98, 54, 46]</p>
</div>
<div class="paragraph">
<p>后序口诀帮记忆：左右根（先处理孩子，最后处理自己）</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_2_二叉排序树关键码序列">2.2 二叉排序树关键码序列</h3>
<div class="paragraph">
<p>可以构造出下图所示二叉排序树（二叉检索树、二叉查找树）的关键码序列是（ B ）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/mermaid-2025-05-11-164301.svg" alt="mermaid 2025 05 11 164301" width="294" height="317">
</div>
<div class="title">Figure 1. <a href="img/mermaid-2025-05-11-164301.svg">二叉排序树</a></div>
</div>
<div class="literalblock">
<div class="content">
<pre>A 10 13 17 19 23 27 31 40 65 91
B 23 40 91 17 19 10 31 65 27 13
C 23 19 40 27 17 13 10 91 65 31
D 27 31 40 65 91 13 10 17 23 19</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>要构造题目所示的二叉排序树，关键码序列需满足以下条件：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>根节点必须最先插入</strong>：根节点是23，因此任何以其他数字开头的序列（如选项A、D）均可排除。</p>
</li>
<li>
<p><strong>父节点必须在子节点之前插入</strong>：每个子节点的位置由其父节点的值决定，因此父节点必须已存在于树中。</p>
</li>
<li>
<p><strong>插入路径需符合树的层级关系</strong>：<mark>插入时需从根节点开始，逐层比较，最终定位到正确位置。</mark></p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>选项B的插入过程分析</strong>：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">插入顺序</th>
<th class="tableblock halign-left valign-top">插入逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">23</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为根节点插入。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">40</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与23比较，40&gt;23，成为23的右子节点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">91</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">先与23比较，进入右子树，再与40比较，91&gt;40，成为40的右子节点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">17</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">先与23比较，17&lt;23，成为23的左子节点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">19</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">先与23比较，进入左子树，与17比较，19&gt;17，成为17的右子节点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">先与23比较，进入左子树，与17比较，10&lt;17，成为17的左子节点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">31</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">先与23比较，进入右子树，与40比较，31&lt;40，成为40的左子节点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">65</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">先与23比较，进入右子树，与40比较，进入右子树，与91比较，65&lt;91，成为91的左子节点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">27</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">先与23比较，进入右子树，与40比较，进入左子树，与31比较，27&lt;31，成为31的左子节点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">先与23比较，进入左子树，与17比较，进入左子树，与10比较，13&gt;10，成为10的右子节点。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>为何有时与根节点比较，有时与父节点比较？</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>插入始终从根开始</strong>：每次插入新节点时，必须从根节点23开始逐层比较。例如，插入13时，虽然其父节点是10，但插入路径需经过23→17→10，最终确定13的位置。</p>
</li>
<li>
<p><strong>路径依赖父节点顺序</strong>：父节点的插入顺序决定了子节点的比较路径。例如，插入27时，路径为23→40→31，因为31已插入，才能进一步比较27的位置。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>错误选项分析</strong>：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>选项C：插入顺序为23,19,40,27,17,13,10,91,65,31。</p>
<div class="ulist">
<ul>
<li>
<p>插入19时，23的左子节点应为17，但19被错误地插入到左子树，导致后续17无法正确插入到23的左子树，结构混乱。</p>
</li>
</ul>
</div>
</li>
<li>
<p>选项D：以27开头，根节点必须是23，因此排除。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>结论</strong>：选项 B 的插入顺序严格遵循二叉排序树的构造规则，每个节点的父节点均在其之前插入，且路径正确，最终形成题目所示的树结构。因此，正确答案为：</p>
</div>
<div class="paragraph">
<p><strong>答案：B</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_2_3_二叉树最小高度">2.3 二叉树最小高度</h3>
<div class="paragraph">
<p>假设一棵二叉树的结点个数为 50，则它的最小高度是（ ）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 4
B 5
C 6
D 7</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>按照满足条件时，当 50 个结点构成一棵完全二叉树时高度最小，\(h = \lfloor \log_2(n) \rfloor 向下取整为5再 + 1 = 6\)</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_4_二叉树结点数">2.4 二叉树结点数</h3>
<div class="paragraph">
<p>若一棵二叉树的高度（即层数）为h，则该二叉树（A）。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A 最多有 \(2^h - 1\) 个结点</p>
</li>
<li>
<p>B 最少有 \(2^h - 1\) 个结点</p>
</li>
<li>
<p>C \(2^h\) 个结点</p>
</li>
<li>
<p>D 有 \(2^h -1\) 个结点</p>
</li>
</ul>
</div>
<h4 id="_解析" class="discrete">解析</h4>
<div class="paragraph">
<p><strong>A. 最多有 \(2^h - 1\) 个结点</strong> ✅</p>
</div>
<div class="paragraph">
<p>这是正确的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>满二叉树（Full Binary Tree）：每一层的结点数都是最大，第 i 层有 \(2^{i-1}\) 个结点。</p>
</li>
<li>
<p>总结点数为：等比数列求和公式</p>
<div class="ulist">
<ul>
<li>
<p>\(1 + 2 + 4 + ... + 2^{h-1} = 2^h-1\)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以当二叉树是满的（即每一层都满）时，结点最多有 \(2^h - 1\) 个。</p>
</div>
<div class="paragraph">
<p><strong>B. 最少有 2<sup>h</sup> - 1 个结点</strong> ❌
错误。最少的情况是每层只有一个结点（即链式结构），那么最少有 h 个结点，而不是 2<sup>h</sup> - 1。</p>
</div>
<div class="paragraph">
<p><strong>C. 有 2<sup>h</sup> 个结点</strong> ❌
错误。这是满二叉树下一层的节点数，仅在深度为 h+1 时才可能达到。</p>
</div>
<div class="paragraph">
<p><strong>D. 有 2<sup>h</sup> - 1 个结点</strong> ❌
错误。这是最多的情况，而非所有情况。</p>
</div>
<div class="paragraph">
<p>正确答案 <strong>A</strong></p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">最简单作法</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>画个满二叉树图</p>
<div class="imageblock">
<div class="content">
<img src="img/mermaid-2025-05-23-215839.svg" alt="mermaid 2025 05 23 215839" width="443" height="278">
</div>
</div>
</li>
<li>
<p>代入选项公式即能得到正确答案</p>
<div class="ulist">
<ul>
<li>
<p>上面满二叉树最多为  7 个节点，有 3 层，所以选项 A 正确。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_2_5_二叉树小根堆">2.5 二叉树小根堆</h3>
<div class="paragraph">
<p>对于 n 个元素的关键字序列 \(\{ k_1, k_2, \ldots k_n \}\)，当且仅当满足下面关系时称其为小根堆(小顶堆)。</p>
</div>
<div class="stemblock">
<div class="content">
\[[k_i \le k_{2i} \ \text{且} \ k_i \le k_{2i+1} \ \{ i = 1, 2, \ldots, \left\lfloor \frac{n}{2} \right\rfloor \}]\]
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
就到 n/2，因为再往后取就没有数来对比了。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下序列中，（ ）不是小根堆(小顶堆)。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 16,25,40,55,30,50,45
B 16,40,25,50,45,30,55
C 16,25,39,41,45,43,50
D 16,40,25,53,39,55,45</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>这是根据完全二叉树在数组中的存储方式来判断的。小根堆是一种完全二叉树结构的堆，在顺序存储时具有以下规律：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/mermaid-2025-05-09-174131.svg" alt="mermaid 2025 05 09 174131" width="333" height="235">
</div>
<div class="title">Figure 2. <a href="img/mermaid-2025-05-09-174131.svg">D 16,40,25,53,39,55,45</a></div>
</div>
<div class="paragraph">
<p><strong>答案为 D</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_2_6_二叉树遍历顺序">2.6 二叉树遍历顺序</h3>
<div class="paragraph">
<p>已知一棵二叉树的先序遍历结果为 ABCDEF，中序遍历结果为 CBAEDF，则后序遍历结果为（ ）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A CBEFDA
B FEDCBA
C CBEDFA
D 不确定</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>我们根据 <strong>先序遍历</strong> 和 <strong>中序遍历</strong> 来还原这棵二叉树，再求出它的 <strong>后序遍历</strong>。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">遍历就是访问树中所有节点的一种方式</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>先序遍历（Preorder）</strong>: 访问顺序：<strong>根 → 左子树 → 右子树</strong></p>
</li>
<li>
<p><strong>中序遍历（Inorder）</strong>: 访问顺序：<strong>左子树 → 根 → 右子树</strong></p>
</li>
<li>
<p><strong>后序遍历（Postorder）</strong>: 访问顺序：<strong>左子树 → 右子树 → 根</strong></p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>给定：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>先序遍历（Preorder）：<code>A B C D E F</code></p>
</li>
<li>
<p>中序遍历（Inorder）： <code>C B A E D F</code></p>
</li>
</ul>
</div>
<h3 id="_步骤一构建二叉树" class="discrete">步骤一：构建二叉树</h3>
<div class="paragraph">
<p>先序遍历的第一个节点是根节点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>根节点：A</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>查找 A 在中序遍历中的位置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>中序遍历：<code>C B | A | E D F</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以 A 的左子树是 <code>C B</code>，右子树是 <code>E D F</code>。</p>
</div>
<h4 id="_处理左子树" class="discrete">处理左子树：</h4>
<div class="paragraph">
<p>先序遍历中 A 的左子树部分是：<code>B C</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p>根是 B（先序中紧跟 A 之后）</p>
</li>
<li>
<p>中序左子树为 <code>C B</code>，B 是根，C 在左边 ⇒ C 是 B 的左子</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>左子树构建为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><span></span>   B
  /
C</code></pre>
</div>
</div>
<h4 id="_处理右子树" class="discrete">处理右子树：</h4>
<div class="paragraph">
<p>先序遍历中 A 的右子树部分是：<code>D E F</code>（剩下的）</p>
</div>
<div class="ulist">
<ul>
<li>
<p>根是 D（下一个未使用的先序元素）</p>
</li>
<li>
<p>中序右子树是 <code>E D F</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>D 在中序中的位置中间，所以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>左子树：E</p>
</li>
<li>
<p>右子树：F</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>右子树构建为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><span></span>   D
  / \
 E   F</code></pre>
</div>
</div>
<h4 id="_整体树结构为" class="discrete">整体树结构为：</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><span></span>       A
     /   \
    B     D
   /     / \
  C     E   F</code></pre>
</div>
</div>
<h3 id="_步骤二求后序遍历postorder" class="discrete">步骤二：求后序遍历（Postorder）</h3>
<div class="paragraph">
<p>后序遍历顺序是：<strong>左 → 右 → 根</strong></p>
</div>
<div class="paragraph">
<p>按照树结构遍历：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>左子树（B 的子树）：C → B</p>
</li>
<li>
<p>右子树（D 的子树）：E → F → D</p>
</li>
<li>
<p>根：A</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>合起来是：<code>C B E F D A</code></p>
</div>
<h4 id="_答案a_cbefda" class="discrete">答案：<strong>A. CBEFDA</strong></h4>
<hr>
</div>
<div class="sect2">
<h3 id="_2_7_二叉树哪个效率最差">2.7 二叉树哪个效率最差</h3>
<div class="paragraph">
<p>某个二叉查找树（即二叉排序树）中进行查找时，效率最差的情形是该二叉查找树是（C）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 完全二叉树
B 平衡二叉树
C 单枝树
D 满二叉树</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>查找效率最差的情形是当<strong>二叉查找树退化为单枝树</strong>时，这种结构就像一个<strong>链表</strong>，每次查找都只能顺着一个方向（全部左子树或全部右子树）一直找下去，时间复杂度为 <strong>O(n)</strong>，这是最差情况。</p>
</div>
<div class="paragraph">
<p>各选项解释如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>A. 完全二叉树</strong>：节点尽可能往左靠拢，结构紧凑，查找效率较高，接近 O(log n)。</p>
</li>
<li>
<p><strong>B. 平衡二叉树</strong>：左右子树高度差不超过1，保持良好的平衡性，查找效率高，为 O(log n)。</p>
</li>
<li>
<p><strong>C. 单枝树</strong>：所有节点都只有一个子节点（全左或全右），结构像链表，查找效率最差，为 O(n)。</p>
</li>
<li>
<p><strong>D. 满二叉树</strong>：每个非叶子节点都有两个子节点，并且所有叶子都在同一层，也是结构紧凑，查找效率高。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>正确答案：C 单枝树</strong></p>
</div>
<h4 id="_满二叉树full_binary_tree" class="discrete">满二叉树（Full Binary Tree）</h4>
<div class="paragraph">
<p><strong>定义：</strong>
每个非叶子节点都有两个子节点，所有叶子节点都处于同一层。</p>
</div>
<div class="paragraph">
<p><strong>特征：</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有层都被填满</p>
</li>
<li>
<p>节点数为：\(2^h - 1\) ，其中 h 为树的高度</p>
</li>
<li>
<p>树结构对称、规则</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>示意图：</strong></p>
</div>
<div class="literalblock">
<div class="content">
<pre>    A
   / \
  B   C
 / \ / \
D  E F  G</pre>
</div>
</div>
<div class="paragraph">
<p><strong>查找效率：</strong> 高，约为 \(O(\log n)\)</p>
</div>
<h4 id="_完全二叉树complete_binary_tree" class="discrete">完全二叉树（Complete Binary Tree）</h4>
<div class="paragraph">
<p><strong>定义</strong>：除了最后一层，其余各层都填满，最后一层从左到右依次排列，不允许中间有空缺。</p>
</div>
<div class="paragraph">
<p><strong>特征：</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>是结构上接近满二叉树的一种</p>
</li>
<li>
<p>节点尽可能靠左排列</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>示意图：</strong></p>
</div>
<div class="literalblock">
<div class="content">
<pre>    A
   / \
  B   C
 / \  /
D  E F</pre>
</div>
</div>
<div class="paragraph">
<p><strong>查找效率：</strong> 高，约为 \(O(\log n)\)</p>
</div>
<h4 id="_平衡二叉树avl_tree" class="discrete">平衡二叉树（AVL Tree）</h4>
<div class="paragraph">
<p><strong>定义</strong>：任意一个节点，其左子树与右子树的高度差的绝对值不超过 1。</p>
</div>
<div class="paragraph">
<p><strong>特征：</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>保持结构平衡，避免退化为链表</p>
</li>
<li>
<p>可通过旋转操作自动调整平衡</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>示意图：</strong></p>
</div>
<div class="literalblock">
<div class="content">
<pre>    10
   /  \
  5    15
 / \     \
2   7     20</pre>
</div>
</div>
<div class="paragraph">
<p><strong>查找效率：</strong> 高，约为 \(O(\log n)\)</p>
</div>
<h4 id="_单枝树skewed_tree" class="discrete">单枝树（Skewed Tree）</h4>
<div class="paragraph">
<p><strong>定义：</strong>
所有节点只有一个子节点（要么全左、要么全右），退化成链表结构。</p>
</div>
<div class="paragraph">
<p><strong>特征：</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>最差情况的二叉查找树</p>
</li>
<li>
<p>完全没有平衡性，结构最差</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>示意图（右单枝）：</strong></p>
</div>
<div class="literalblock">
<div class="content">
<pre>1
 \
  2
   \
    3
     \
      4</pre>
</div>
</div>
<div class="paragraph">
<p><strong>查找效率</strong>：最差，约为 \(O(n)\)</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_8_满二叉树判定左右孩子">2.8 满二叉树判定左右孩子</h3>
<div class="paragraph">
<p>一个高度为 h 的满二叉树的结点总数为 \(2^h-1\)，从根结点开始，自上而下、同层次结点从左至右，对结点按照顺序依次编号，即根结点编号为 1，其左、右孩子结点编号分别为 2 和 3，再下一层从左到右的编号为 4，5，6，7，依此类推。
那么，在一棵满二叉树中，对于编号为 m 和 n 的两个结点，若 n = 2 m + 1,则 （ ）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A m是n的左孩子
B m是n的右孩子
C n是m的左孩子
D n是m的右孩子</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>我们来分析题目中给出的二叉树节点编号规律：</p>
</div>
<div class="paragraph">
<p>在满二叉树中，按照从上到下、从左到右的顺序进行编号：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>根节点编号为 1</p>
</li>
<li>
<p>对于任意编号为 m 的节点：</p>
<div class="ulist">
<ul>
<li>
<p>它的左孩子编号是 2m</p>
</li>
<li>
<p>它的右孩子编号是 2m + 1</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>根据编号规律，编号为 m 的结点的右孩子编号为：<code>2m + 1</code></p>
</div>
<div class="paragraph">
<p>而题目中给出：<code>n = 2m + 1</code></p>
</div>
<div class="paragraph">
<p>因此，<strong>n 是 m 的右孩子</strong>。</p>
</div>
<div class="paragraph">
<p><strong>正确答案：</strong> <strong>D. n 是 m 的右孩子</strong></p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">最简单作法</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>画个满二叉树图</p>
<div class="imageblock">
<div class="content">
<img src="img/mermaid-2025-05-23-224518.svg" alt="mermaid 2025 05 23 224518" width="439" height="278">
</div>
</div>
</li>
<li>
<p>取个节点比如 2 想成是 m，则 2 的左节点是 4（2m），那么 2 的右节点是 5 （2m+1=n）即能得到正确答案为 <strong>D: n 是 m 的右孩子</strong></p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_2_9_哈夫曼树最优二叉树公式">2.9 哈夫曼树(最优二叉树)公式</h3>
<div class="paragraph">
<p>若一棵哈夫曼(Huffman)树共有 9 个顶点，则其叶子结点的个数为（ ）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 4
B 5
C 6
D 7</pre>
</div>
</div>
<div class="paragraph">
<p>答案为：B</p>
</div>
<div class="paragraph">
<p>先推个公式出来：</p>
</div>
<div class="paragraph">
<p>正确的构建流程（4 个叶子结点：A、B、C、D）：</p>
</div>
<div class="paragraph">
<p>初始结点：A、B、C、D（都是叶子）</p>
</div>
<div class="paragraph">
<p>第一步：合并权值最小的两个（比如 A 和 B）⇒ 生成中间结点 P</p>
</div>
<div class="paragraph">
<p>第二步：合并权值最小的两个（比如 C 和 D）⇒ 生成中间结点 Q</p>
</div>
<div class="paragraph">
<p>第三步：合并 P 和 Q ⇒ 得到根结点 R</p>
</div>
<div class="paragraph">
<p>树的结构应该是这样的：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    R
   / \
  P   Q
 / \ / \
A  B C  D</pre>
</div>
</div>
<div class="paragraph">
<p>总结点数验证：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>叶子结点：A、B、C、D ⇒ 4 个</p>
</li>
<li>
<p>中间结点：P、Q、R ⇒ 3 个</p>
</li>
<li>
<p>总结点数：4 + 3 = 7 = 2×4 - 1</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以有公式: <mark>总结点数 = 叶子结点数 + 内部结点数 = n+(n−1) = 2n−1</mark></p>
</div>
<div class="paragraph">
<p>9 个顶点代入公式： 9 = 2n - 1 &#8594; n = 5</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_10_哈夫曼树编码">2.10 哈夫曼树编码</h3>
<div class="paragraph">
<p>已知字符集 { a, b, c, d, e, f }，若各字符出现的次数（理解成出现的概率）分别为 6, 3, 8, 2, 10, 4，则对应字符集中各字符的哈夫曼编码可能为（A）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 00，1011, 01, 1010, 11, 100
B 11, 100, 110, 000 , 0010, 01
C 10, 1011, 11, 0011, 00, 010
D 0011, 10, 11, 0010, 01, 000</pre>
</div>
</div>
<hr>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>初始节点</strong>：按权值升序排列为 d(2), b(3), f(4), a(6), c(8), e(10)。</p>
</li>
<li>
<p><strong>合并最小节点</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>合并 d(2) 和 b(3) 成 5，队列变为 [f(4), 5, a(6), c(8), e(10)]。</p>
</li>
<li>
<p>合并 f(4) 和 5 成 9，队列变为 [a(6), 9, c(8), e(10)]。</p>
</li>
<li>
<p>合并 a(6) 和 c(8) 成 14，队列变为 [9, e(10), 14]。</p>
</li>
<li>
<p>合并 9 和 e(10) 成 19，队列变为 [14, 19]。</p>
</li>
<li>
<p>合并 14 和 19 成根节点 33。</p>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-2025-05-23-231928.svg" alt="graphviz 2025 05 23 231928" width="598" height="279">
</div>
<div class="title">Figure 3. 画出的树，可用边来推算出编码</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>编码规则</strong>：每个节点的左分支为 0，右分支为 1。</p>
<div class="ulist">
<ul>
<li>
<p><strong>a</strong> 的路径为：根→左→左，  编码 <strong>00</strong>。</p>
</li>
<li>
<p><strong>c</strong> 的路径为：根→左→右，  编码 <strong>01</strong>。</p>
</li>
<li>
<p><strong>e</strong> 的路径为：根→右→右，  编码 <strong>11</strong>。</p>
</li>
<li>
<p><strong>f</strong> 的路径为：根→右→左→左，编码 <strong>100</strong>。</p>
</li>
<li>
<p><strong>d</strong> 的路径为：根→右→左→右→左，编码 <strong>1010</strong>。</p>
</li>
<li>
<p><strong>b</strong> 的路径为：根→右→左→右→右，编码 <strong>1011</strong>。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>选项 A 的编码与上述结果完全一致</strong>，且满足哈夫曼编码的最短加权路径性质（高频字符编码更短）。<br>
其他选项（如 B、C、D）中，存在高频字符编码过长或前缀冲突的问题，因此排除。</p>
</div>
<div class="paragraph">
<p><strong>答案：A</strong></p>
</div>
<div class="paragraph">
<p>哈夫曼编码原则回顾：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>频率越高，编码越短；频率越低，编码越长。</p>
</li>
<li>
<p>没有一个编码是另一个编码的前缀（前缀码）。</p>
</li>
<li>
<p>哈夫曼树是通过合并频率最小的两个节点，逐步构建出来的。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>分析选项 A：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>频率最高的是 e(10) 和 c(8)，它们的编码分别是 11 和 01（都是2位）✅</p>
</li>
<li>
<p>a(6) 是 00（也是2位）✅</p>
</li>
<li>
<p>f(4) 是 100（3位）✅</p>
</li>
<li>
<p>b(3) 是 1011（4位），d(2) 是 1010（4位）✅</p>
</li>
<li>
<p>没有任何编码是另一个编码的前缀 ✅</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这完全符合哈夫曼编码的基本原则。</p>
</div>
<div class="paragraph">
<p>其他选项简要分析：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>B：e 的编码是 0010（4位），但它频率最高，应是最短的 → 不合理 ❌</p>
</li>
<li>
<p>C：b(3) 是 1011，d(2) 是 0011，但 a(6) 是 10，b 的编码比 a 还长，合理 ✅，但由于题目只选一项，A 更标准，A 是由树推算出来的。</p>
</li>
<li>
<p>D：a(6) 的编码是 0011（4位），比 b(3) 的 10 还长 → 不合理 ❌</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_2_11_哈夫曼树编码计算">2.11 哈夫曼树编码计算</h3>
<div class="paragraph">
<p>霍夫曼编码将频繁出现的字符采用短编码，出现频率较低的字符采用长编码。（目的是可以减少存储空间，参下面的频繁出现百分比表）</p>
</div>
<div class="paragraph">
<p>具体的操作过程为:</p>
</div>
<div class="paragraph">
<p>1) 以每个字符的出现频率作为关键字构建最小优先级队列（就是按出现频率排个序）;</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. 频繁出现百分比表</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">字符</th>
<th class="tableblock halign-left valign-top">a</th>
<th class="tableblock halign-left valign-top">b</th>
<th class="tableblock halign-left valign-top">c</th>
<th class="tableblock halign-left valign-top">d</th>
<th class="tableblock halign-left valign-top">e</th>
<th class="tableblock halign-left valign-top">f</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">出现频率 %</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">18</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">26</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>把这个表排序为:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. 最小优先级队列</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">字符</th>
<th class="tableblock halign-left valign-top">c</th>
<th class="tableblock halign-left valign-top">d</th>
<th class="tableblock halign-left valign-top">e</th>
<th class="tableblock halign-left valign-top">a</th>
<th class="tableblock halign-left valign-top">f</th>
<th class="tableblock halign-left valign-top">b</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">出现频率 %</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">18</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">26</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>2) 取出关键字最小的两个结点生成子树，根节点的关键字为孩子节点关键字之和，并将根节点插入到最小优先级队列中，直至得到一颗最优编码树。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
霍夫曼编码方案是基于贪心策略的。
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-2025-05-13-054235.svg" alt="graphviz 2025 05 13 054235" width="598" height="351">
</div>
<div class="title">Figure 4. 画出的树，可用边来推算出编码</div>
</div>
<div class="paragraph">
<p>求解：用该方案对包含 <strong>a~f</strong> 六个字符的文件进行编码，文件包含 <strong>100000</strong> 个字符，则与固定长度编码相比，该编码方案节省了 (A) 存储空间。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 21%
B 27%
C 18%
D 36%</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p><strong>分析：</strong>
这是对前面学习的哈夫曼编码的深层次应用。</p>
</div>
<div class="paragraph">
<p>如果对包含 100,000 个字符，且这些字符都属于 a 到 f。那么如果 <strong>采用固定长度的编码</strong>，针对于每个字符需要 3 位来编码（因为有 6 个不同的字符，至少需要 3 位才能表示 6 种不同的变化）。那么对 100000 个字符编码，其编码长度为 300000。</p>
</div>
<div class="paragraph">
<p>使用哈夫曼编码时，由图可以知道各编码为：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. 表格加上编码</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">字符</th>
<th class="tableblock halign-left valign-top">c</th>
<th class="tableblock halign-left valign-top">d</th>
<th class="tableblock halign-left valign-top">e</th>
<th class="tableblock halign-left valign-top">a</th>
<th class="tableblock halign-left valign-top">f</th>
<th class="tableblock halign-left valign-top">b</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\(f_i\) 出现频率 %</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">18</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">26</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\(l_i\) 编码长度 个</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0101</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">011</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>因此总的编码长度为:</p>
</div>
<div class="stemblock">
<div class="content">
\[L = \sum_{i=1}^{6} f_i \cdot l_i = 4\%×4 + 8\%×4 + 12\%×3 + 18\%×2 + 26\%×2 + 32\%×2 = 2.36\]
</div>
</div>
<div class="paragraph">
<p>因此节省的存储空间大小为 \(300000 - 2.36 \times 100000 = 64000\)</p>
</div>
<div class="paragraph">
<p>因此节省的存储空间比例为 \(\frac{64000}{300000}=21\%\)</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_12_无向图顶点度数之和">2.12 无向图顶点度数之和</h3>
<div class="paragraph">
<p>无向图中一个顶点的度是指图中与该顶点相邻接的顶点数。若无向图 G 中的顶点数为 n，边数为 e，则所有顶点的度数之和为（ ）</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A n*e</p>
</li>
<li>
<p>B n+e</p>
</li>
<li>
<p>C 2n</p>
</li>
<li>
<p>D 2e</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>答案：D</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>定义：在无向图中，一个顶点的度数（Degree）是指与该顶点相连的边的数量。度数是描述顶点在图中连接程度的一个重要指标。</p>
</div>
<div class="paragraph">
<p>这个题考查的是图论中无向图的一个基本性质：</p>
</div>
<div class="paragraph">
<p>在一个无向图中，所有顶点的度数之和等于边数的两倍。</p>
</div>
<div class="paragraph">
<p>原因解释：
每条边连接两个顶点，因此会被两个顶点各“贡献一次”度数。所以总的度数是边数的两倍。</p>
</div>
<div class="paragraph">
<p>设：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>顶点数为 n</p>
</li>
<li>
<p>边数为 e</p>
</li>
<li>
<p>公式中的 \(v_i\) 指顶点</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>则： \(\sum_{i=1}^{n} \deg(v_i) = 2e\)</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_13_无向连通图顶点和边数">2.13 无向连通图顶点和边数</h3>
<div class="paragraph">
<p>一个具有 n(n＞0) 个顶点的无向连通图至少有（ ）条边。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A n+1
B n
C n/2
D n-1</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>一个具有 \(n (n &gt; 0)\)个顶点的<strong>无向连通图</strong>，至少有 \(n - 1\) 条边。</p>
</div>
<div class="paragraph">
<p>这是因为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>无向连通图的最小边数是形成<strong>一棵树</strong>的情况。</p>
</li>
<li>
<p>一棵包含 n 个顶点的树恰好有 \(n - 1\) 条边，且是<strong>连通无环图</strong>。</p>
</li>
<li>
<p>如果边数再少，就不能保持连通性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以答案是：<strong>\(n - 1\)</strong> 条边。</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_14_有向图邻接矩阵">2.14 有向图邻接矩阵</h3>
<div class="paragraph">
<p>对于如下所示的有向图，其邻接矩阵是一个（A）的矩阵。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-2025-05-14-193037.svg" alt="graphviz 2025 05 14 193037" width="250" height="130">
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>A 5*5
B 5*7
C 7*5
D 7*7</pre>
</div>
</div>
<div class="paragraph">
<p>分析：<strong>邻接矩阵的定义：</strong></p>
</div>
<div class="paragraph">
<p>对于一个有向图，邻接矩阵是一个 n × n 的矩阵，其中 n 是图中顶点的个数。<strong>所以答案是 A。</strong></p>
</div>
<div class="paragraph">
<p>行和列都表示图中的顶点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>行号表示“从哪个顶点出发”（起点）</p>
</li>
<li>
<p>列号表示“到哪个顶点去”（终点）</p>
</li>
<li>
<p>行列交点的值表示是否存在这样的边。如果存在从顶点 i 到顶点 j 的边，则 A[i][j] = 1，否则为 0。</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. 邻接矩阵（顶点 1 到 5）</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top">1</th>
<th class="tableblock halign-center valign-top">2</th>
<th class="tableblock halign-center valign-top">3</th>
<th class="tableblock halign-center valign-top">4</th>
<th class="tableblock halign-center valign-top">5</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. 构造邻接表</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">顶点</th>
<th class="tableblock halign-left valign-top">邻接点（即表结点）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 和 3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 和 5</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">—（无）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">—（无）</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_2_15_某个度的节点数">2.15 某个度的节点数</h3>
<div class="paragraph">
<p>在—棵度为 3 的树中，若有 2 个度为 3 的结点，有 1 个度为 2 的结点，则有（C）个度为 0 的结点。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 4
B 5
C 6
D 7</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>解释：<mark>度为 3 的树（也称为<strong>三叉树</strong>）是指<strong>树中每个结点的最大子结点数为3</strong>，即每个结点最多可以有 3 个子结点。</mark></p>
</div>
<div class="paragraph">
<p><strong>度为3的树的特点：</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>结点的度</strong>：每个结点的子结点数可以是0（叶子结点）、1、2 或 3。</p>
</li>
<li>
<p><strong>树的度</strong>：整棵树的度是所有结点<mark>度的最大值</mark>，因此如果树中至少有一个结点有 3 个子结点，则该树的度为 3。</p>
</li>
<li>
<p><strong>结构</strong>：不同于<strong>二叉树（每个结点最多2个子结点）</strong>，三叉树可以有更灵活的分支结构。</p>
</li>
</ol>
</div>
<div class="literalblock">
<div class="title"><strong>示例：</strong></div>
<div class="content">
<pre>     A
   / | \
  B  C  D
 / \    |
E   F   G</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>A</strong> 的度为3（子结点 B、C、D）。</p>
</li>
<li>
<p><strong>B</strong> 的度为2（子结点 E、F）。</p>
</li>
<li>
<p><strong>D</strong> 的度为1（子结点 G）。</p>
</li>
<li>
<p><strong>C、E、F、G</strong> 的度为 0（叶子结点）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>总结：<strong>度为 3 的树是一种每个结点最多有 3 个子结点的树结构</strong>，适用于需要更高分支因子的场景。</p>
</div>
<div class="paragraph">
<p>基本概念清楚了，要想计算，还是挺麻烦的。下面画一个图可以快速求出本题。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>     A
   /   \
  B     C
 /|\   /|\
D E F G H I</pre>
</div>
</div>
<div class="paragraph">
<p>这个树的度为 3，且有两个度为 3 的节点（B和C），A节点的度为 2，度为 0 的节点有 6 个。所以答案是 C</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_16_拓扑排序">2.16 拓扑排序</h3>
<div class="paragraph">
<p>（ ）是右图的合法拓扑序列。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-2025-05-10-205110.svg" alt="graphviz 2025 05 10 205110" width="441" height="162">
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>A 654321
B 123456
C 563421
D 564213</pre>
</div>
</div>
<div class="paragraph">
<p>答案：A</p>
</div>
<hr>
<div class="paragraph">
<p>本题考查数据结构的基础知识。</p>
</div>
<div class="paragraph">
<p>拓扑排序是将AOV网中所有顶点排成一个线性序列的过程，并且该序列满足：若在 AOV 网中从顶点 vi 到 vj 有一条路径，则在该线性序列中，顶点 vi 必然在顶点 vj 之前。</p>
</div>
<div class="paragraph">
<p>对AOV网进行拓扑排序的方法如下：</p>
</div>
<div class="paragraph">
<p>(1)在AOV网中选择一个 <mark>入度为零（没有前驱）的顶点</mark> 且输出它；</p>
</div>
<div class="paragraph">
<p>(2)从网中删除该顶点及与该顶点有关的所有边；</p>
</div>
<div class="paragraph">
<p>(3)重复上述两步，直至网中不存在入度为零的顶点为止。</p>
</div>
<div class="paragraph">
<p>本题中只有序列“6 5 4 3 2 1”可由上述过程导出。</p>
</div>
<div class="paragraph">
<p>对有向图进行拓扑排序的结果会有两种情况：一种是所有顶点已输出，此时整个拓扑排序完成，说明网中不存在回路；另一种是尚有未输出的顶点，剩余的顶点均有前驱顶点，表明网中存在回路。</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_17_进栈出栈">2.17 进栈出栈</h3>
<div class="paragraph">
<p>若元素以a,b,c,d,e的顺序进入一个初始为空的栈中，每个元素进栈、出栈各1次，要求出栈的第一个元素为d，则合法的出栈序列共有 （4） 种。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 4
B 5
C 6
D 24</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>本题考查数据结构基础知识。</p>
</div>
<div class="paragraph">
<p>栈的修改规则是后进先出。对于题目给出的元素序列，若要求 d 先出栈，则此时 a、b、c 尚在栈中，因此这四个元素构成的出栈序列只能是 dcba。</p>
</div>
<div class="paragraph">
<p>若 e 在 c 出栈之前进栈，因此可以得到出栈系列 decba。</p>
</div>
<div class="paragraph">
<p>若 e 在 b 出栈之前进栈，因此可以得到出栈序列 dceba。</p>
</div>
<div class="paragraph">
<p>若 e 在 a 出栈之前入栈，因此可以得到出栈序列 dcbea。</p>
</div>
<div class="paragraph">
<p>若 e 在 a 出栈之后入栈，因此可以得到出栈序列 dcbae。</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_18_栈的大小计算">2.18 栈的大小计算</h3>
<div class="paragraph">
<p>利用栈对算术表达式 \(10 \times (40-30/5)+20\) 求值时，存放操作数的栈(初始为空)的容量至少为（C ），才能满足暂存该表达式中的运算数或运算结果的要求。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 2    B 3    C 4    D 5</pre>
</div>
</div>
<hr>
<h4 id="_初始理解题目" class="discrete">初始理解题目</h4>
<div class="paragraph">
<p>题目给出了一个算术表达式：\(10 \times (40-30/5)+20\)，并要求我们在利用栈（stack）来求值这个表达式时，存放操作数的栈（操作数栈）至少需要多大的容量。这里的“容量”指的是栈能够同时存放的操作数的最大数量。初始时栈是空的。</p>
</div>
<h4 id="_栈在表达式求值中的应用" class="discrete">栈在表达式求值中的应用</h4>
<div class="paragraph">
<p>在计算机科学中，栈常用于算术表达式的求值，尤其是使用“后缀表达式”（逆波兰表示法）或通过“中缀表达式”直接求值。通常，我们会使用两个栈：一个操作数栈（存放数字），一个运算符栈（存放运算符）。<mark>但本题只关注操作数栈的容量</mark>。</p>
</div>
<div class="paragraph">
<p>在中缀表达式的求值过程中，我们通常会按照运算符的优先级和括号的顺序来计算。具体步骤如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>初始化两个栈：操作数栈和运算符栈。</p>
</li>
<li>
<p>从左到右扫描表达式：</p>
<div class="ulist">
<ul>
<li>
<p>遇到数字，压入操作数栈。</p>
</li>
<li>
<p>遇到运算符：</p>
<div class="ulist">
<ul>
<li>
<p>如果运算符栈为空，或栈顶是左括号，或当前运算符优先级高于栈顶运算符，则压入运算符栈。</p>
</li>
<li>
<p>否则，从运算符栈弹出运算符，从操作数栈弹出相应数量的操作数进行计算，将结果压回操作数栈，然后继续比较当前运算符与新的栈顶运算符。</p>
</li>
</ul>
</div>
</li>
<li>
<p>遇到左括号，压入运算符栈。</p>
</li>
<li>
<p>遇到右括号，不断弹出运算符栈的运算符并计算，直到遇到左括号，弹出左括号。</p>
</li>
</ul>
</div>
</li>
<li>
<p>表达式扫描完后，弹出运算符栈中所有运算符并计算。</p>
</li>
<li>
<p>最后操作数栈中剩下的就是结果。</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
我们要看这期间，运算符栈最多被占用了多少个。
</td>
</tr>
</table>
</div>
<h4 id="_应用到具体表达式" class="discrete">应用到具体表达式</h4>
<div class="paragraph">
<p>让我们一步一步地计算表达式 \(10 \times (40-30/5)+20\)，并跟踪操作数栈的最大使用量。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>初始：</p>
<div class="literalblock">
<div class="content">
<pre>操作数栈: []
运算符栈: []
最大操作数栈大小: 0</pre>
</div>
</div>
</li>
<li>
<p>遇到 <code>10</code>（数字）：</p>
<div class="literalblock">
<div class="content">
<pre>压入操作数栈: [10]
最大大小: max(0, 1) = 1</pre>
</div>
</div>
</li>
<li>
<p>遇到 x：</p>
<div class="literalblock">
<div class="content">
<pre>运算符栈为空，压入 [x]
操作数栈: [10]
最大大小: 1</pre>
</div>
</div>
</li>
<li>
<p>遇到 <code>(</code>：</p>
<div class="literalblock">
<div class="content">
<pre>压入运算符栈: [x, (]
操作数栈: [10]
最大大小: 1</pre>
</div>
</div>
</li>
<li>
<p>遇到 <code>40</code>：</p>
<div class="literalblock">
<div class="content">
<pre>压入操作数栈: [10, 40]
最大大小: max(1, 2) = 2</pre>
</div>
</div>
</li>
<li>
<p>遇到 <code>-</code>：</p>
<div class="literalblock">
<div class="content">
<pre>栈顶是 `(`，压入 `-`: [x, (, -]
操作数栈: [10, 40]
最大大小: 2</pre>
</div>
</div>
</li>
<li>
<p>遇到 <code>30</code>：</p>
<div class="literalblock">
<div class="content">
<pre>压入操作数栈: [10, 40, 30]
最大大小: max(2, 3) = 3</pre>
</div>
</div>
</li>
<li>
<p>遇到 <code>/</code>：</p>
<div class="literalblock">
<div class="content">
<pre>栈顶是 `-`，`/` 优先级高于 `-`，压入 `/`: [x, (, -, /]
操作数栈: [10, 40, 30]
最大大小: 3</pre>
</div>
</div>
</li>
<li>
<p>遇到 <code>5</code>：</p>
<div class="literalblock">
<div class="content">
<pre>压入操作数栈: [10, 40, 30, 5]
最大大小: max(3, 4) = 4</pre>
</div>
</div>
</li>
<li>
<p>遇到 <code>)</code>：开始弹出并计算，直到 <code>(</code>：</p>
<div class="literalblock">
<div class="content">
<pre>弹出 `/`，弹出 `5` 和 `30`，计算 `30 / 5 = 6`，压入 `6`:
    操作数栈: [10, 40, 6]
    最大大小: 4（之前达到过）</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>弹出 `-`，弹出 `6` 和 `40`，计算 `40 - 6 = 34`，压入 `34`:
    操作数栈: [10, 34]
    最大大小: 4</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>弹出 `(`:
    运算符栈: [x]
    操作数栈: [10, 34]
    最大大小: 4</pre>
</div>
</div>
</li>
<li>
<p>遇到 <code>+</code>：</p>
<div class="literalblock">
<div class="content">
<pre>栈顶是 `x`，`+` 优先级低于 `x`，所以弹出 `x`，弹出 `34` 和 `10`，计算 `10 * 34 = 340`，压入 `340`:
   操作数栈: [340]
   最大大小: 4</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>现在运算符栈为空，压入 `+`: ['+']
操作数栈: [340]
最大大小: 4</pre>
</div>
</div>
</li>
<li>
<p>遇到 <code>20</code>：</p>
<div class="literalblock">
<div class="content">
<pre>压入操作数栈: [340, 20]
最大大小: max(4, 2) = 4</pre>
</div>
</div>
</li>
<li>
<p>表达式结束，弹出运算符栈中的 <code>+</code>：</p>
<div class="literalblock">
<div class="content">
<pre>弹出 `+`，弹出 `20` 和 `340`，计算 `340 + 20 = 360`，压入 `360`:
   操作数栈: [360]
   最大大小: 4</pre>
</div>
</div>
</li>
</ol>
</div>
<h4 id="_最大操作数栈大小的观察" class="discrete">最大操作数栈大小的观察</h4>
<div class="paragraph">
<p>在整个过程中，操作数栈的大小变化如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[] (0)</p>
</li>
<li>
<p>[10] (1)</p>
</li>
<li>
<p>[10, 40] (2)</p>
</li>
<li>
<p>[10, 40, 30] (3)</p>
</li>
<li>
<p><mark>[10, 40, 30, 5] (4) ← 最大值</mark></p>
</li>
<li>
<p>[10, 40, 6] (3)</p>
</li>
<li>
<p>[10, 34] (2)</p>
</li>
<li>
<p>[340] (1)</p>
</li>
<li>
<p>[340, 20] (2)</p>
</li>
<li>
<p>[360] (1)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，操作数栈最大是 4。</p>
</div>
<h4 id="_验证其他路径" class="discrete">验证其他路径</h4>
<div class="paragraph">
<p>为了确保没有更大的需求，让我们看看是否有其他操作顺序会导致更大的栈大小。关键在于嵌套的计算：</p>
</div>
<div class="paragraph">
<p>在 <code>(40 - 30 / 5)</code> 部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>30 / 5</code> 需要 <code>30</code> 和 <code>5</code> 都在栈中，此时栈是 <code>[10, 40, 30, 5]</code>（大小4）。</p>
</li>
<li>
<p>计算 <code>30 / 5</code> 后，栈变为 <code>[10, 40, 6]</code>（大小3）。</p>
</li>
<li>
<p>然后 <code>40 - 6</code> 需要 <code>40</code> 和 <code>6</code> 在栈中（大小2）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>没有其他部分需要同时存储更多的操作数。</p>
</div>
<h4 id="_排除其他选项" class="discrete">排除其他选项</h4>
<div class="ulist">
<ul>
<li>
<p>A. 2：在 <code>30 / 5</code> 时需要 <code>30</code> 和 <code>5</code> 同时在栈中，此时栈中已经有 <code>10</code> 和 <code>40</code>，所以至少需要 4。</p>
</li>
<li>
<p>B. 3：同样，<code>[10, 40, 30, 5]</code> 需要 4。</p>
</li>
<li>
<p>D. 5：从未达到过 5。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，正确答案是 C. 4。</p>
</div>
<h4 id="_可能的误区" class="discrete">可能的误区</h4>
<div class="paragraph">
<p>有时候可能会忽略括号内的计算对栈的影响。例如，可能会认为 <code>10</code> 和 <code>40</code> 是主要的，而忽略 <code>30</code> 和 <code>5</code> 的同时存在。因此，容易低估栈的最大需求。</p>
</div>
<div class="paragraph">
<p>另外，可能会混淆操作数栈和运算符栈的大小。本题只问操作数栈，所以不需要考虑运算符栈的大小。</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_19_两栈共享空间">2.19 两栈共享空间</h3>
<div class="paragraph">
<p>若栈采用顺序存储方式，现有两栈共享空间 V[1..n], top[i] 代表 i (i=1,2) 个栈的栈顶(两个栈都空时 top[1] = 1、top[2] = n)，栈 1 的底在 V[1]，栈 2 的底在 V[n]，则栈满(即 n 个元素暂存在这两个栈)的条件是（ ）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A top[1]= top[2]
B top[1]+ top[2]==1
C top[1]+ top[2]==n
D top[1]- top[2]==1</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p><strong>读懂题：</strong></p>
</div>
<div class="sect3">
<h4 id="_2_19_1_先弄懂两个栈都空时_top1_1top2_n">2.19.1 先弄懂：两个栈都空时 top[1] = 1、top[2] = n</h4>
<div class="paragraph">
<p>我们就以栈空时 top[1] = 1 来分析。</p>
</div>
<div class="paragraph">
<p>在栈的顺序存储（数组实现）中，栈顶指针 top 的含义和初始化值取决于具体的实现方式。通常有两种常见的定义方式：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>top 指向栈顶元素：</p>
<div class="ulist">
<ul>
<li>
<p>初始时栈为空，top 可以设置为 -1 或 0（取决于数组下标从 0 还是 1 开始）。</p>
</li>
<li>
<p>例如：</p>
<div class="ulist">
<ul>
<li>
<p>如果数组下标从 0 开始，初始 top = -1（表示无元素）。</p>
</li>
<li>
<p>如果数组下标从 1 开始，初始 top = 0（表示无元素）。</p>
</li>
</ul>
</div>
</li>
<li>
<p>入栈时先移动 top，再赋值：top++; stack[top] = x。</p>
</li>
<li>
<p>出栈时先取值，再移动 top：x = stack[top]; top--。</p>
</li>
</ul>
</div>
</li>
<li>
<p>top 指向栈顶元素的下一个位置（即“预指向”）：</p>
<div class="ulist">
<ul>
<li>
<p>初始时栈为空，top 指向栈的起始位置（如 top = 0 或 top = 1）。</p>
</li>
<li>
<p>例如：</p>
<div class="ulist">
<ul>
<li>
<p>如果数组下标从 0 开始，初始 top = 0（表示栈空）。</p>
</li>
<li>
<p>如果数组下标从 1 开始，初始 top = 1（表示栈空）。</p>
</li>
</ul>
</div>
</li>
<li>
<p>入栈时先赋值，再移动 top：stack[top] = x; top++。</p>
</li>
<li>
<p>出栈时先移动 top，再取值：top--; x = stack[top]。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>本题的具体定义</strong></p>
</div>
<div class="paragraph">
<p>题目中明确：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>栈1的底在 V[1]，初始时 top[1] = 1（栈空）。</p>
</li>
<li>
<p>栈2的底在 V[n]，初始时 top[2] = n（栈空）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，本题采用的是 top 指向栈顶元素的下一个位置 的实现方式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>栈1</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>初始 <code>top[1] = 1</code>（指向 <code>V[1]</code>，但 <code>V[1]</code> 尚未存储元素，表示栈空）。</p>
</li>
<li>
<p>入栈操作：<code>V[top[1]] = x; top[1]++</code>。</p>
</li>
<li>
<p>出栈操作：<code>top[1]--; x = V[top[1]]</code>。</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>栈2</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>初始 <code>top[2] = n</code>（指向 <code>V[n]</code>，但 <code>V[n]</code> 尚未存储元素，表示栈空）。</p>
</li>
<li>
<p>入栈操作：<code>V[top[2]] = x; top[2]--</code>（因为栈2向低地址增长）。</p>
</li>
<li>
<p>出栈操作：<code>top[2]++; x = V[top[2]]</code>。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>为什么 <code>top[1] = 1</code> 表示栈空？</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>因为 <code>top[1]</code> 指向的是 <strong>下一个可以插入的位置</strong>，而不是当前栈顶元素的位置。</p>
</li>
<li>
<p>初始时 <code>top[1] = 1</code>，表示下一个可以插入的位置是 <code>V[1]</code>，但 <code>V[1]</code> 尚未被占用，因此栈中无元素。</p>
</li>
<li>
<p>如果栈中有元素，<code>top[1]</code> 会指向比实际栈顶元素高一个的位置。例如：</p>
<div class="ulist">
<ul>
<li>
<p>插入一个元素 <code>x</code> 到栈1：</p>
<div class="ulist">
<ul>
<li>
<p><code>V[1] = x; top[1]++</code> → <code>top[1] = 2</code>。</p>
</li>
<li>
<p>此时栈顶元素是 <code>V[1]</code>，<code>top[1] = 2</code> 指向下一个空闲位置。</p>
</li>
</ul>
</div>
</li>
<li>
<p>再插入一个元素 <code>y</code>：</p>
<div class="ulist">
<ul>
<li>
<p><code>V[2] = y; top[1]++</code> → <code>top[1] = 3</code>。</p>
</li>
<li>
<p>此时栈顶元素是 <code>V[2]</code>，<code>top[1] = 3</code> 指向下一个空闲位置。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>类比现实场景</strong></p>
</div>
<div class="paragraph">
<p>可以类比书桌上的一摞书：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>top 指向的是“可以放下一本书的位置”，而不是“当前最上面的书”。</p>
</li>
<li>
<p>初始时桌面上没有书（栈空），top 指向桌面的起始位置（top = 1）。</p>
</li>
<li>
<p>放一本书后，top 移动到下一个空闲位置（top = 2），而实际最上面的书在位置 1。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>回到题目</strong></p>
</div>
<div class="paragraph">
<p>题目中栈满的条件是 <code>top[1] - top[2] == 1</code>，因为：
- 栈1从 <code>V[1]</code> 向高地址增长，<code>top[1]</code> 指向下一个空闲位置。
- 栈2从 <code>V[n]</code> 向低地址增长，<code>top[2]</code> 指向下一个空闲位置。
- 当 <code>top[1] - top[2] == 1</code> 时，表示两个栈的占用区域刚好连续接壤，且没有重叠或空隙，整个数组被占满。</p>
</div>
<div class="paragraph">
<p><strong>总结</strong></p>
</div>
<div class="paragraph">
<p>初始时 <code>top[1] = 1</code> 表示栈空，是因为：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>top[1]</code> 指向的是 <strong>下一个可插入的位置</strong>，而不是当前栈顶元素。</p>
</li>
<li>
<p>初始时 <code>V[1]</code> 未被占用，因此栈中无元素。</p>
</li>
<li>
<p>这是栈的一种常见实现方式（尤其是双栈共享空间时），目的是统一指针的语义。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>最终答案: <strong>D. top[1] - top[2] == 1</strong></p>
</div>
</div>
<div class="sect3">
<h4 id="_2_19_2_再弄懂栈1的底在_v1栈_2_的底在_vn">2.19.2 再弄懂：栈1的底在 V[1]，栈 2 的底在 V[n]</h4>
<div class="paragraph">
<p>“栈1的底在 V[1]” 的含义</p>
</div>
<div class="paragraph">
<p>在顺序存储的双栈共享空间问题中，<strong>“栈1的底在 V[1]”</strong> 表示：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>栈1的固定底部位置</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>栈1的<strong>最底层元素</strong>（即<strong>栈底</strong>）始终存储在数组 <code>V</code> 的第一个位置 <code>V[1]</code>。</p>
</li>
<li>
<p>这意味着栈1的存储空间从 <code>V[1]</code> 开始，向数组的高地址方向（即 <code>V[2], V[3], &#8230;&#8203;, V[n]</code>）增长。</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>栈1的增长方向</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>栈1的入栈操作（<code>push</code>）会使 <code>top[1]</code> <strong>增加</strong>（向 <code>V[n]</code> 方向移动）。</p>
</li>
<li>
<p>栈1的出栈操作（<code>pop</code>）会使 <code>top[1]</code> <strong>减少</strong>（向 <code>V[1]</code> 方向移动）。</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>栈1的初始状态（栈空）</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>初始时，栈1为空，<code>top[1] = 1</code>，表示栈顶指针指向 <code>V[1]</code>（但 <code>V[1]</code> 尚未存储有效数据）。</p>
</li>
<li>
<p>当第一个元素入栈时，<code>V[1]</code> 被填充，<code>top[1]</code> 移动到 <code>V[2]</code>（指向下一个可插入位置）。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>类比现实场景</strong></p>
</div>
<div class="paragraph">
<p>假设有一个书架（数组 <code>V</code>），两个栈分别从两端向中间摆放书籍：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>栈1</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>从书架的最左侧（<code>V[1]</code>）开始放书，<code>top[1]</code> 指向下一个可放书的位置。</p>
</li>
<li>
<p>初始时没有书（栈空），<code>top[1] = 1</code>（指向第一个空位 <code>V[1]</code>）。</p>
</li>
<li>
<p>放入一本书后，<code>top[1]</code> 移动到 <code>V[2]</code>（指向下一个空位）。</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>栈2</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>从书架的最右侧（<code>V[n]</code>）开始放书，<code>top[2]</code> 指向下一个可放书的位置。</p>
</li>
<li>
<p>初始时没有书（栈空），<code>top[2] = n</code>（指向第一个空位 <code>V[n]</code>）。</p>
</li>
<li>
<p>放入一本书后，<code>top[2]</code> 移动到 <code>V[n-1]</code>（指向下一个空位）。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>为什么“栈1的底在 V[1]”是固定的？</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>栈的“底”是固定的，因为栈的存储空间是顺序的（数组实现），不能动态调整起始位置。</p>
</li>
<li>
<p>栈1的所有操作（push/pop）都只能在 V[1] 到 top[1] 的范围内进行。</p>
</li>
<li>
<p>栈2同理，其栈底固定在 V[n]，向 V[1] 方向增长。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>栈满的条件推导</strong></p>
</div>
<div class="paragraph">
<p>当两个栈的栈顶指针相遇或交叉时，表示空间已满：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>栈1的 top[1] 指向下一个可插入位置（向高地址增长）。</p>
</li>
<li>
<p>栈2的 top[2] 指向下一个可插入位置（向低地址增长）。</p>
</li>
<li>
<p>栈满时：top[1] - 1（栈1的最后一个元素位置）和 top[2] + 1（栈2的最后一个元素位置）相邻。</p>
<div class="ulist">
<ul>
<li>
<p>即 top[1] - 1 == top[2] 或 top[1] == top[2] + 1。</p>
</li>
<li>
<p>题目中采用 top[1] - top[2] == 1 作为栈满条件（选项 D 正确）。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>总结</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>“栈1的底在 V[1]”</strong> 表示栈1的存储空间从 <code>V[1]</code> 开始，向高地址方向增长。</p>
</li>
<li>
<p><strong>初始时 <code>top[1] = 1</code> 表示栈空</strong>，因为 <code>top[1]</code> 指向的是下一个可插入位置（而非当前栈顶元素）。</p>
</li>
<li>
<p><strong>栈满的条件是 <code>top[1] - top[2] == 1</code></strong>（两个栈的栈顶指针相邻）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>最终答案</strong> D. top[1] - top[2] == 1</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_20_队列长度">2.20 队列长度</h3>
<div class="paragraph">
<p>设某循环队列 Q 的定义中有 front 和 rear 两个域变量，其中，front 指示队头元素的位置，rear 指示队尾元素之后的位置，如下图所示。若该队列的容量为 M，则其长度为（D）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/queue_length.png" alt="queue length">
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>A (Q.rear-Q.front+1)
B (Q.rear-Q.front+M)
C (Q.rear-Q.front+1)%M
D (Q.rear-Q.front+M)%M</pre>
</div>
</div>
<div class="paragraph">
<p>本题考查数据结构基础知识。</p>
</div>
<div class="paragraph">
<p>根据题目中所给的示意图，Q.front 为队头元素的指针，Q.rear 表示队尾元素之后的一个空位置，故队列长度为Q.rear-Q.front</p>
</div>
<div class="paragraph">
<p>由于队列中存储位置编号是在 0～M－1 之间循环的，Q.rear-Q.front 的结果有可能是负数，故在 Q.rear-Q.front基础上加上 M 可恢复为正数，而此正数有可能超出 0～M－1 的范围，故用整除，M 取余运算恢复一下，因此长度计算的式子为 (Q.rear-Q.front+M)%M。</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_21_线性探查法解决冲突构造哈希表">2.21 线性探查法解决冲突构造哈希表</h3>
<div class="paragraph">
<p>设散列函数为 H（key）= key % 11，对于关键码序列（23，40，91，17，19，10，31，65，26），用线性探查法解决冲突构造的哈希表为（ ）。</p>
</div>
<hr>
<div class="paragraph">
<p>直接计算吧，不列出选项了。</p>
</div>
<div class="paragraph">
<p>构造哈希表方法：线性探查法（开放地址法）
模 11 插入过程：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>23 % 11 = 1 → 插入地址 1</p>
</li>
<li>
<p>40 % 11 = 7 → 插入地址 7</p>
</li>
<li>
<p>91 % 11 = 3 → 插入地址 3</p>
</li>
<li>
<p>17 % 11 = 6 → 插入地址 6</p>
</li>
<li>
<p>19 % 11 = 8 → 插入地址 8</p>
</li>
<li>
<p>10 % 11 = 10 → 插入地址 10</p>
</li>
<li>
<p>31 % 11 = 9 → 插入地址 9</p>
</li>
<li>
<p>65 % 11 = 10 → 地址 10 已占 → 往下循环探查地址为 0 → 插入地址 0</p>
</li>
<li>
<p>26 % 11 = 4 → 插入地址 4</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最终哈希表：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3337%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">哈希地址</th>
<th class="tableblock halign-center valign-top">0</th>
<th class="tableblock halign-center valign-top">1</th>
<th class="tableblock halign-center valign-top">2</th>
<th class="tableblock halign-center valign-top">3</th>
<th class="tableblock halign-center valign-top">4</th>
<th class="tableblock halign-center valign-top">5</th>
<th class="tableblock halign-center valign-top">6</th>
<th class="tableblock halign-center valign-top">7</th>
<th class="tableblock halign-center valign-top">8</th>
<th class="tableblock halign-center valign-top">9</th>
<th class="tableblock halign-center valign-top">10</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">关键码</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">65</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">23</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">91</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">26</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">17</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">40</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">19</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">31</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_2_22_三对角矩阵">2.22 三对角矩阵</h3>
<div class="paragraph">
<p>将三对角矩阵 A[1…100][1&#8230;&#8203;100] 按行优先存入一维数组 B[1&#8230;&#8203;298] 中，A中元素 A[66][65] 在数组 B 中的位置k为（B）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 198
B 195
C 197
D 196</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>对于三对角矩阵，将 A[1..n][1..n] 压缩至 B[1..3n-2] 时，a(ij) 与 b(k) 的对应关系为 k=2i+j-2。
则 A 中的元素 A[66][65] 在数组 B 中的位置 k=2*66+65-2=195</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_3_算法">3 算法</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_3_1_算法策略和时间复杂度">3.1 算法策略和时间复杂度</h3>
<div class="paragraph">
<p>某货车运输公司有一个中央仓库和n个运输目的地，每天要从中央仓库将货物运输到所有的运输目的地，到达每个运输目的地一次且仅一次，最后回到中央仓库。在两个地点i和j之间运输货物存在费用cij。为求解旅行费用总和最小的运输路径，设计如下算法：首先选择离中央仓库最近的运输目的地1，然后选择离运输目的地1最近的运输目的地2,……，每次在未访问过的运输目的地中选择离当前运输目的地最近的运输目的地，最后回到中央仓库。</p>
</div>
<div class="paragraph">
<p>则该算法采用了（ ）算法设计策略，其时间复杂度为（ ）。</p>
</div>
<hr>
<div class="ulist">
<ul>
<li>
<p>分治（Divide and Conquer）：将问题分解为若干子问题，递归解决子问题后合并结果。这里没有明显的分解和合并过程。</p>
</li>
<li>
<p>动态规划（Dynamic Programming）：将问题分解为重叠子问题，保存子问题的解以避免重复计算。这里没有保存子问题的解或利用重叠子问题的特性。</p>
</li>
<li>
<p><mark>贪心（Greedy）：在每一步选择当前看起来最优的局部解，希望最终得到全局最优解。这里的“每次选择最近的未访问目的地”正是贪心策略的体现。</mark></p>
</li>
<li>
<p>回溯（Backtracking）：通过尝试所有可能的解，并在发现当前路径不可能得到最优解时回溯。这里没有回溯的过程。</p>
</li>
</ul>
</div>
<hr>
<div class="paragraph">
<p>时间复杂度分析
贪心的最近邻算法的时间复杂度可以如下分析：</p>
</div>
<div class="paragraph">
<p>从中央仓库出发，选择最近的未访问目的地：需要比较n个目的地的距离，O(n)时间。</p>
</div>
<div class="paragraph">
<p>从第一个目的地选择下一个最近的未访问目的地：需要比较n-1个目的地的距离，O(n)时间。</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>从第n-1个目的地选择最后一个未访问目的地：O(1)时间。</p>
</div>
<div class="paragraph">
<p>最后返回中央仓库：O(1)时间。</p>
</div>
<div class="paragraph">
<p>总的时间复杂度是：O(n) + O(n-1) + &#8230;&#8203; + O(1) = O(n^2)。</p>
</div>
<hr>
<div class="paragraph">
<p>总结时间复杂度	含义	例子</p>
</div>
<div class="ulist">
<ul>
<li>
<p>O(1)	一次搞定	数组取元素 arr[0]</p>
</li>
<li>
<p>O(log n)	每次砍掉一半数据	二分查找、平衡二叉树的查找</p>
</li>
<li>
<p>O(n)	遍历所有数据	找最大值、线性查找</p>
</li>
<li>
<p>O(n log n)	分治 + 每层处理 n 次	归并排序、快速排序</p>
</li>
<li>
<p>O(n²)	双重循环	冒泡排序、最近邻贪心 TSP</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_3_1_1_插入排序算法时间和空间复杂度">3.1.1 插入排序算法时间和空间复杂度</h4>
<div class="paragraph">
<p>对 n 个基本有序的整数进行排序，若采用插入排序算法，则时间和空间复杂度分别为（D）</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A O(n2)和O(n)
B O(n)和O(n)
C O(n2)和O(1)
D O(n)和O(1)</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>算法简介：插入排序是一种简单直观的排序算法，其基本思想是从第二个元素开始，将每个元素插入到它前面已经排好序的子数组中，使整个数组逐步变成有序。</p>
</div>
<div class="paragraph">
<p>若数据基本有序，对插入排序算法而言，则可以在近似线性时间内完成排序，即O(n);</p>
</div>
<div class="paragraph">
<p>插入排序算法在排序时仅需要一个额外的存储空间，即空间复杂度均为常数时间复杂度 O(1)。</p>
</div>
<div class="sect4">
<h5 id="_3_1_1_1_python_插入排序源代码">3.1.1.1 python 插入排序&#8212;&#8203;源代码</h5>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="python"><span></span><span class="tok-k">def</span> <span class="tok-nf">insertion_sort</span><span class="tok-p">(</span><span class="tok-n">arr</span><span class="tok-p">):</span>
    <span class="tok-nb">print</span><span class="tok-p">(</span><span class="tok-s2">&quot;初始数组:&quot;</span><span class="tok-p">,</span> <span class="tok-n">arr</span><span class="tok-p">)</span>
    <span class="tok-k">for</span> <span class="tok-n">i</span> <span class="tok-ow">in</span> <span class="tok-nb">range</span><span class="tok-p">(</span><span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-n">arr</span><span class="tok-p">)):</span>
        <span class="tok-n">key</span> <span class="tok-o">=</span> <span class="tok-n">arr</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">]</span>
        <span class="tok-n">j</span> <span class="tok-o">=</span> <span class="tok-n">i</span> <span class="tok-o">-</span> <span class="tok-mi">1</span>
        <span class="tok-nb">print</span><span class="tok-p">(</span><span class="tok-sa">f</span><span class="tok-s2">&quot;</span><span class="tok-se">\n</span><span class="tok-s2">第 </span><span class="tok-si">{</span><span class="tok-n">i</span><span class="tok-si">}</span><span class="tok-s2"> 步：准备插入元素 </span><span class="tok-si">{</span><span class="tok-n">key</span><span class="tok-si">}</span><span class="tok-s2">（来自位置 </span><span class="tok-si">{</span><span class="tok-n">i</span><span class="tok-si">}</span><span class="tok-s2">）&quot;</span><span class="tok-p">)</span>

        <span class="tok-c1"># 将大于 key 的元素向后移</span>
        <span class="tok-k">while</span> <span class="tok-n">j</span> <span class="tok-o">&gt;=</span> <span class="tok-mi">0</span> <span class="tok-ow">and</span> <span class="tok-n">arr</span><span class="tok-p">[</span><span class="tok-n">j</span><span class="tok-p">]</span> <span class="tok-o">&gt;</span> <span class="tok-n">key</span><span class="tok-p">:</span>
            <span class="tok-nb">print</span><span class="tok-p">(</span><span class="tok-sa">f</span><span class="tok-s2">&quot;</span><span class="tok-se">\t</span><span class="tok-s2">移动: 元素 </span><span class="tok-si">{</span><span class="tok-n">arr</span><span class="tok-p">[</span><span class="tok-n">j</span><span class="tok-p">]</span><span class="tok-si">}</span><span class="tok-s2"> 从位置 </span><span class="tok-si">{</span><span class="tok-n">j</span><span class="tok-si">}</span><span class="tok-s2"> 移动到位置 </span><span class="tok-si">{</span><span class="tok-n">j</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-si">}</span><span class="tok-s2">&quot;</span><span class="tok-p">)</span>
            <span class="tok-n">arr</span><span class="tok-p">[</span><span class="tok-n">j</span> <span class="tok-o">+</span> <span class="tok-mi">1</span><span class="tok-p">]</span> <span class="tok-o">=</span> <span class="tok-n">arr</span><span class="tok-p">[</span><span class="tok-n">j</span><span class="tok-p">]</span>
            <span class="tok-n">j</span> <span class="tok-o">-=</span> <span class="tok-mi">1</span>

        <span class="tok-n">arr</span><span class="tok-p">[</span><span class="tok-n">j</span> <span class="tok-o">+</span> <span class="tok-mi">1</span><span class="tok-p">]</span> <span class="tok-o">=</span> <span class="tok-n">key</span>
        <span class="tok-nb">print</span><span class="tok-p">(</span><span class="tok-sa">f</span><span class="tok-s2">&quot;</span><span class="tok-se">\t</span><span class="tok-s2">插入: 元素 </span><span class="tok-si">{</span><span class="tok-n">key</span><span class="tok-si">}</span><span class="tok-s2"> 到位置 </span><span class="tok-si">{</span><span class="tok-n">j</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-si">}</span><span class="tok-s2">&quot;</span><span class="tok-p">)</span>
        <span class="tok-nb">print</span><span class="tok-p">(</span><span class="tok-s2">&quot;</span><span class="tok-se">\t</span><span class="tok-s2">当前数组状态:&quot;</span><span class="tok-p">,</span> <span class="tok-n">arr</span><span class="tok-p">)</span>

    <span class="tok-nb">print</span><span class="tok-p">(</span><span class="tok-s2">&quot;</span><span class="tok-se">\n</span><span class="tok-s2">最终排序结果:&quot;</span><span class="tok-p">,</span> <span class="tok-n">arr</span><span class="tok-p">)</span>
    <span class="tok-k">return</span> <span class="tok-n">arr</span>

<span class="tok-c1"># 测试代码</span>
<span class="tok-n">arr</span> <span class="tok-o">=</span> <span class="tok-p">[</span><span class="tok-mi">5</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">6</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
<span class="tok-n">insertion_sort</span><span class="tok-p">(</span><span class="tok-n">arr</span><span class="tok-o">.</span><span class="tok-n">copy</span><span class="tok-p">())</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>代码很巧妙，需要理解它的时间复杂度和空间复杂度。</p>
</div>
<div class="literalblock">
<div class="title">输出结果</div>
<div class="content">
<pre>初始数组: [5, 2, 4, 6, 1, 3]

第 1 步：准备插入元素 2（来自位置 1）
	移动: 元素 5 从位置 0 移动到位置 1
	插入: 元素 2 到位置 0
	当前数组状态: [2, 5, 4, 6, 1, 3]

第 2 步：准备插入元素 4（来自位置 2）
	移动: 元素 5 从位置 1 移动到位置 2
	插入: 元素 4 到位置 1
	当前数组状态: [2, 4, 5, 6, 1, 3]

第 3 步：准备插入元素 6（来自位置 3）
	插入: 元素 6 到位置 3
	当前数组状态: [2, 4, 5, 6, 1, 3]

第 4 步：准备插入元素 1（来自位置 4）
	移动: 元素 6 从位置 3 移动到位置 4
	移动: 元素 5 从位置 2 移动到位置 3
	移动: 元素 4 从位置 1 移动到位置 2
	移动: 元素 2 从位置 0 移动到位置 1
	插入: 元素 1 到位置 0
	当前数组状态: [1, 2, 4, 5, 6, 3]

第 5 步：准备插入元素 3（来自位置 5）
	移动: 元素 6 从位置 4 移动到位置 5
	移动: 元素 5 从位置 3 移动到位置 4
	移动: 元素 4 从位置 2 移动到位置 3
	插入: 元素 3 到位置 2
	当前数组状态: [1, 2, 3, 4, 5, 6]

最终排序结果: [1, 2, 3, 4, 5, 6]</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_3_1_1_2_python_插入排序活动图">3.1.1.2 python 插入排序&#8212;&#8203;活动图</h5>
<div class="imageblock">
<div class="content">
<img src="img/diagram-2025-05-14-103821.svg" alt="diagram 2025 05 14 103821" width="386" height="942">
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_3_1_2_快速排序算法时间和空间复杂度">3.1.2 快速排序算法时间和空间复杂度</h4>
<div class="paragraph">
<p>对 n 个基本有序的整数进行排序，若采用快速排序算法，则时间和空间复杂度分别为（A）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A O(n^2)和O(n)
B O(nlogn)和O(n)
C O(n^2)和O(1)
D O(nlogn)和O(1)</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>快速排序的核心是 “分治法”（Divide and Conquer）：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>选一个“基准”元素（pivot）。</p>
</li>
<li>
<p>把数组分成两个部分：</p>
<div class="ulist">
<ul>
<li>
<p>左边部分：所有小于 pivot 的元素。</p>
</li>
<li>
<p>右边部分：所有大于等于 pivot 的元素。</p>
</li>
</ul>
</div>
</li>
<li>
<p>分别对左右两部分递归地进行排序。</p>
</li>
<li>
<p>把排序好的左边 + pivot + 排序好的右边合并起来。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>就是这样一步一步拆分成小问题，最后拼回一个有序的结果。</p>
</div>
<h4 id="_示例演示" class="discrete">示例演示</h4>
<div class="paragraph">
<p>对数组 <code>[5, 2, 4, 6, 1, 3]</code> 执行 quicksort，过程如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>第一次：pivot = 5</p>
<div class="ulist">
<ul>
<li>
<p>左边：[2, 4, 1, 3]</p>
</li>
<li>
<p>右边：[6]</p>
</li>
</ul>
</div>
</li>
<li>
<p>对左边 <code>[2, 4, 1, 3]</code> 执行 quicksort：</p>
<div class="ulist">
<ul>
<li>
<p>pivot = 2</p>
</li>
<li>
<p>左边：[1]</p>
</li>
<li>
<p>右边：[4, 3]</p>
</li>
</ul>
</div>
</li>
<li>
<p>对 <code>[4, 3]</code> 执行 quicksort：</p>
<div class="ulist">
<ul>
<li>
<p>pivot = 4</p>
</li>
<li>
<p>左边：[3]</p>
</li>
<li>
<p>右边：[]</p>
</li>
</ul>
</div>
</li>
<li>
<p>合并过程：</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>[1] + [2] + [3, 4] = [1, 2, 3, 4]</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>最终结果：</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>[1, 2, 3, 4] + [5] + [6] = [1, 2, 3, 4, 5, 6]</pre>
</div>
</div>
<h4 id="_为什么叫快速排序" class="discrete">为什么叫“快速排序”？</h4>
<div class="paragraph">
<p>快速排序之所以叫“快速”，是因为它的平均性能非常优秀：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>平均时间复杂度：<code>O(n log n)</code></p>
</li>
<li>
<p>最坏情况：<code>O(n^2)</code>（当 pivot 选得很差时）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>它在大多数实际应用中比冒泡、选择、插入等排序算法快很多，因此得名“快速排序”。</p>
</div>
<h4 id="_总结" class="discrete">总结</h4>
<div class="paragraph">
<p>快速排序之所以能够排序成功，是因为它在每一步都将数据划分为两部分：
* 小的元素在左边
* 大的元素在右边</p>
</div>
<div class="paragraph">
<p>通过递归地排序这两部分，最终拼出一个完整有序的结果。</p>
</div>
<div class="sect4">
<h5 id="_3_1_2_1_python_快速排序源代码">3.1.2.1 python 快速排序&#8212;&#8203;源代码</h5>
<div class="paragraph">
<p>下面是用 Python 实现的 快速排序（Quicksort） 源代码，采用的是经典的递归方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="python"><span></span><span class="tok-k">def</span> <span class="tok-nf">quicksort</span><span class="tok-p">(</span><span class="tok-n">arr</span><span class="tok-p">):</span>
    <span class="tok-k">if</span> <span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-n">arr</span><span class="tok-p">)</span> <span class="tok-o">&lt;=</span> <span class="tok-mi">1</span><span class="tok-p">:</span>
        <span class="tok-k">return</span> <span class="tok-n">arr</span>
    <span class="tok-n">pivot</span> <span class="tok-o">=</span> <span class="tok-n">arr</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">]</span>  <span class="tok-c1"># 选取第一个元素作为基准</span>
    <span class="tok-n">left</span> <span class="tok-o">=</span>  <span class="tok-p">[</span><span class="tok-n">x</span> <span class="tok-k">for</span> <span class="tok-n">x</span> <span class="tok-ow">in</span> <span class="tok-n">arr</span><span class="tok-p">[</span><span class="tok-mi">1</span><span class="tok-p">:]</span> <span class="tok-k">if</span> <span class="tok-n">x</span> <span class="tok-o">&lt;</span> <span class="tok-n">pivot</span><span class="tok-p">]</span>     <span class="tok-c1"># 小于 pivot 的元素</span>
    <span class="tok-n">right</span> <span class="tok-o">=</span> <span class="tok-p">[</span><span class="tok-n">x</span> <span class="tok-k">for</span> <span class="tok-n">x</span> <span class="tok-ow">in</span> <span class="tok-n">arr</span><span class="tok-p">[</span><span class="tok-mi">1</span><span class="tok-p">:]</span> <span class="tok-k">if</span> <span class="tok-n">x</span> <span class="tok-o">&gt;=</span> <span class="tok-n">pivot</span><span class="tok-p">]</span>    <span class="tok-c1"># 大于等于 pivot 的元素</span>
    <span class="tok-k">return</span> <span class="tok-n">quicksort</span><span class="tok-p">(</span><span class="tok-n">left</span><span class="tok-p">)</span> <span class="tok-o">+</span> <span class="tok-p">[</span><span class="tok-n">pivot</span><span class="tok-p">]</span> <span class="tok-o">+</span> <span class="tok-n">quicksort</span><span class="tok-p">(</span><span class="tok-n">right</span><span class="tok-p">)</span>

<span class="tok-n">nums</span> <span class="tok-o">=</span> <span class="tok-p">[</span><span class="tok-mi">5</span><span class="tok-p">,</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-mi">4</span><span class="tok-p">,</span> <span class="tok-mi">6</span><span class="tok-p">,</span> <span class="tok-mi">1</span><span class="tok-p">,</span> <span class="tok-mi">3</span><span class="tok-p">]</span>
<span class="tok-n">sorted_nums</span> <span class="tok-o">=</span> <span class="tok-n">quicksort</span><span class="tok-p">(</span><span class="tok-n">nums</span><span class="tok-p">)</span>
<span class="tok-nb">print</span><span class="tok-p">(</span><span class="tok-n">sorted_nums</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>===</p>
</div>
</div>
<div class="sect4">
<h5 id="_3_1_2_2_python_快速排序活动图">3.1.2.2 python 快速排序&#8212;&#8203;活动图</h5>
<div class="imageblock">
<div class="content">
<img src="img/diagram-2025-05-14-113805.svg" alt="diagram 2025 05 14 113805" width="396" height="495">
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_3_1_3_根据代码求时间复杂度">3.1.3 根据代码求时间复杂度</h4>
<div class="paragraph">
<p>设n是描述问题规模的非负整数，下面程序片段的时间复杂度是（A）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>x=2；
while(x&lt;n/2)
    x=2*x；</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>A O(log2n)
B O(n)
C O(nlog2n)
D O(n^2)</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>该程序片段的时间复杂度可以通过分析循环次数来确定。</p>
</div>
<div class="paragraph">
<p>初始时，x=2，每次循环x被乘以2，直到x &gt;= n/2。</p>
</div>
<div class="paragraph">
<p>设循环执行 k 次后，x 的值为 \(2^{k+1}\)。
终止条件为 \(2^{k+1} \ge \frac{n}{2}\)，
解得 \(k+1 \ge \log_2{\frac{n}{2}}\)，即 \(k \ge \log_2{n} - 2\)
忽略常数项后，时间复杂度为 \(O(\log_2{n})\)。</p>
</div>
<div class="paragraph">
<p>答案：A O(log2n)</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_2_排序">3.2 排序</h3>
<div class="sect3">
<h4 id="_3_2_1_简单选择排序selection_sort">3.2.1 简单选择排序（Selection Sort）</h4>
<div class="paragraph">
<p>采用简单选择排序算法对序列(49，38，65，97，76，13，27，49)进行非降序排序，两趟后的序列为（A）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A (13，27，65，97，76，49，38，49)
B (38，49，65，76，13，27，49，97)
C (13，38，65，97，76，49，27，49)
D (38，49，65，13，27，49，76，97)</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>简单选择排序（Selection Sort）是每一趟从待排序的序列中选出最小的元素，放到已排序序列的末尾。</p>
</div>
<div class="paragraph">
<p>给定序列：(49, 38, 65, 97, 76, 13, 27, 49)</p>
</div>
<div class="paragraph">
<p>第一趟排序：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>找到最小值，序列中最小的是13。</p>
</li>
<li>
<p>把13与第一个元素49交换，得到：(13, 38, 65, 97, 76, 49, 27, 49)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>第二趟排序：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从剩余序列(38, 65, 97, 76, 49, 27, 49)中找最小值，最小值是27。</p>
</li>
<li>
<p>把27和第二个元素38交换，得到：(13, 27, 65, 97, 76, 49, 38, 49)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这就是两趟排序后的序列。所以答案为 A</p>
</div>
</div>
<div class="sect3">
<h4 id="_3_2_2_快速排序初始排列">3.2.2 快速排序初始排列</h4>
<div class="paragraph">
<p>在快速排序过程中，需要设立基准元素并划分序列来进行排序，若序列由元素 {12,25,3,45,52,67,85} 构成，则初始排列为（ A），排序效率最高（令序列的第一个元素为基准元素）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 45，12，3，25，67，52，85
B 85，67，52，45，3，25，12
C 12，25，3，45，52，67，85
D 45，12，25，3，85，67，52</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>在快速排序（Quick Sort）中，选择“基准元素”（pivot）并将序列划分为左右两个子序列的效率对整体排序性能有显著影响。</p>
</div>
<div class="paragraph">
<p>题目设定为</p>
</div>
<div class="ulist">
<ul>
<li>
<p>原始序列：{12, 25, 3, 45, 52, 67, 85}</p>
</li>
<li>
<p>使用第一个元素为基准元素</p>
</li>
<li>
<p>要求判断哪种初始排列下划分效率最高</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>快速排序的关键步骤（简化）：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>选定一个基准元素（pivot）。</p>
</li>
<li>
<p>将序列划分为两个部分：</p>
<div class="ulist">
<ul>
<li>
<p>左边：比基准元素小的数；</p>
</li>
<li>
<p>右边：比基准元素大的数。</p>
</li>
</ul>
</div>
</li>
<li>
<p>对两部分递归地进行排序。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>对选项A进行分析：A: 45，12，3，25，67，52，85</p>
</div>
<div class="ulist">
<ul>
<li>
<p>以第一个元素 45 为基准。</p>
</li>
<li>
<p>划分结果：</p>
</li>
<li>
<p>小于 45 的部分：12，3，25 → 3 个元素</p>
</li>
<li>
<p>大于 45 的部分：67，52，85 → 3 个元素</p>
</li>
<li>
<p>划分非常均匀，是理想的情况。</p>
</li>
<li>
<p>所以此时排序效率最高。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对其他选项进行分析：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>B: 85，67，52，45，3，25，12</p>
</li>
<li>
<p>以 85 为基准。</p>
</li>
<li>
<p>小于 85 的有 6 个，大于的为 0 → 极不均匀 → 最差情况。</p>
</li>
<li>
<p>C: 12，25，3，45，52，67，85</p>
</li>
<li>
<p>以 12 为基准。</p>
</li>
<li>
<p>小于 12 的为 0 个，大于的为 6 → 也是极不均匀。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>D: 45，12，25，3，85，67，52
    * 同样以 45 为基准。
    * 小于 45 的：12，25，3 → 3 个
    * 大于 45 的：85，67，52 → 3 个
    * 和 A 一样，也很均匀。</p>
</div>
<div class="paragraph">
<p>但区别在于：选项A中的较小元素和较大元素分别在一侧，便于实现高效的原地划分操作，而 D 中较小和较大的元素是交错分布的，可能导致划分步骤变得复杂，效率略低。</p>
</div>
<div class="paragraph">
<p>最终结论：答案是 A，因为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用第一个元素为基准时，它能把数组划分为大小接近的两部分；</p>
</li>
<li>
<p>快速排序在这种情况下效率最高（时间复杂度接近 O(n log n)）。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_3_2_3_猜排序算法">3.2.3 猜排序算法</h4>
<div class="paragraph">
<p>对一组数据 2,12,16,88,5,10 进行排序，如果前 3 趟排序结果如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>第一趟排序结果：2,12,16,5,10,88</p>
</li>
<li>
<p>第二趟排序结果：2,12,5,10,16,88</p>
</li>
<li>
<p>第三趟排序结果：2,5,10,12,16,88</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>则采用的排序算法可能是（A）</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 冒泡排序
B 希尔排序
C 归并排序
D 基数排序</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>解析：</p>
</div>
<div class="paragraph">
<p>分析排序过程：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>第一趟：88 被移动到了最后一位，表现为将最大元素“冒”到末尾。</p>
</li>
<li>
<p>第二趟：16 被移到倒数第二位，继续“冒”出次大元素。</p>
</li>
<li>
<p>第三趟：前半部分继续调整，最后形成整体有序序列。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该过程符合冒泡排序的特点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每一趟比较相邻元素，交换顺序错误的对。</p>
</li>
<li>
<p>每一趟结束后，最大元素沉到正确位置。</p>
</li>
<li>
<p>多趟执行，最终完成排序。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>排除其他选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>B. 希尔排序：采用分组排序，不是这种逐步交换相邻元素的过程。</p>
</li>
<li>
<p>C. 归并排序：采用分治合并，不会有线性逐步“冒出”最大值的现象。</p>
</li>
<li>
<p>D. 基数排序：非比较类排序，按位处理，过程差异较大。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>答案：</p>
</div>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p>冒泡排序</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_3_背包问题">3.3 背包问题</h3>
<div class="paragraph">
<p>考虑下述背包问题的实例。
有 5 件物品，背包容量为 100，每件物品的价值和重量如下表所示，并已经按照物品的单位重量价值从大到小排好序，<mark>根据物品单位重量价值大优先的策略装入背包中</mark>，则采用了（B）设计策略。</p>
</div>
<div class="paragraph">
<p>考虑 0|1 背包问题（每件物品或者全部放入或者全部不装入背包）和部分背包问题（物品可以部分装入背包），求解该实例，得到的最大价值分别为（C）。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">物品编号</th>
<th class="tableblock halign-center valign-top">价值</th>
<th class="tableblock halign-center valign-top">重量</th>
<th class="tableblock halign-center valign-top">单位重量价值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">50</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">25</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">180</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">30</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">225</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">45</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">50</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>第一问选项:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 分治
B 贪心
C 动态规划
D 回溯</pre>
</div>
</div>
<div class="paragraph">
<p>第二问选项:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 605和630
B 605和605
C 430和630
D 630和430</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>第二问答案：C. 430 和 630</p>
</div>
<div class="paragraph">
<p>0|1 背包（贪心选物）：只能整件选，按顺序选入 1、2、3 号物品，重量共 60，价值为 430</p>
</div>
<div class="paragraph">
<p>部分背包（贪心法）：可以部分选物，总价值为 630</p>
</div>
<div class="paragraph">
<p>注意：0|1 背包这里并非求最优解（605），而是要求在<mark>贪心策略</mark>下的结果。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_4_状态转换机">4 状态转换机</h2>
<div class="sectionbody">
<div class="paragraph">
<p>下图所示为一个不确定有限自动机(NFA)的状态转换图，与该 NFA 等价的 DFA 是 ()</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-2025-05-10-125143-NFA.svg" alt="graphviz 2025 05 10 125143 NFA" width="679" height="107">
</div>
<div class="title">Figure 5. 解析：NFA 正规集 0 (0|11*) 0 &#8594; <strong>答案为 C</strong></div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
DFA 不允许有 ε 空输入。
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-2025-05-10-125311-A.svg" alt="graphviz 2025 05 10 125311 A" width="329" height="107">
</div>
<div class="title">Figure 6. 选项 A &#8594; 正规集为 01*0;</div>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-2025-05-10-125444-B.svg" alt="graphviz 2025 05 10 125444 B" width="434" height="107">
</div>
<div class="title">Figure 7. 选项 B &#8594; 正规集为 001*0</div>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-2025-05-10-125457-C.svg" alt="graphviz 2025 05 10 125457 C" width="434" height="107">
</div>
<div class="title">Figure 8. 选项 C &#8594; 正规集为 0(0|11*)0</div>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-2025-05-10-125519-D.svg" alt="graphviz 2025 05 10 125519 D" width="434" height="107">
</div>
<div class="title">Figure 9. 选项 D -》 正规集为 01*00</div>
</div>
<div class="sect2">
<h3 id="_4_1_正规集识别字符种类个数">4.1 正规集识别字符种类个数</h3>
<div class="paragraph">
<p>正规集(ab|c)(1|2|3),可以识别的字符种类有（D）个</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 1
B 2
C 3
D 6</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>解析：该正则表达式由两个部分组成</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>(ab|c)</code>：表示可以是字符串 <code>"ab"</code> 或字符 <code>"c"</code>。</p>
</li>
<li>
<p><code>(1|2|3)</code>：表示可以是字符 <code>"1"</code>、<code>"2"</code> 或 <code>"3"</code>。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>匹配的所有字符串：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ab1</code></p>
</li>
<li>
<p><code>ab2</code></p>
</li>
<li>
<p><code>ab3</code></p>
</li>
<li>
<p><code>c1</code></p>
</li>
<li>
<p><code>c2</code></p>
</li>
<li>
<p><code>c3</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>共计 6 个匹配字符串。</p>
</div>
<div class="paragraph">
<p>题目问的是可以识别的字符种类个数，不是字符串个数，而是字符种类。</p>
</div>
<div class="paragraph">
<p>故涉及的字符种类是从所有字符串中提取不重复的字符为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>a</code></p>
</li>
<li>
<p><code>b</code></p>
</li>
<li>
<p><code>c</code></p>
</li>
<li>
<p><code>1</code></p>
</li>
<li>
<p><code>2</code></p>
</li>
<li>
<p><code>3</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>共 6 种字符。</p>
</div>
</div>
<div class="sect2">
<h3 id="_4_2_文法推导正规集">4.2 文法推导正规集</h3>
<div class="paragraph">
<p>已知文法G: S&#8594;A0|B1，A&#8594;S1|1，B&#8594;S0|0，其中 S 是开始符号。从 S 出发可以推导出（C） 。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 所有由0构成的字符串
B 所有由1构成的字符串
C 某些0和1个数相等的字符串
D 所有0和1个数不同的字符串</pre>
</div>
</div>
<hr>
<h4 id="_文法规则" class="discrete">文法规则</h4>
<div class="literalblock">
<div class="content">
<pre>S → A0 | B1  <i class="conum" data-value="1"></i><b>(1)</b>
A → S1 | 1   <i class="conum" data-value="2"></i><b>(2)</b>
B → S0 | 0   <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<h4 id="_关键推导步骤" class="discrete">关键推导步骤</h4>
<div class="paragraph">
<p><strong>基础推导</strong></p>
</div>
<div class="literalblock">
<div class="content">
<pre>`S → A0 → 10` （0和1各1个）
`S → B1 → 01` （0和1各1个）</pre>
</div>
</div>
<div class="paragraph">
<p><strong>递归展开示例</strong></p>
</div>
<div class="literalblock">
<div class="content">
<pre>S → A0 → S10 → (A0)10 → 1010  <i class="conum" data-value="1"></i><b>(1)</b>
S → B1 → S01 → (B1)01 → 0101  <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
每次递归调用都会追加平衡的字符对（如 <code>0</code> 和 <code>1</code>）
</td>
</tr>
</table>
</div>
<h4 id="_数目关系分析" class="discrete">数目关系分析</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">符号</th>
<th class="tableblock halign-left valign-top">数量差特征</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0的数量 = 1的数量</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">因每次展开都会补充对称字符（如A生成`1<code>时必跟</code>0`）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0比1少1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由规则 &lt;2&gt; 的递归特性决定（<code>A→S1</code> 会传递差额）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0比1多1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由规则 &lt;3&gt; 的递归特性决定（<code>B→S0</code> 会传递差额）</p></td>
</tr>
</tbody>
</table>
<h4 id="_选项验证" class="discrete">选项验证</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">选项</th>
<th class="tableblock halign-left valign-top">结果</th>
<th class="tableblock halign-left valign-top">分析</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A. 全0字符串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">错误 ×</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无法生成（所有推导必须同时包含0和1）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">B. 全1字符串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">错误 ×</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">同上（必须混合0和1）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C. 某些0和1相等的字符串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">正确 ✓</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有合法推导结果均满足 <code>n0 = n1</code>（如10, 01, 1010等）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">D. 所有数目不同的字符串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">错误 ×</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与文法特性矛盾（无法生成`n0 ≠ n1`的字符串）</p></td>
</tr>
</tbody>
</table>
<h4 id="_结论" class="discrete">结论</h4>
<div class="paragraph">
<p>正确答案为选项 <strong>C</strong></p>
</div>
<div class="paragraph">
<p>该文法生成的语言是：
<code>L(G) = { w | w ∈ {0,1}* 且 w中0与1的数量相等 }</code></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_存储系统与寻址结构">5 存储系统与寻址结构</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_5_1_存储单元地址宽度">5.1 存储单元地址宽度</h3>
<div class="paragraph">
<p>设有一个 <code>64K×32</code> 位的存储器（每个存储单元为 <code>32</code> 位），其存储单元的地址宽度为（ B ）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 15
B 16
C 30
D 32</pre>
</div>
</div>
<div class="paragraph">
<p>详细解释</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>存储单元数量计算</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>"64K" 中的 "K" 表示 <strong>1024</strong>（即 \(2^{10}\)），所以：
\(64K = 64 \times 1024\)</p>
</li>
<li>
<p>而 \(64 = 2^6\)，\(1024 = 2^{10}\)，因此：
\(64 \times 1024 = 2^6 \times 2^{10} = 2^{16}\)</p>
</li>
<li>
<p>最终得到存储单元总数：
\(64K = 65{,}536 = 2^{16}\)</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>地址宽度计算</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>要寻址 \(2^{16}\) 个存储单元，需要的地址位数为：
\(\log_2(2^{16}) = 16 \text{ 位}\)</p>
</li>
<li>
<p>因此，<strong>地址宽度为 16 位</strong>。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>结论：通过指数运算可直接推导出，该存储器的 <strong>地址宽度是 16 位</strong>，正确答案为 <strong>B</strong>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_2_寻址范围计算">5.2 寻址范围计算</h3>
<div class="paragraph">
<p>若某计算机字长为32位，内存容量为2GB，按字编址，则可寻址范围为（C）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 1024M
B 1GB
C 512M
D 2GB</pre>
</div>
</div>
<h4 id="_理解基本概念" class="discrete">理解基本概念</h4>
<div class="paragraph">
<p>首先，我们需要明确几个关键概念：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>字长（Word Size）</strong>：指计算机一次能处理的二进制位数。这里字长为32位，即4字节（因为1字节=8位，32位=4字节）。</p>
</li>
<li>
<p><strong>内存容量</strong>：指计算机内存的总大小。这里是2GB（GigaBytes）。需要明确的是，通常“B”代表字节（Byte），所以2GB = 2 × 1024 × 1024 × 1024 字节。</p>
</li>
<li>
<p><strong>编址方式</strong>：</p>
<div class="ulist">
<ul>
<li>
<p><strong>按字节编址</strong>：每个地址对应一个字节。</p>
</li>
<li>
<p><strong>按字编址</strong>：每个地址对应一个字（这里一个字是32位，即4字节）。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>题目中明确指出是“按字编址”，因此每个地址对应的是一个字（4字节）。</p>
</div>
<h4 id="_计算可寻址范围" class="discrete">计算可寻址范围</h4>
<div class="paragraph">
<p>可寻址范围指的是可以寻址的地址数量。我们需要计算在按字编址的情况下，有多少个唯一的地址可以访问。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>内存总容量</strong>：2GB = 2 × 2^30 字节 = 2^31 字节。</p>
</li>
<li>
<p><strong>按字编址</strong>：每个字 = 4字节 = 2^2 字节。</p>
<div class="literalblock">
<div class="content">
<pre>因此，可寻址的字数量 = 总字节数 / 每个字的字节数 = 2^31 / 2^2 = 2^(31-2) = 2^29。</pre>
</div>
</div>
</li>
<li>
<p>2^29 是多少？</p>
<div class="ulist">
<ul>
<li>
<p>2^10 = 1K</p>
</li>
<li>
<p>2^20 = 1M</p>
</li>
<li>
<p>2^30 = 1G</p>
</li>
<li>
<p>所以 2^29 = 2^(30-1) = 1G / 2 = 512M。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>因此，可寻址范围是512M个地址。</p>
</div>
<h4 id="_验证单位" class="discrete">验证单位</h4>
<div class="paragraph">
<p>题目问的是“可寻址范围”，通常指的是地址的数量。地址的数量是无单位的（即多少个地址），但选项中给出的单位是“M”、“GB”等。这里需要明确：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果“可寻址范围”指的是地址的数量，那么512M表示512 × 2^20个地址。</p>
</li>
<li>
<p>每个地址对应一个字（4字节），因此总内存 = 地址数量 × 字大小 = 512M × 4字节 = 2048MB = 2GB，这与题目给出的内存容量一致。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，选项C的“512M”是正确的。</p>
</div>
<h4 id="_排除其他选项_2" class="discrete">排除其他选项</h4>
<div class="paragraph">
<p>让我们看看其他选项为什么不对：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>A. 1024M</strong>：</p>
</li>
<li>
<p>1024M = 1G 地址。</p>
</li>
<li>
<p>按字编址，总内存 = 1G × 4字节 = 4GB，与题目2GB不符。</p>
</li>
<li>
<p><strong>B. 1GB</strong>：</p>
</li>
<li>
<p>类似于A，1GB地址 = 1G地址。</p>
</li>
<li>
<p>总内存 = 1G × 4字节 = 4GB，不符。</p>
</li>
<li>
<p><strong>D. 2GB</strong>：</p>
</li>
<li>
<p>2GB地址。</p>
</li>
<li>
<p>总内存 = 2G × 4字节 = 8GB，不符。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>只有C（512M）满足：</p>
</div>
<div class="paragraph">
<p>512M地址 × 4字节/地址 = 2GB 内存。</p>
</div>
<h4 id="_可能的混淆点" class="discrete">可能的混淆点</h4>
<div class="paragraph">
<p>有时候，人们可能会混淆“按字编址”和“按字节编址”：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果是*按字节编址*：</p>
</li>
<li>
<p>可寻址范围 = 2GB / 1字节 = 2G 地址。</p>
</li>
<li>
<p>但题目是按字编址，所以需要除以字的大小（4字节）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，不能直接认为内存容量是2GB，可寻址范围就是2G。</p>
</div>
<h4 id="_单位的选择" class="discrete">单位的选择</h4>
<div class="paragraph">
<p>为什么选项用“M”而不是“MB”？</p>
</div>
<div class="ulist">
<ul>
<li>
<p>这里的“M”指的是“百万”或“2^20”个地址，不是“MB”（兆字节）。</p>
</li>
<li>
<p>因为地址数量是无单位的，所以用“M”表示“百万”个地址是合理的。</p>
</li>
<li>
<p>如果写成“MB”可能会误解为内存大小。</p>
</li>
</ul>
</div>
<h4 id="_总结_2" class="discrete">总结</h4>
<div class="ulist">
<ul>
<li>
<p>内存总容量：2GB = 2^31 字节。</p>
</li>
<li>
<p>按字编址，字长：32位 = 4字节。</p>
</li>
<li>
<p>可寻址的字数量 = 2^31 / 4 = 2^29 = 512M。</p>
</li>
<li>
<p>因此，正确答案是 <strong>C 512M</strong>。</p>
</li>
</ul>
</div>
<h4 id="_最终答案" class="discrete">最终答案</h4>
<div class="paragraph">
<p><strong>C 512M</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_5_3_寻址单元数计算">5.3 寻址单元数计算</h3>
<div class="paragraph">
<p>设机器字长为 32 位，一个容量为 16MB 的存储器，CPU 按照半字寻址，其可寻址的单元数是（ ）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 2^24
B 2^23 正确
C 2^22
D 2^21</pre>
</div>
</div>
<hr>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>‌明确关键概念‌</p>
<div class="ulist">
<ul>
<li>
<p>机器字长‌：32位，即 CPU 一次处理数据的位数为 32bit‌。</p>
</li>
<li>
<p>半字‌：字长的一半，32 位机器的半字为 16位（2字节）‌。</p>
</li>
<li>
<p>存储器容量‌：16MB = 16 × 2²⁰字节 = 2²⁴字节（因1MB = 2²⁰字节）‌。</p>
</li>
</ul>
</div>
</li>
<li>
<p>‌计算总位数‌</p>
<div class="ulist">
<ul>
<li>
<p>存储器容量需转换为位数以便后续计算：</p>
</li>
<li>
<p>16MB的位数‌ = 16 × 2²⁰字节 × 8位/字节 = 2²⁴ × 8位 = 2²⁷位‌。</p>
</li>
</ul>
</div>
</li>
<li>
<p>‌按半字寻址的单元数‌</p>
<div class="ulist">
<ul>
<li>
<p>每个半字大小‌：16位（2字节）‌。</p>
</li>
<li>
<p>总单元数‌ = 存储器总字节数 ÷ 每单元字节数 = 2²⁴字节 ÷ 2字节/单元 = 2²³单元‌。</p>
</li>
<li>
<p>（或等价计算：总位数 ÷ 半字位数 = 2²⁷位 ÷ 16位/单元 = 2²³单元）</p>
</li>
</ul>
</div>
</li>
<li>
<p>‌验证与选项对比‌</p>
<div class="ulist">
<ul>
<li>
<p>选项B（2²³）‌与计算结果一致‌。</p>
</li>
<li>
<p>其他选项错误原因‌：</p>
<div class="literalblock">
<div class="content">
<pre>A（2²⁴）：误用字节寻址（每单元1字节）‌。
C（2²²）和D（2²¹）：无对应计算逻辑支持‌。</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>通用公式：</p>
<div class="ulist">
<ul>
<li>
<p>可寻址单元数 = 存储器容量（字节） ÷ 每单元字节数‌</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>本题中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每单元字节数 = 半字大小 = 2字节 → 2²⁴ ÷ 2 = 2²³‌。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过以上步骤可清晰得出答案为‌B. 2²³‌。</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_4_存储体系位示图_第几个字多少字">5.4 存储体系位示图 (第几个字)(多少字)</h3>
<div class="paragraph">
<p>某文件管理系统采用位示图(bitmap)记录磁盘的使用情况。
如果系统的字长为 32 位（指计算机一次可以处理的数据位数为32位），
磁盘物理块的大小为 4MB，物理块依次编号为：0、1、2、位示图字依次编号为：0、1、2，
那么 16385 号物理块的使用情况在位示图中的第（ ）个字中描述;
如果磁盘的容量为 1000GB，那么位示图需要（ ）个字来表示。</p>
</div>
<hr>
<div class="paragraph">
<p>关于 16385 号物理块在位示图中的位置计算，正确的答案确实是‌<strong>512</strong>‌（从0开始编号），而不是511。以下是详细解释：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>16385 号物理块的位置计算</p>
<div class="ulist">
<ul>
<li>
<p>物理块编号从‌<strong>0</strong>‌开始，因此16385号物理块实际上是第‌<strong>16386</strong>‌个物理块（因为编号 0 是第 1 块）‌。</p>
</li>
<li>
<p>每个字长为 32 位，可表示 32 个物理块的状态。</p>
</li>
<li>
<p>计算：</p>
<div class="ulist">
<ul>
<li>
<p>字数 = 16386​ / 32 = 512.0625</p>
</li>
<li>
<p>取整数部分，得到‌<strong>512</strong>‌（从0开始编号的字序号）‌。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>1000GB 磁盘的位示图字数计算</p>
<div class="ulist">
<ul>
<li>
<p>磁盘容量 = 1000GB = 1000 * 1024MB = 1,024,000MB。</p>
</li>
<li>
<p>每个物理块大小 = 4MB，因此物理块总数 = 1,024,000 / 4 ​= 256,000 个。</p>
</li>
<li>
<p>每个字表示 32 个物理块，所需字数 = 32 * 256,000 = 8,000个字‌。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>最终答案：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>16385号物理块在位示图中的第‌ 512 个字中描述；</p>
</li>
<li>
<p>1000GB磁盘的位示图需要‌ 8,000 个字来表示‌。</p>
</li>
</ul>
</div>
<hr>
<div class="paragraph">
<p><strong>继续解释：</strong></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>每个字长为 32 位（即一个字里有 32 个 bit），<strong>每个 bit 表示一个物理块的状态</strong>，而每个物理块大小为 <strong>4MB</strong>。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>换句话说：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个 bit → 表示一个 4MB 的物理块是否已被使用（0 表示空闲，1 表示占用）</p>
</li>
<li>
<p>一个 32 位的字（即 4 字节）→ 可以表示 <strong>32 个 4MB 的物理块</strong> 的使用情况；</p>
</li>
<li>
<p>所以：一个字可管理的总磁盘空间为：<code>32 × 4MB = 128MB</code>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>举个简单：</p>
</div>
<div class="paragraph">
<p>假设磁盘只有 128MB，块大小是 4MB，那么：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>总共有 <code>128 ÷ 4 = 32</code> 个块；</p>
</li>
<li>
<p>只需要一个 32 位的字（4 字节）就能用位示图来表示这 32 个块的使用情况。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>总结：“每个字长为 32 位，可表示 32 个物理块的状态”指的是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>每个位对应一个 4MB 的物理块</strong>。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_5_5_存储地址编号">5.5 存储地址编号</h3>
<div class="paragraph">
<p>设用 2K×4 位的存储器芯片组成 16K×8 位的存储器（地址单元为 0000H~3FFFH，每个芯片的地址空间连续)，则地址单元 <strong>0B1FH</strong> 所在芯片的最小地址编号为（ ）。</p>
</div>
<div class="paragraph">
<p><strong>A</strong> 0000H; <strong>B</strong> 0800H; <strong>C</strong> 2000H; <strong>D</strong> 2800H;</p>
</div>
<div class="paragraph">
<p>先分析问题：</p>
</div>
<hr>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>什么是「2K×4位的芯片」？</p>
<div class="ulist">
<ul>
<li>
<p>「2K」表示有 <strong>2 × 1024 = 2048</strong> 个地址单元</p>
</li>
<li>
<p>「4位」表示每个地址单元存的是 <strong>4位数据</strong>（半个字节）</p>
</li>
</ul>
</div>
</li>
<li>
<p>我们要做一个「16K × 8位」的存储器</p>
<div class="ulist">
<ul>
<li>
<p>「16K」表示有 <strong>16 × 1024 = 16384</strong> 个地址单元</p>
</li>
<li>
<p>每个地址要存 <strong>8 位数据</strong>（1 个字节）</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<hr>
<div class="paragraph">
<p><strong>怎么用小芯片拼出大存储器？</strong></p>
</div>
<div class="paragraph">
<p>现在有很多个「2K × 4位」的小芯片。要拼成「16K × 8位」的存储器：</p>
</div>
<div class="paragraph">
<p>第一步：数据宽度</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每个芯片只有 4 位，但我们需要 8 位 → 所以 <strong>要用两个芯片拼起来</strong></p>
</li>
<li>
<p>一个管高 4 位，一个管低 4 位，所以每个地址要用 <strong>2 个芯片</strong>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>第二步：地址数量</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每个芯片能放 2K 个地址，但我们需要 16K 个地址，所以需要
16K / 2K = <strong>8 组地址区间</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>每组地址，需要 2 个芯片（见上一步），所以总共是：<strong>8 组 × 2 个芯片 = 16 个芯片</strong>。</p>
</div>
<hr>
<div class="paragraph">
<p>看看题目问什么？</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>地址单元 0B1FH（十六进制）是在哪个芯片中？这个芯片的起始地址是多少？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>把 0B1F₁₆ 换成十进制 <code>0B1F₁₆ = 2847₁₀</code>，然后我们看一下每组芯片的地址范围是多大：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每组是 2K 地址 → 2048 个地址</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以地址分组是这样的：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">区块编号</th>
<th class="tableblock halign-left valign-top">地址范围（十六进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0000H ~ 07FFH &#8594; (0000 ~ 2047)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0800H ~ 0FFFH &#8594; (2048 ~ 4095)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000H ~ 17FFH &#8594; (4096 ~ 6143)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">……</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">……</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3800H ~ 3FFFH &#8594; (14335 ~ 16383)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>那 0B1F 属于哪组？</p>
</div>
<div class="paragraph">
<p>看看 0B1F 在不在 0800H ~ 0FFFH 里？<br>
是的！属于 <strong>第 1 组</strong>（编号为 1）</p>
</div>
<hr>
<div class="paragraph">
<p>所以这个芯片的最小地址是：<strong>0800H</strong>，最后答案是：<strong>B. 0800H</strong>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_6_存储时间计算">5.6 存储时间计算</h3>
<div class="paragraph">
<p>在磁盘上存储数据的排列方式会影响 IO 服务的总时间。假设每个磁道被划分成 10 个物理块，每个物理块存放1个逻辑记录。逻辑记录R1,R2&#8230;&#8203;.R10存放在同一个磁道上，记录的排列顺序如下表所示。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3337%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">物理块数</th>
<th class="tableblock halign-center valign-top">1</th>
<th class="tableblock halign-center valign-top">2</th>
<th class="tableblock halign-center valign-top">3</th>
<th class="tableblock halign-center valign-top">4</th>
<th class="tableblock halign-center valign-top">5</th>
<th class="tableblock halign-center valign-top">6</th>
<th class="tableblock halign-center valign-top">7</th>
<th class="tableblock halign-center valign-top">8</th>
<th class="tableblock halign-center valign-top">9</th>
<th class="tableblock halign-center valign-top">10</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">逻辑记录</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R6</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R8</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R9</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">R10</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>假定磁盘的旋转速度为 10ms/周，磁头当前处在 R1 的开始处。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>若系统顺序处理这些记录，使用单缓冲区，每个记录处理时间为 2ms,则处理这 10个 记录的最长时间为（D）;</p>
<div class="literalblock">
<div class="content">
<pre>A 30ms
B 60ms
C 94ms
D 102ms</pre>
</div>
</div>
</li>
<li>
<p>若对存储数据的排列顺序进行优化，处理10个记录的最少时间为（ ）。</p>
</li>
</ul>
</div>
<hr>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>磁头当前处于 R1 处，读取出 R1 的时间为 10ms/10=1ms，然后的使用单缓冲区处理，花费 2ms。R1 处理完毕后磁头此时已处于 R4 处，若是顺序读和处理 R2 则需要再等待 8ms，R2 的读取与处理时间与 R1 相同，当 R2 处理完毕再读取 R3 仍然需要再等待 8ms&#8230;&#8203;&#8230;&#8203;依次类推，10 个记录读完处理完毕的时间一共是 102ms。</p>
<div class="ulist">
<ul>
<li>
<p>计算：<strong>总时间 = 3ms（R1）+ 9(R2到R10还剩9个没处理) × 11ms(每个3+8)= 102ms</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>若对存储数据的排列顺序进行优化，即在原先存放 R4 处，存放 R2，则十个记录的处理时间会缩短至 30ms。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>关键总结</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>读取时间</strong>：是物理块从磁头下方通过的时间（10ms/周 ÷ 10块 = 1ms/块）。</p>
</li>
<li>
<p><strong>处理时间</strong>：是程序处理数据的时间（题目给定2ms），期间磁盘仍在旋转。</p>
</li>
<li>
<p><strong>优化核心</strong>：通过重排数据，让“处理时间”对应的磁盘旋转刚好定位到下一个记录，避免等待。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这样设计后，磁盘的物理特性（旋转延迟）被完全利用，实现了最短时间（30ms）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_7_存储器分类方式">5.7 存储器分类方式</h3>
<div class="paragraph">
<p>（C）不属于按寻址方式划分的一类存储器。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 随机存储器
B 顺序存储器
C 相联存储器
D 直接存储器</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>正确答案是：<strong>C 相联存储器</strong></p>
</div>
<div class="paragraph">
<p>题目问的是“<strong>不属于按寻址方式划分的一类存储器</strong>”，而存储器的寻址方式通常分为以下几类：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>随机存储器（A）</strong>：通过地址直接访问任意存储单元，如RAM。</p>
</li>
<li>
<p><strong>顺序存储器（B）</strong>：必须按顺序访问存储单元，如磁带。</p>
</li>
<li>
<p><strong>直接存储器（D）</strong>：介于随机和顺序之间，通过部分地址直接定位到某个区域，如磁盘。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>相联存储器（C）</strong>是通过<strong>内容</strong>而非地址访问的存储器（如CAM，Content-Addressable Memory），因此它不属于按寻址方式划分的类别，而是按访问方式划分的。</p>
</div>
<div class="paragraph">
<p>关键点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>寻址方式关注的是<strong>如何定位存储单元</strong>（地址、顺序、直接等）。</p>
</li>
<li>
<p>相联存储器是通过<strong>内容匹配</strong>访问，与寻址方式无关。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>其他选项（A、B、D）均属于按寻址方式划分的存储器类型。</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_8_存储分页系统">5.8 存储分页系统</h3>
<div class="sect3">
<h4 id="_5_8_1_求物理地址">5.8.1 求物理地址</h4>
<div class="paragraph">
<p>某计算机系统页面大小为 4K，进程的页面变换表如下所示。若进程的逻辑地址为 3C28H。该地址经过变换后，其物理地址应为（D）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>页号      物理块号
0           1
1           3
2           4
3           6</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>A 2048H
B 4096H
C 4C28H
D 6C28H</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>首先，我们需要明确几个关键概念：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>页面大小（Page Size）：这里是 4K，即 4096 字节（因为 1K = 1024 字节）。</p>
</li>
<li>
<p>逻辑地址（Logical Address）：由 CPU 生成的地址，分为页号和页内偏移量。</p>
</li>
<li>
<p>页表（Page Table）：将逻辑页号映射到物理块号。</p>
</li>
<li>
<p>物理地址（Physical Address）：由物理块号和页内偏移量组合而成。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们来一步步分析这道题。</p>
</div>
<hr>
<div class="paragraph">
<p>已知信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>页面大小为 4K</strong>，即 <strong>每页大小 = 4KB = 2¹² = 4096 字节</strong>。</p>
</li>
<li>
<p>所以逻辑地址的格式为：</p>
<div class="literalblock">
<div class="content">
<pre>逻辑地址 = 页号 + 页内偏移量
        = 高 4 位（页号） + 低 12 位（页内偏移）</pre>
</div>
</div>
</li>
<li>
<p>页表如下：</p>
<div class="literalblock">
<div class="content">
<pre>页号      物理块号
0           1
1           3
2           4
3           6</pre>
</div>
</div>
</li>
<li>
<p>给定逻辑地址为：<code>3C28H</code></p>
</li>
</ul>
</div>
<hr>
<div class="paragraph">
<p>第一步：将逻辑地址转换为二进制</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><span></span>转为二进制：
3C28H = 0011 1100 0010 1000（二进制）

前 4 位：0011 → 页号 = 3
后 12 位：1100 0010 1000 → 页内偏移 = 0xC28</code></pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>第二步：查表得知页号为 3，对应物理块号是 6</p>
</div>
<div class="paragraph">
<p>每个物理块的大小也是 4K（4096 字节），所以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><span></span>物理地址 = 物理块号 × 页大小 + 页内偏移
        = 6 × 4096 + 0xC28</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>利用位运算的特性：</p>
<div class="ulist">
<ul>
<li>
<p>4096 = 2¹²，所以 6 × 4096 = 6 &lt;&lt; 12（左移 12 位）。</p>
</li>
<li>
<p>也就是：把 6 变成一个以 12 个零结尾的二进制数。</p>
<div class="literalblock">
<div class="content">
<pre>6 × 4096 = 6 &lt;&lt; 12 = 0x6000</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>把偏移量直接加进去：</p>
<div class="ulist">
<ul>
<li>
<p>偏移量是 0xC28，直接加到 0x6000：</p>
<div class="literalblock">
<div class="content">
<pre>0x6000 + 0x0C28 = 0x6C28</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>✅ 答案：<strong>D. 6C28H</strong></p>
</div>
</div>
<div class="sect3">
<h4 id="_5_8_2_求淘汰页">5.8.2 求淘汰页</h4>
<div class="paragraph">
<p>某系统采用请求页式存储管理方案，假设某进程有 6 个页面，系统给该进程分配了 4 个存储块，其页面变换表如下表所示，表中的状态位等于 1/0 分别表示页面在内存/不在内存。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">页号</th>
<th class="tableblock halign-left valign-top">页帧号</th>
<th class="tableblock halign-left valign-top">状态位</th>
<th class="tableblock halign-left valign-top">访问位</th>
<th class="tableblock halign-left valign-top">修改位</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">—</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">—</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当该进程访问的页面 2 不在内存时，应该淘汰表中页号为（D）的页面。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 0
B 3
C 4
D 5</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>这个题考察的是操作系统中的请求分页系统页面置换算法和地址变换。我们逐步来分析：</p>
</div>
<div class="paragraph">
<p>题意解析：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>系统采用请求页式存储管理：说明不是所有页都在内存里，需要访问时再调入。</p>
</li>
<li>
<p>进程有6个页面（页号0~5），系统给它分配了4个页框（也就是最多4页能在内存中）。</p>
</li>
<li>
<p>给出了页表，每行分别是：</p>
<div class="ulist">
<ul>
<li>
<p>页号（Page Number）</p>
</li>
<li>
<p>页帧号（Frame Number）</p>
</li>
<li>
<p>状态位（1表示在内存，0表示不在内存）</p>
</li>
<li>
<p>访问位（是否访问过）</p>
</li>
<li>
<p>修改位（是否修改过</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>找出页面2不在内存，要换入内存，需要淘汰哪个页？</p>
</div>
<div class="paragraph">
<p>页面 2 不在内存（状态位为0），所以要换入。内存页框已满（页号0、3、4、5状态位都为1），需要淘汰一个页。</p>
</div>
<div class="paragraph">
<p>选择淘汰页的算法（常用是 NRU 或 Clock）</p>
</div>
<div class="paragraph">
<p>从表中可看到访问位与修改位，用NRU算法（Not Recently Used）。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">NRU 通常按如下优先级淘汰（越上优先级越高，优先被淘汰）：</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类别</th>
<th class="tableblock halign-left valign-top">访问位</th>
<th class="tableblock halign-left valign-top">修改位</th>
<th class="tableblock halign-left valign-top">优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最高（立即淘汰）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">次高</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">次低</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最低</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>对比内存中页面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>页号0：访问=1，修改=1 → 类别3</p>
</li>
<li>
<p>页号3：访问=1，修改=0 → 类别2</p>
</li>
<li>
<p>页号4：访问=1，修改=1 → 类别3</p>
</li>
<li>
<p>页号5：访问=0，修改=0 → 类别0 ✅</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>页号 5 满足类别 0（未访问未修改）→ 最佳淘汰对象</p>
</div>
</div>
<div class="sect3">
<h4 id="_5_8_3_求页帧号接上题淘汰页">5.8.3 求页帧号（接上题淘汰页）</h4>
<div class="paragraph">
<p>接上题，假定页面大小为 4K，逻辑地址为十六进制 3C18H，该地址经过变换后的页帧号为（A）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 2
B 5
C 8
D 12</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>逻辑地址 3C18H → 页号、页内偏移，找出页帧号</p>
</div>
<div class="ulist">
<ul>
<li>
<p>采用页式管理，每页大小为 4K = 2¹² 字节（即页偏移是12位）</p>
</li>
<li>
<p>所以逻辑地址的前几位是页号，低 12 位是页内偏移</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>将 3C18H 转成二进制：</p>
</div>
<div class="paragraph">
<p>3C18H = 0011 1100 0001 1000（16位）</p>
</div>
<div class="ulist">
<ul>
<li>
<p>页号（高4位）：0011 = 3</p>
</li>
<li>
<p>页内偏移（低12位）：1100 0001 1000</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>→ 所以是页号 3</p>
</div>
<div class="paragraph">
<p>查页表中页号 3 的页帧号是 2 ✅</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_5_9_存储磁盘块计算">5.9 存储磁盘块计算</h3>
<div class="paragraph">
<p>某文件系统采用链式存储管理方案，磁盘块的大小为 1024 字节。
文件 Myfile.doc 由 5 个逻辑记录组成，每个逻辑记录的大小与磁盘块的大小相等，并依次存放在 121、75、86、65 和 114 号磁盘块上。
若需要存取文件的第 5120 字节处的信息，应该访问（D）号磁盘块。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 75
B 85
C 65
D 114</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>这个题比较简单，从前往后数，1024B * 4 = 4096B，小于 5120B，所以只能是在最后一个磁盘块上了。
所以答案是 D 114</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_10_存储磁盘读取文件时间计算">5.10 存储磁盘读取文件时间计算</h3>
<div class="paragraph">
<p>某磁盘磁头从一个磁道移至另一个磁道需要 10ms。文件在磁盘上非连续存放，逻辑上相邻数据块的平均移动距离为 10 个磁道，每块的旋转延迟时间及传输时间分别为 100ms 和 2ms，则读取一个 100 块的文件需要（D）ms 时间。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 10200
B 11000
C 11200
D 20200</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>本题考查操作系统中设备管理的基本知识。
访问一个数据块的时间应为寻道时间加旋转延迟时间及传输时间。
根据题意，每块的旋转延迟时间及传输时间共需 102ms，磁头从一个磁道移至另一个磁道需要 10ms，但逻辑上相邻数据块的平均距离为10个磁道，即读完一个数据块到下一个数据块寻道时间需要 100ms。
通过上述分析，本题访问一个数据块的时间应为 202ms，而读取一个 100块的文件共需要 20200ms。</p>
</div>
<div class="paragraph">
<p>如果以后再遇到类似题，可以用这个公式快速估算：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>总读取时间 = 块数 *（寻道时间 + 旋转延迟 + 传输时间）
         = 100 * (10*10+100+2)
         = 20200ms</pre>
</div>
</div>
<div class="paragraph">
<p>前提是：数据块非连续存储，所以每次都要重复这三步。</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_11_磁盘块与缓冲区读取时间计算">5.11 磁盘块与缓冲区读取时间计算</h3>
<div class="paragraph">
<p>假设磁盘块与缓冲区大小相同，每个盘块读入缓冲区的时间为 16us, 由缓冲区送至用户区的时间是 5us, 在用户区内系统对每块数据的处理时间为 1us。</p>
</div>
<div class="paragraph">
<p>若用户需要将大小为 10 个磁盘 块的 Doc1 文件逐块从磁盘读入缓冲区，并送至用户区进行处理，那么采用单缓冲区需要花费的时间为（D 211）us；</p>
</div>
<div class="paragraph">
<p>采用双缓冲区需要花费的时间为，（C 166）us。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><span></span>A 160
B 161
C 166
D 211


A 160
B 161
C 166
D 211</code></pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>由于缓冲区的访问是互斥的，所以对单一缓冲区，从磁盘写入和读出到用户区的操作必须串行执行，也就是要保证互斥操作。</p>
</div>
<div class="paragraph">
<p>而 CPU 对数据的分析与从用户区读数据也是需要互斥操作，但是 CPU 分析与从磁盘写入缓冲区的操作可以并行。</p>
</div>
<div class="paragraph">
<p>从本题看，由于分析所用的时间小于从磁盘写入缓冲区的时间，因此，CPU 会空闲。</p>
</div>
<div class="paragraph">
<p>单缓冲区的总时间=(磁盘写入缓冲区时间 + 缓冲区读出时间) × 10 + CPU 处理最后一块数据的时间 = (16+5)×10+1 = 211 μs。</p>
</div>
<hr>
<div class="paragraph">
<p>当采用双缓冲区时，每块缓冲区的操作也必须满足互斥操作，但是，对两块缓冲区的操作却可以并行，所以，当第一个缓冲区写满以后，磁盘紧接着写另一个缓冲区，同时，前一个已经满了的缓冲区被读出到用户区，并立即进行CPU的数据分析。</p>
</div>
<div class="paragraph">
<p>读出操作和数据分析必须互斥进行，故，从时间上看，当数据被读出并分析后，恰好另一个缓冲区也写满了，可以立即进行读出数据到用户区并进行数据分析。</p>
</div>
<div class="paragraph">
<p>两块缓冲区交替进行读写，直到数据分析完毕，因此，</p>
</div>
<div class="paragraph">
<p>总时间=(磁盘写入缓冲区时间)×10 + 读出最后一块数据时间 + CPU分析最后一块数据时间 = (16)×10+5+1=166 us。</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_12_存储图片需光盘张数">5.12 存储图片需光盘张数</h3>
<div class="paragraph">
<p>10000 张分辨率为 1024X768 的真彩（32位）图片刻录到DVD光盘上，假设每张光盘可以存放 4GB 的信息，则需要（B）张光盘。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 7
B 8
C 70
D 71</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>图像数据大小与光盘数量计算（二进制单位），32位 指每个像素占用 32bit。</p>
</div>
<h4 id="_图像数据量计算方法" class="discrete">图像数据量计算方法</h4>
<div class="paragraph">
<p>每张图片的分辨率为 1024×768，色深为 32 位（即每像素 32 bit），共 10000 张图片。</p>
</div>
<div class="paragraph">
<p>总数据量（以 bit 为单位）如下：</p>
</div>
<div class="stemblock">
<div class="content">
\[图像数据量：10000 × 1024 × 768 × 32\text{ bit}\]
</div>
</div>
<h4 id="_光盘容量换算方式" class="discrete">光盘容量换算方式</h4>
<div class="paragraph">
<p>每张光盘容量为 4GB，其中：</p>
</div>
<div class="stemblock">
<div class="content">
\[1GB 为 2^{30} 字节（Byte），即 2^{30} × 8 bit\]
</div>
</div>
<div class="paragraph">
<p>所以每张光盘容量为：</p>
</div>
<div class="stemblock">
<div class="content">
\[4 × 2^{30} × 8 bit\]
</div>
</div>
<h4 id="_所需光盘张数计算步骤" class="discrete">所需光盘张数计算步骤</h4>
<div class="paragraph">
<p>将图像总数据量除以单张光盘容量，得到：</p>
</div>
<div class="stemblock">
<div class="content">
\[\frac{10000 × 1024 × 768 × 32}{4 × 2^{30} × 8} ≈ 7.3\]
</div>
</div>
<div class="paragraph">
<p>最终结果向上取整为：8 张光盘</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_13_地址范围转字节数">5.13 地址范围转字节数</h3>
<div class="paragraph">
<p>内存按字节编址，地址从 A0000H 到 CFFFFH 的内存，共存（D）字节，若用存储容量为 64k×8bit 的存储器芯片构成该内存空间，至少需要（ ）片。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 80KB
B 96KB
C 160KB
D 192KB</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>A 2
B 3
C 5
D 8</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>从 A0000H 到 CFFFFH 有多少字节？你可以这样估算：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>起始 A0000H ≈ 第 10 个 64KB（A=10）</p>
</li>
<li>
<p>结束 CFFFFH ≈ 第 13 个 64KB（C=12，因为地址从0开始数）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>→ 总共跨了 3 × 64KB = 30000H = 192KB</p>
</div>
<div class="paragraph">
<p>你要的总容量是 192KB，每片芯片容量是 64KB：</p>
</div>
<div class="paragraph">
<p>所以，192KB ÷ 64KB = 3（片芯片），这就是需要芯片的最少数量。</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_14_页式虚拟存储缺页中断分析">5.14 页式虚拟存储缺页中断分析</h3>
<div class="paragraph">
<p>假设一台按字节编址的 16 位计算机系统 (此信息在本题中未用到)，采用虚拟页式存储管理方案，页面大小为 2KB（2048 字节），系统中没有使用快表。某用户程序执行以下指令：</p>
</div>
<div class="paragraph">
<p><code>MOVE data1, data2</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MOVE</code> 是一个 4 字节指令。</p>
</li>
<li>
<p><code>data1</code> 和 <code>data2</code> 是两个 32 位操作数（各占 4 字节）。</p>
</li>
<li>
<p>地址分布如下：</p>
</li>
<li>
<p><code>MOVE</code> 指令从地址 <code>2047</code> 开始</p>
</li>
<li>
<p><code>data1</code> 从地址 <code>6143</code> 开始</p>
</li>
<li>
<p><code>data2</code> 从地址 <code>10239</code> 开始</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>程序页表信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>仅页号为 <code>0</code> 的页面在内存中（状态位为 1）</p>
</li>
<li>
<p>其他页均不在内存（状态位为 0）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>页面编号的计算方式</strong></p>
</div>
<div class="paragraph">
<p>由于页面大小为 2KB = 2048 字节 = 2^11，因此每个地址属于的页号可通过如下方式计算：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>页号 = 地址 ÷ 2048（在机器中等价于位操作：页号 = 地址 &gt;&gt; 11）</p>
</li>
<li>
<p>页内偏移 = 地址 % 2048 (本题未用到)</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. 地址与页号的划分示例如下：</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">地址范围</th>
<th class="tableblock halign-left valign-top">页号</th>
<th class="tableblock halign-left valign-top">原始状态</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 ~ 2047</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 (开始只有0页号在内存中)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2048 ~ 4095</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4096 ~ 6143</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6144 ~ 8191</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8192 ~ 10239</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10240 ~ 12287</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>缺页中断分析</strong></p>
</div>
<div class="paragraph">
<p>取指令：地址 2047~2050</p>
</div>
<div class="ulist">
<ul>
<li>
<p>地址 2047：页号 0（在内存）✅</p>
</li>
<li>
<p>地址 2048、2049、2050：页号 1（不在内存）❌</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>→ 访问页号 1 时触发 1 次缺页中断</p>
</div>
<div class="paragraph">
<p><strong>取指令缺页中断次数：1</strong></p>
</div>
<div class="paragraph">
<p>取 data1 操作数：地址 6143~6146</p>
</div>
<div class="ulist">
<ul>
<li>
<p>地址 6143：页号 2（不在内存）❌</p>
</li>
<li>
<p>地址 6144~6146：页号 3（不在内存）❌</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>→ 跨两个页：页号 2 和 3，各触发 1 次缺页中断</p>
</div>
<div class="paragraph">
<p><strong>取 data1 缺页中断次数：2</strong></p>
</div>
<div class="paragraph">
<p>取 data2 操作数：地址 10239~10242</p>
</div>
<div class="ulist">
<ul>
<li>
<p>地址 10239：页号 4（不在内存）❌</p>
</li>
<li>
<p>地址 10240~10242：页号 5（不在内存）❌</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>→ 跨两个页：页号 4 和 5，各触发 1 次缺页中断</p>
</div>
<div class="paragraph">
<p><strong>取 data2 缺页中断次数：2</strong></p>
</div>
<hr>
<div class="paragraph">
<p><strong>最终结果</strong></p>
</div>
<div class="paragraph">
<p>执行 <code>MOVE data1, data2</code> 指令将产生：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>总缺页中断次数：<strong>5</strong></p>
</li>
<li>
<p>其中：</p>
<div class="ulist">
<ul>
<li>
<p>取指令产生：<strong>1</strong> 次缺页中断</p>
</li>
<li>
<p>取 data1 操作数产生：<strong>2</strong> 次缺页中断</p>
</li>
<li>
<p>取 data2 操作数产生：<strong>2</strong> 次缺页中断</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_5_15_多级索引文件最大长度">5.15 多级索引文件最大长度</h3>
<div class="paragraph">
<p>某文件系统采用多级索引结构，若磁盘块的大小为 512 字节，每个块号需占 3 字节，
那么根索引采用一级索引时的文件最大长度为 （A） K 字节；
采用二级索引时的文件最大长度为 （C） K 字节。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 85    B 170   C 512   D 1024
A 512   B 1024  C 14450 D 28900</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p><strong>第一问解析：</strong></p>
</div>
<div class="paragraph">
<p>磁盘块的大小为 512B，每个块号需占 3B，因此一个磁盘物理块可存放
\(512 \div 3 \approx 170\) 个块号。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
由于不能存半个块号，所以向下取整为 170 个块号。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>根索引采用一级索引时的文件最大长度为：
\(170 \times 512 \div 1024 = 87040 \div 1024 = 85 \text{KB}\)</p>
</div>
<div class="paragraph">
<p><strong>第二问解析：</strong></p>
</div>
<div class="paragraph">
<p>一级索引结构：根索引块 ——&gt; 直接指向数据块</p>
</div>
<div class="paragraph">
<p>二级索引结构：根索引块 ——&gt; 指向“一级索引块”（中间层） ——&gt; 每个一级索引块再指向数据块</p>
</div>
<div class="paragraph">
<p>总共能访问的数据块数量是：\(170 \times 170 = 28,900 \text{ 个数据块}\)</p>
</div>
<div class="paragraph">
<p>每个数据块是 512B，所以文件最大大小为：
\(28,900 \times 512 = 14796800 \text{ 字节}
= \frac{14796800}{1024} = 14450 \text{ KB}
\)</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_16_数字音频存储大小">5.16 数字音频存储大小</h3>
<div class="paragraph">
<p>5分钟、双声道、22.05kHz采样、16位量化的声音，经5:1压缩后，其数字音频的数据量约为（B）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 5.168MB
B 5.047MB
C 26.460MB
D 26.082MB</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>一、原始音频的数据量计算</p>
</div>
<div class="paragraph">
<p>给出的音频参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>时长：5 分钟 = 5 × 60 = 300 秒</p>
</li>
<li>
<p>声道数：2（双声道）</p>
</li>
<li>
<p>采样率：22.05 kHz = 22050 次/秒</p>
</li>
<li>
<p>量化位数：16 位</p>
</li>
<li>
<p>压缩比：5:1</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>公式：原始数据量（位）= 时间（秒）× 采样率 × 量化位数 × 声道数</p>
</div>
<div class="paragraph">
<p>代入：300 × 22050 × 16 × 2 = 211680000 位</p>
</div>
<div class="paragraph">
<p>转换为字节（8 位 = 1 字节）：= 211680000 ÷ 8 = 26460000 字节</p>
</div>
<div class="paragraph">
<p>二、压缩后数据量（压缩比 5:1）</p>
</div>
<div class="paragraph">
<p>压缩后 = 26460000 ÷ 5 = 5292000 字节</p>
</div>
<div class="paragraph">
<p>三、换算为 MB</p>
</div>
<div class="paragraph">
<p>通常使用 1 MB = 1024 × 1024 = 1,048,576 字节：</p>
</div>
<div class="paragraph">
<p>压缩后大小（MB） = 5292000 ÷ 1048576 ≈ 5.0468 MB ≈ 5.047 MB</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_指令流水线">6 指令流水线</h2>
<div class="sectionbody">
<div class="paragraph">
<p>某指令流水线由 4 段组成，各段所需要的时间如下图所示。连续输入 8 条指令时的吞吐率(单位时间内流水线所完成的任务数或输出的结果数)为()</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-2025-05-10-120508.svg" alt="graphviz 2025 05 10 120508" width="539" height="58">
</div>
</div>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p>8/56Δt</p>
</li>
<li>
<p>8/32Δt</p>
</li>
<li>
<p>8/28Δt</p>
</li>
<li>
<p>8/24Δt</p>
</li>
</ol>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>根据题目描述，某指令流水线由4段组成，各段所需时间分别为Δt、2Δt、3Δt、Δt。连续输入8条指令时的吞吐率计算如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>流水线周期‌：由最长段决定，即3Δt。</p>
</li>
<li>
<p>总执行时间‌：</p>
<div class="ulist">
<ul>
<li>
<p>第一条指令完成时间 = 各段时间和 = Δt + 2Δt + 3Δt + Δt = 7Δt。</p>
</li>
<li>
<p>后续7条指令每间隔一个周期（3Δt）完成，因此<strong>总时间 = 7Δt + 7×3Δt = 28Δt</strong>。</p>
</li>
</ul>
</div>
</li>
<li>
<p>吞吐率‌：完成任务数（8条）除以总时间（28Δt），即 ‌8/28Δt‌。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>因此，正确答案为 ‌C‌。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_6_1_指令之扩展操作码">6.1 指令之扩展操作码</h3>
<div class="paragraph">
<p>某计算机指令字长为 16 位，指令有双操作数、单操作数和无操作数 3 种格式，每个操作数字段均用 6 位二进制表示，该指令系统共 有 m 条（m&lt;16）双操作数指令，并存在无操作数指令。若采用扩展操作码技术，那么最多还可设计出（B）条单操作数指令。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 2^6
B（2^4-m）×2^6-1
C（2^4-m）×2^6
D（2^4-m）×（2^6-1）</pre>
</div>
</div>
<hr>
<h4 id="_指令编码与单操作数指令数计算总结" class="discrete">指令编码与单操作数指令数计算总结</h4>
<div class="paragraph">
<p>本题考查扩展操作码技术下，指令编码空间的划分与计算方法。</p>
</div>
<h4 id="_基本条件" class="discrete">基本条件</h4>
<div class="ulist">
<ul>
<li>
<p>指令字长：16 位</p>
</li>
<li>
<p>有三种指令格式：双操作数、单操作数、无操作数</p>
</li>
<li>
<p>每个操作数字段为 6 位</p>
</li>
</ul>
</div>
<h4 id="_双操作数指令格式" class="discrete">双操作数指令格式</h4>
<div class="ulist">
<ul>
<li>
<p>含两个操作数字段 → 6 位 × 2 = 12 位</p>
</li>
<li>
<p>剩余位数：16 - 12 = 4 位 → 用于操作码</p>
</li>
<li>
<p>4 位操作码最多可表示：\(2^4=16\) 条不同的双操作数指令</p>
</li>
</ul>
</div>
<h4 id="_已知条件" class="discrete">已知条件</h4>
<div class="ulist">
<ul>
<li>
<p>实际双操作数指令数量为 \(m\) 条，且 \(m &lt; 16\)</p>
</li>
<li>
<p>剩余可用操作码数为：\(2^4 - m = 16 - m\)</p>
</li>
</ul>
</div>
<h4 id="_扩展操作码原理" class="discrete">扩展操作码原理</h4>
<div class="ulist">
<ul>
<li>
<p>采用剩余的操作码作为“扩展操作码”入口</p>
</li>
<li>
<p>每一个扩展操作码可对应一种扩展格式指令，例如单操作数指令</p>
</li>
</ul>
</div>
<h4 id="_单操作数指令格式" class="discrete">单操作数指令格式</h4>
<div class="ulist">
<ul>
<li>
<p>一个操作数字段：6 位</p>
</li>
<li>
<p>剩余位数：16 - 6 = 10 位</p>
</li>
<li>
<p>常见划分方式： <strong>题的选择项中已经给出了 \(2^6\)</strong></p>
<div class="ulist">
<ul>
<li>
<p>前 4 位：扩展操作码</p>
</li>
<li>
<p>后 6 位：表示具体指令编号</p>
</li>
</ul>
</div>
</li>
<li>
<p>每个扩展操作码可扩展出：\(2^6 = 64\) 条单操作数指令</p>
</li>
</ul>
</div>
<h4 id="_单操作数指令总数计算" class="discrete">单操作数指令总数计算</h4>
<div class="ulist">
<ul>
<li>
<p>可用扩展操作码数：\(2^4 - m = 16 - m\)</p>
</li>
<li>
<p>每个扩展码可扩展出 \(2^6 = 64\) 条单操作数指令</p>
</li>
<li>
<p>所以最多可设计：\((2^4 - m) \times 2^6 = (16 - m) \times 64\)</p>
</li>
</ul>
</div>
<h4 id="_无操作数指令考虑" class="discrete">无操作数指令考虑</h4>
<div class="ulist">
<ul>
<li>
<p>题目说明存在“无操作数指令”</p>
</li>
<li>
<p>最少需保留 1 条指令编码给无操作数类</p>
</li>
<li>
<p><mark>最终最多可设计单操作数指令数为： \((2^4 - m) \times 2^6 - 1\)</mark></p>
</li>
</ul>
</div>
<h4 id="_答案选择" class="discrete">答案选择</h4>
<div class="paragraph">
<p>B 选项符合上述计算公式，因此答案为：<strong>B</strong></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_7_程序优化加速比">7 程序优化加速比</h2>
<div class="sectionbody">
<div class="paragraph">
<p>假定求浮点数平方根（FPSQR）的操作在某台机器上的一个基准测试程序中占总执行时间的20%，FP运算指令所用时间占总执行时间的50%。</p>
</div>
<div class="paragraph">
<p>采用两种优化FPSQR的方法，第一种方法是增加专门的FPSQR硬件，可以将FPSQR的操作速度提高为原来的10倍；</p>
</div>
<div class="paragraph">
<p>第二种方法是提高所有FP（浮点）运算指令的执行速度到原来的1.6倍，从而提高求浮点数平方根操作的速度。</p>
</div>
<div class="paragraph">
<p>可以通过计算这两种方法对基准测试程序的加速比来比较这两种方法的优劣。以下叙述正确的是（B）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 第一种方法的加速比是1.23，效果较好
B 第二种方法的加速比是1.23，效果较好
C 第一种方法的加速比是1.22，效果较好
D 第二种方法的加速比是1.22，效果较好</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>Amdahl 定律应用分析题</p>
</div>
<h4 id="_题目描述" class="discrete">题目描述</h4>
<div class="paragraph">
<p>假定求浮点数平方根（FPSQR）的操作在某台机器上的一个基准测试程序中占总执行时间的 20%，
而所有 FP（浮点）运算指令所用时间占总执行时间的 50%。</p>
</div>
<div class="paragraph">
<p>有两种优化 FPSQR 的方法：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>第一种方法是增加专门的 FPSQR 硬件，可将 FPSQR 操作速度提高为原来的 10 倍；</p>
</li>
<li>
<p>第二种方法是提高所有 FP 运算指令的执行速度到原来的 1.6 倍，从而也提高 FPSQR 操作速度。</p>
</li>
</ol>
</div>
<h4 id="_选项" class="discrete">选项</h4>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p>第一种方法的加速比是 1.23，效果较好<br></p>
</li>
<li>
<p>第二种方法的加速比是 1.23，效果较好<br></p>
</li>
<li>
<p>第一种方法的加速比是 1.22，效果较好<br></p>
</li>
<li>
<p>第二种方法的加速比是 1.22，效果较好</p>
</li>
</ol>
</div>
<h4 id="_考察知识点" class="discrete">考察知识点</h4>
<div class="paragraph">
<p>本题考察 <strong>Amdahl 定律</strong> 的应用，用于分析<strong>部分程序优化</strong>对<strong>整体性能</strong>的影响</p>
</div>
<div class="paragraph">
<p>Amdahl 定律公式： \(\text{Speedup} = \frac{1}{(1 - f) + \frac{f}{s}}\)</p>
</div>
<div class="paragraph">
<p>其中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\(f\)：可优化部分占总执行时间的比例</p>
</li>
<li>
<p>\(s\)：该部分的加速倍数（speedup factor）</p>
</li>
</ul>
</div>
<h4 id="_方法一优化_fpsqr占_20加速_10_倍" class="discrete">方法一：优化 FPSQR（占 20%，加速 10 倍）</h4>
<div class="ulist">
<ul>
<li>
<p>可优化部分：\(f = 0.2\)</p>
</li>
<li>
<p>非优化部分：\(1 - f = 0.8\)</p>
</li>
<li>
<p>加速比计算：</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="asciidoc"><span></span>stem:[
\text{Speedup}_1 = \frac{1}{0.8 + \frac{0.2}{10}} = \frac{1}{0.8 + 0.02} = \frac{1}{0.82} \approx 1.22
]</code></pre>
</div>
</div>
</li>
</ul>
</div>
<h4 id="_方法二优化所有_fp_指令占_50加速_1_6_倍" class="discrete">方法二：优化所有 FP 指令（占 50%，加速 1.6 倍）</h4>
<div class="ulist">
<ul>
<li>
<p>可优化部分：\(f = 0.5\)</p>
</li>
<li>
<p>非优化部分：\(1 - f = 0.5\)</p>
</li>
<li>
<p>加速比计算：</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="asciidoc"><span></span>stem:[
\text{Speedup}_2 = \frac{1}{0.5 + \frac{0.5}{1.6}} = \frac{1}{0.5 + 0.3125} = \frac{1}{0.8125} \approx 1.23
]</code></pre>
</div>
</div>
</li>
</ul>
</div>
<h4 id="_结论_2" class="discrete">结论</h4>
<div class="ulist">
<ul>
<li>
<p>方法一的加速比约为 \(1.22\)</p>
</li>
<li>
<p>方法二的加速比约为 \(1.23\)</p>
</li>
<li>
<p>所以 <strong>方法二略优</strong></p>
</li>
</ul>
</div>
<h4 id="_正确答案" class="discrete">正确答案</h4>
<div class="paragraph">
<p><strong>B. 第二种方法的加速比是 1.23，效果较好</strong></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_8_操作系统">8 操作系统</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_8_1_进程同步与互斥pv_操作">8.1 进程同步与互斥（PV 操作）</h3>
<div class="sect3">
<h4 id="_8_1_1_前趋图">8.1.1 前趋图</h4>
<div class="paragraph">
<p>前趋图（Precedence Graph）是一种用于表示任务或进程之间执行顺序关系的图形表示方法。它通常用于项目管理、操作系统的进程调度、编译原理中的指令调度等领域，以帮助确定任务或进程的执行顺序和依赖关系。</p>
</div>
<div class="paragraph">
<p>前趋图的特点：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>节点（Vertices）</strong>：图中的每个节点代表一个任务或进程。</p>
</li>
<li>
<p><strong>有向边（Directed Edges）</strong>：图中的边表示任务或进程之间的依赖关系。如果存在一条从节点 A 指向节点 B 的有向边，那么它表示任务 A 必须在任务 B 之前完成。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>前趋图的作用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>确定执行顺序</strong>：通过分析前趋图，可以确定哪些任务可以并行执行，哪些任务必须按顺序执行。</p>
</li>
<li>
<p><strong>避免死锁</strong>：在操作系统中，前趋图可以帮助设计避免死锁的资源分配策略。</p>
</li>
<li>
<p><strong>优化调度</strong>：在编译器设计中，前趋图可以帮助优化指令的执行顺序，提高程序的执行效率。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>前趋图的示例：</p>
</div>
<div class="paragraph">
<p>假设有四个任务 A、B、C、D，其中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>任务 A 必须在任务 B 和 C 之前完成。</p>
</li>
<li>
<p>任务 B 和 C 必须在任务 D 之前完成。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>前趋图可以表示为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><span></span>  A
  │
  ▼
  B---C
  │    │
  ▼    ▼
    D</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个图中，A 是 B 和 C 的前趋，B 和 C 是 D 的前趋。</p>
</div>
<div class="paragraph">
<p>在操作系统的进程调度中，前趋图可以帮助操作系统确定进程的执行顺序，确保系统资源的有效利用和进程的正确执行。</p>
</div>
</div>
<div class="sect3">
<h4 id="_8_1_2_pv_操作">8.1.2 PV 操作</h4>
<div class="paragraph">
<p>PV 操作是操作系统中用于进程同步与互斥的一种机制，由两部分组成：
P 操作（Proberen，荷兰语中的“测试”）和 V 操作（Verhogen，荷兰语中的“增加”）。这种机制通常与信号量（Semaphore）一起使用，信号量是一个整数变量，用于控制对共享资源的访问。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>P 操作（等待操作）</p>
<div class="ulist">
<ul>
<li>
<p>P 操作用于申请资源。当一个进程需要访问共享资源时，它会执行 P操作。如果信号量的值大于 0，表示资源可用，信号量减 1，进程继续执行。如果信号量的值为 0，表示资源不可用，进程将被阻塞，直到信号量的值变为正数。</p>
</li>
</ul>
</div>
</li>
<li>
<p>V 操作（释放操作）</p>
<div class="ulist">
<ul>
<li>
<p>V 操作用于释放资源。当一个进程完成对共享资源的访问后，它会执行 V操作。这会使信号量的值增加 1。如果此时有其他进程因为资源不可用而被阻塞，那么 V 操作会唤醒其中一个阻塞的进程，使其可以继续执行。</p>
</li>
</ul>
</div>
</li>
<li>
<p>信号量的类型</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>整型信号量</strong>：信号量的值可以是任意整数，用于表示资源的数量。当信号量的值为 0 时，表示没有资源可用。</p>
</li>
<li>
<p><strong>二进制信号量</strong>：信号量的值只能是 0 或 1，用于实现互斥锁。0 表示锁被占用，1 表示锁可用。</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>PV 操作广泛应用于操作系统中的进程同步、互斥、死锁避免等领域。例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>进程同步</strong>：确保多个进程按照特定的顺序执行。</p>
</li>
<li>
<p><strong>互斥访问</strong>：确保在任何时刻只有一个进程可以访问共享资源。</p>
</li>
<li>
<p><strong>避免死锁</strong>：通过控制资源的分配和释放，避免系统进入死锁状态。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过合理使用 PV 操作，可以有效地管理进程间的协作和资源共享，提高系统的稳定性和效率。</p>
</div>
</div>
<div class="sect3">
<h4 id="_8_1_3_example_信号量初值等于_0">8.1.3 Example 信号量初值等于 0</h4>
<div class="paragraph">
<p>进程 P1、P2、P3、P4、P5 的 <a href="img/graphviz-pv-2025-05-08-193314.png">前趋图</a> 如下：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-pv-2025-05-08-193314.svg" alt="graphviz pv 2025 05 08 193314" width="267" height="140">
</div>
</div>
<div class="paragraph">
<p>若用 PV 操作控制进程并发执行的过程，则需要设置 4 个信号量 S1、S2、S3、S4，且信号量初值都等于零。下面 <a href="img/graphviz-2025-05-08-194149.png">PV图</a> 中 a 和 b 应分别填写（），c 和 d 应分别填写（），e 和 f 应分别填写（）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-2025-05-08-194149.png" alt="graphviz 2025 05 08 194149" width="467" height="296">
</div>
</div>
<div class="paragraph">
<p><strong>答案解析：</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>a 和 b 处</strong>：当 P1 和 P2 执行完毕后，它们需要通过执行 V 操作来增加信号量 S1 和 S2 的值，从而通知 P3 可以开始执行。因此，<mark>a 处应填写 V(S1)，b 处应填写 V(S2)</mark>。</p>
</li>
<li>
<p><strong>c 和 d 处</strong>：进程 P3 在开始执行前，需要通过执行 P 操作来检查 S1 和 S2 的值是否大于 0。如果 S1 和 S2 的值都大于 0，表示 P1 和 P2 已经执行完毕，P3 可以开始执行。因此，<mark>c 处应填写 P(S1) 和 P(S2)</mark>，<mark>d 处应填写 V(S3) 和 V(S4)</mark>。</p>
</li>
<li>
<p><strong>e 和 f 处</strong>：进程 P4 和 P5 在开始执行前，需要通过执行 P 操作来检查 S3 和 S4 的值是否大于 0。如果 S3 和 S4 的值都大于 0，表示 P3 已经执行完毕，P4 和 P5 可以开始执行。因此，<mark>e 处应填写 P(S3)，f 处应填写 P(S4)</mark>。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_8_1_4_example_信号量初值不等于_0">8.1.4 Example 信号量初值不等于 0</h4>
<div class="paragraph">
<p>某企业的生产流水线上有2名工人 P1 和 P2，1名检验员 P3。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>P1 将初步加工的半成品放入半成品箱 B1；</p>
</li>
<li>
<p>P2 从半成品箱 B1 取出继续加工，加工好的产品放入成品箱 B2；</p>
</li>
<li>
<p>P3 从成品箱  B2 取出产品校验。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>假设 B1 可存放 n 件半成品，B2 可存放 m 件产品，并设置 6 个信号量 S1、S2、S3、S4、S5 和 S6，且 S3 和 S6 的初值都为 0。</p>
</div>
<div class="paragraph">
<p>采用 PV 操作实现 P1、P2 和 P3 的同步模型如下图所示，S2、S4 的初值分别为（ ）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-2025-05-12-075618.svg" alt="graphviz 2025 05 12 075618" width="611" height="706">
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>A n、0
B m、0
C m、n
D n、m</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>分析：</p>
</div>
<div class="paragraph">
<p>在本题中涉及到的信号量较多，所以先要分析应用场景中哪些地方可能涉及到互斥和同步，这样才能把问题分析清楚。从题目的描述可以了解到整个流程由3名不同的工人协作完成，先进行P1的处理，然后是P2，最后P3，这样要达到协作关系，要使用同步信号量。同时由于P1处理结果会存到B1中，P2再从B1取内容，在此B1不能同时既进入存操作，也进行取操作，这就涉及到互斥。结合配图可以看出：S1信号量是互斥信号量，它确保B1的使用是互斥使用；S5信号量针对B2起到同样的作用。</p>
</div>
<div class="paragraph">
<p>当半成品放入 B1 时，S2 就会减一，且放入后不会得到释放，由此推断 S2 为 B1 箱子容量的信号量，同理可得出 S4 为箱子 B2 的容量的信号量。</p>
</div>
</div>
<div class="sect3">
<h4 id="_8_1_5_信号量s的取值范围">8.1.5 信号量S的取值范围</h4>
<div class="paragraph">
<p>假设系统有n (n≥5) 个进程共享资源R，且资源R的可用数为5。若采用PV操作，则相应的信号量S的取值范围应为（D）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A -1~n-1
B -5~5
C -(n-1)~1
D -(n-5)~5</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>本题中已知有 n 个进程共享 R 资源，且 R 资源的可用数为 5，故信号量 S 的初值应设为 5。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>当第1个进程申请资源时，信号量 S 减 1，即 S=4;</p>
</li>
<li>
<p>当第2个进程申请资源时，信号量 S 减 1，即 S=3;</p>
</li>
<li>
<p>当第3个进程申请资源时，信号量 S 减 1，即 S=2;</p>
</li>
<li>
<p>当第4个进程申请资源时，信号量 S 减 1，即 S=1;</p>
</li>
<li>
<p>当第5个进程申请资源时，信号量 S 减 1，即 S=0;</p>
</li>
<li>
<p>当第6个进程申请资源时，信号量 S 减 1，即 S=-1 &#8230;&#8203;..</p>
</li>
<li>
<p>当第n个进程申请资源时，信号量 S 减 1，即 S=-(n-5)。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>经上分析，信号量的取值范围应在-(n-5)~5。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
信号量可以为负值，负值表示等待资源的进程数。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_8_2_资源分配图resource_allocation_graph_rag">8.2 资源分配图（Resource Allocation Graph, RAG）</h3>
<div class="ulist">
<ul>
<li>
<p><strong>用途</strong>：用于分析<strong>死锁</strong>。</p>
</li>
<li>
<p><strong>核心概念</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>节点包括<strong>进程（P）</strong>和<strong>资源（R）</strong>。</p>
</li>
<li>
<p>边表示<strong>资源请求</strong>或<strong>资源分配</strong>。</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>目标</strong>：判断系统是否可能出现<strong>死锁</strong>。</p>
</li>
<li>
<p><strong>关键点</strong>：循环等待是死锁的重要条件之一，图中若存在<strong>有向环</strong>，可能表示死锁（特别是在每种资源只有一个实例时）。</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">与PV 操作（也称信号量机制）区别</div>
<div class="ulist">
<ul>
<li>
<p><strong>用途</strong>：用于实现进程的<strong>互斥与同步</strong>。</p>
</li>
<li>
<p><strong>核心概念</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>P 操作（也叫 wait 或 down）：请求资源或进入临界区。</p>
</li>
<li>
<p>V 操作（也叫 signal 或 up）：释放资源或退出临界区。</p>
</li>
<li>
<p>常用于解决<strong>临界区问题</strong>、<strong>生产者-消费者问题</strong>、<strong>读者-写者问题</strong>等。</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>目标</strong>：确保进程之间不会出现<strong>竞态条件（race condition）</strong>，并实现正确的协作。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_8_2_1_example_阻塞节点和死锁">8.2.1 Example 阻塞节点和死锁</h4>
<div class="paragraph">
<p>进程资源图如图(a)和(b)所示，其中：图(a)中（B）; 图(b)中（C）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-2025-05-12-103138.svg" alt="graphviz 2025 05 12 103138" width="452" height="457">
</div>
<div class="title">Figure 10. 图 a</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>P → R：表示 “进程请求资源”</p>
</li>
<li>
<p>R → P：表示 “资源分配给进程”</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="literalblock">
<div class="content">
<pre>A P1是非阻塞节点，P2是阻塞节点，所以该图不可以化简，是死锁的
B P1、P2都是阻塞节点，所以该图不可以化简，是死锁的
C P1、P2都是非阻塞节点，所以该图可以化简，是非死锁的
D P1是阻塞节点，P2是非阻塞节点，所以该图不可以化简、是死锁的</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>分析图 a：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>因为 R1 资源只有 2 个，P2 申请该资源得不到满足，故进程 P2 是阻塞节点；</p>
</li>
<li>
<p>同样 R2 资源只有 3 个，P1 申请该资源得不到满足，故进程 P1 也是阻塞节点。</p>
</li>
<li>
<p>可见进程资源图（a）是死锁的，该图不可以化简。正确答案：B</p>
</li>
</ul>
</div>
<hr>
<div class="imageblock">
<div class="content">
<img src="img/graphviz-2025-05-12-112329.svg" alt="graphviz 2025 05 12 112329" width="490" height="538">
</div>
<div class="title">Figure 11. 图 b</div>
</div>
<div class="literalblock">
<div class="content">
<pre>A P1、P2、P3都是非阻塞节点，该图可以化简，是非死锁的
B P1、P2、P3都是阻塞节点，该图不可以化简，是死锁的
C P2是阻塞节点，P1、P3是非阻塞节点，该图可以化简，是非死锁的
D P1、P2是非阻塞节点，P3是阻塞节点，该图不可以化简，是死锁的。</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>分析图 b：</p>
</div>
<div class="paragraph">
<p>因为 R2 资源有3个，已分配2个，P3申请1个R2资源可以得到满足（P1也可以），故进程P3可以运行完毕释放其占有的资源。
这样可以使得P1、P3都变为非阻塞节点，得到所需资源运行完毕，因此，进程资源图（b）是可化简的。</p>
</div>
<div class="paragraph">
<p>正确答案：C</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>关键点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>阻塞节点是指一个进程申请的资源当前不可用，所以它必须等待。</p>
</li>
<li>
<p>非阻塞节点是指一个进程可以立即获得它申请的所有资源，能够运行完成并释放资源。</p>
</li>
<li>
<p>如果一个图可以逐步化简（即所有进程都能按某种顺序完成），那么就没有死锁。</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_数据库">9 数据库</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_9_1_关系模式">9.1 关系模式</h3>
<div class="paragraph">
<p>设有关系模式 R（课程，教师，学生，成绩，时间，教室），其中函数依赖集 F 如下：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>F＝{
     课程 -&gt;-&gt; 教师，
    (学生，课程) -&gt; 成绩，
    (时间，教室) -&gt; 课程，
    (时间，教师) -&gt; 教室，
    (时间，学生) -&gt; 教室
}</pre>
</div>
</div>
<div class="paragraph">
<p>问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>关系模式 R 的一个主键是 （1）</p>
</li>
<li>
<p>R 规范化程度最高达到 （2）</p>
</li>
<li>
<p>若将关系模式 R 分解为三个关系模式</p>
<div class="literalblock">
<div class="content">
<pre>R1（课程，教师）
R2（学生，课程，成绩）
R3（学生，时间，教室，课程 ），</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>其中 R2 的规范化程度最高达到 （3） 。</p>
</div>
<hr>
<h4 id="_该题目简化版为" class="discrete">该题目简化版为</h4>
<div class="paragraph">
<p>我们有一个表格 <code>R</code>，包含6个字段：
‌<strong>课程、教师、学生、成绩、时间、教室</strong>‌，已知这些字段之间有如下关联规则（函数依赖）：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>一门课程可能对应多个教师（课程→→教师）</p>
</li>
<li>
<p>学生+课程可以确定成绩（学生,课程→成绩）</p>
</li>
<li>
<p>时间+教室可以确定课程（时间,教室→课程）</p>
</li>
<li>
<p>时间+教师可以确定教室（时间,教师→教室）</p>
</li>
<li>
<p>时间+学生可以确定教室（时间,学生→教室）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>问题：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>‌<strong>主键是什么？</strong>‌</p>
</li>
<li>
<p>‌<strong>这个表格设计最高满足第几范式（1NF/2NF/3NF/BCNF）？</strong>‌</p>
</li>
<li>
<p>‌<strong>如果把表格拆成三个小表，其中 R2(学生,课程,成绩) 最高满足第几范式？</strong>‌</p>
</li>
</ol>
</div>
<hr>
<h4 id="_第一步找主键问题1" class="discrete">第一步：找主键（问题1）</h4>
<div class="paragraph">
<p>‌<strong>主键</strong>‌ 是能唯一确定一行数据的最小字段组合。<strong>怎么找？</strong>‌
尝试用最少的字段组合，看看能否推导出所有其他字段。</p>
</div>
<div class="paragraph">
<p>‌<strong>候选组合：<code>(时间,学生)</code></strong>‌</p>
</div>
<div class="ulist">
<ul>
<li>
<p>已知 <code>时间+学生→教室</code>（规则5）</p>
</li>
<li>
<p>已知 <code>时间+教室→课程</code>（规则3）→ 所以 <code>时间+学生→课程</code></p>
</li>
<li>
<p>已知 <code>学生+课程→成绩</code>（规则2）→ 所以 <code>时间+学生→成绩</code></p>
</li>
<li>
<p>课程 &#8594;&#8594; 教师（规则1，但教师是多值依赖，不影响主键）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>✅ ‌<strong>结论</strong>‌：<code>(时间,学生)</code> 能推出所有字段，是主键。</p>
</div>
<hr>
<h4 id="_第二步判断范式问题2" class="discrete">第二步：判断范式（问题2）</h4>
<div class="paragraph">
<p>‌<strong>范式升级路线</strong>‌：1NF → 2NF → 3NF → BCNF → 4NF
我们逐步检查：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>‌<strong>1NF</strong>‌：表格没有重复列（比如没有“电话1,电话2”这种），每个字段都是不可再分的原子数据项，满足 ✅</p>
</li>
<li>
<p>‌<strong>2NF</strong>‌：要求所有非主属性（成绩、教室、课程、教师）必须‌<strong>完全依赖</strong>‌主键（不能只依赖主键的一部分）。</p>
<div class="ulist">
<ul>
<li>
<p>主键是 <code>(时间,学生)</code>，它由两个字段组成。</p>
</li>
<li>
<p>检查是否有字段只依赖`时间`或只依赖`学生`？</p>
</li>
<li>
<p><code>成绩`依赖</code>(学生,课程)<code>，而`课程`又依赖</code>(时间,学生)` → 间接完全依赖主键 ✅</p>
</li>
<li>
<p><code>教室`直接依赖</code>(时间,学生)` ✅</p>
</li>
<li>
<p><code>教师`依赖`课程</code>（多值依赖），但`课程`依赖主键 ✅</p>
</li>
<li>
<p>满足2NF ✅</p>
</li>
</ul>
</div>
</li>
<li>
<p>‌<strong>3NF</strong>‌：要求非主属性‌<strong>不能传递依赖</strong>‌主键（即不能有 A→B→C 这种链式依赖）。</p>
<div class="ulist">
<ul>
<li>
<p>发现传递依赖：
<code>(时间,学生)→教室</code>，且`(时间,教室)→课程` → 即 <code>(时间,学生)→教室→课程</code> ❌</p>
</li>
<li>
<p>还有多值依赖 <code>课程→→教师</code> ❌</p>
</li>
<li>
<p>‌<strong>不满足3NF</strong>‌，最高到2NF。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<hr>
<h4 id="_第三步分解后的r2范式问题3" class="discrete">第三步：分解后的R2范式（问题3）</h4>
<div class="paragraph">
<p>分解后的小表 <code>R2(学生,课程,成绩)</code>：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>‌<strong>函数依赖</strong>‌：<code>(学生,课程)→成绩</code></p>
</li>
<li>
<p>‌<strong>主键</strong>‌：<code>(学生,课程)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>检查范式：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>‌<strong>1NF</strong>‌：满足 ✅</p>
</li>
<li>
<p>‌<strong>2NF</strong>‌：非主属性`成绩`完全依赖主键（没有部分依赖） ✅</p>
</li>
<li>
<p>‌<strong>3NF</strong>‌：没有传递依赖（只有`(学生,课程)→成绩`一条直接依赖） ✅</p>
</li>
<li>
<p>‌<strong>BCNF</strong>‌：所有依赖的左部都是候选键（这里依赖的左部`(学生,课程)`本身就是主键） ✅</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>✅ ‌<strong>R2最高满足BCNF</strong>‌。</p>
</div>
<hr>
<h4 id="_最终答案_2" class="discrete">最终答案</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>主键：‌<strong>(时间,学生)</strong>‌</p>
</li>
<li>
<p>原表R最高满足：‌<strong>2NF</strong>‌</p>
</li>
<li>
<p>分解后的R2最高满足：‌<strong>BCNF</strong>‌</p>
</li>
</ol>
</div>
<hr>
<h4 id="_举个实际例子" class="discrete">举个实际例子</h4>
<div class="paragraph">
<p>假设有一个选课表：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">时间</th>
<th class="tableblock halign-left valign-top">学生</th>
<th class="tableblock halign-left valign-top">教室</th>
<th class="tableblock halign-left valign-top">课程</th>
<th class="tableblock halign-left valign-top">教师</th>
<th class="tableblock halign-left valign-top">成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">周一9:00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">张三</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">101</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数学</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">王老师</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">90</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">周一9:00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">李四</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">101</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数学</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">王老师</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">85</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>‌<strong>主键</strong>‌：<code>(时间,学生)</code>（比如“周一9:00+张三”能唯一确定一行）</p>
</li>
<li>
<p>‌<strong>问题</strong>‌：</p>
<div class="ulist">
<ul>
<li>
<p>如果王老师换了，所有相关行都要修改（数据冗余）→ 不满足3NF</p>
</li>
<li>
<p>拆成小表后（如R2只存学生-课程-成绩），冗余消失 → 满足BCNF</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<hr>
<h4 id="_你需要记住的套路" class="discrete">你需要记住的套路</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>‌<strong>找主键</strong>‌：从最小字段组合出发，尝试推导所有其他字段。</p>
</li>
<li>
<p>‌<strong>判断范式</strong>‌：</p>
<div class="ulist">
<ul>
<li>
<p>2NF：非主属性必须完全依赖主键</p>
</li>
<li>
<p>3NF：不能有传递依赖</p>
</li>
<li>
<p>BCNF：所有依赖的左部必须是候选键</p>
</li>
</ul>
</div>
</li>
<li>
<p>‌<strong>多值依赖</strong>‌（→→）需 4NF 去解决，但题目中因传递依赖先卡在2NF。</p>
</li>
</ol>
</div>
<hr>
<div class="paragraph">
<p>该视频 1NF/2NF/3NF 讲得清楚 <a href="https://www.youtube.com/watch?v=rHiyuR2bElE" class="bare">https://www.youtube.com/watch?v=rHiyuR2bElE</a></p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/Snipaste_2025-05-10_17-21-37.png" alt="1NF-2NF-3NF" width="520">
</div>
</div>
<div class="sect3">
<h4 id="_9_1_1_求候选键">9.1.1 求候选键</h4>
<h5 id="_数据库中的候选键candidate_key" class="discrete">数据库中的候选键（Candidate Key）</h5>
<div class="paragraph">
<p>在数据库中，<strong>候选键（Candidate Key）</strong> 是指在一个关系（表）中，能够唯一标识元组（记录）的属性或属性组合。</p>
</div>
<h5 id="_候选键的两个重要特性" class="discrete">候选键的两个重要特性</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>唯一性（Uniqueness）</strong>
能唯一标识一条记录，表中任意两个元组在该属性（组）上的值不相同。</p>
</li>
<li>
<p><strong>最小性（Minimality）</strong>
候选键不能再简化，即不能再去掉其中的任何一个属性，否则就不能保证唯一性。</p>
</li>
</ol>
</div>
<h5 id="_示例" class="discrete">示例</h5>
<div class="paragraph">
<p>假设有一个学生表 <code>Student</code>：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">学号（student_id）</th>
<th class="tableblock halign-left valign-top">身份证号（id_card）</th>
<th class="tableblock halign-left valign-top">姓名（name）</th>
<th class="tableblock halign-left valign-top">电话号码（phone）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1001</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">123456789012345678</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">张三</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13800000001</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1002</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">234567890123456789</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">李四</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13800000002</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>分析：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>student_id</code> 能唯一标识一个学生 → 是候选键。</p>
</li>
<li>
<p><code>id_card</code> 也是唯一的 → 是候选键。</p>
</li>
<li>
<p><code>name</code> 和 <code>phone</code> 单独都不唯一 → 不是候选键。</p>
</li>
<li>
<p>如果 <code>name + phone</code> 组合能唯一标识学生，也可作为候选键（但通常不推荐）。</p>
</li>
</ul>
</div>
<h5 id="_候选键与主键的关系" class="discrete">候选键与主键的关系</h5>
<div class="ulist">
<ul>
<li>
<p><strong>主键（Primary Key）</strong> 是从候选键中选出来的一个，作为主要标识使用。</p>
</li>
<li>
<p>一个表可以有多个候选键，但 <strong>只能有一个主键</strong>。</p>
</li>
</ul>
</div>
<h5 id="_小结" class="discrete">小结</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">概念</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">候选键</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">能唯一标识记录，且不能再简化</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">主键</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">候选键中被选为主标识的那个</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">唯一性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有记录的该键值都不相同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">最小性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不能包含多余的属性</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_9_1_2_无损连接分解">9.1.2 无损连接分解</h4>
<div class="paragraph">
<p>什么是无损连接分解？</p>
</div>
<div class="paragraph">
<p><strong>一个关系 R 被分解成若干子关系（如 R1、R2），如果通过自然连接（JOIN）能</strong>：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>完全还原出原关系 R，</p>
</li>
<li>
<p>且没有出现冗余或丢失信息，</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>就称为这个分解是 <strong>无损连接（Lossless Join）</strong>。</p>
</div>
<hr>
<div class="paragraph">
<p>如何判断分解是否为无损连接？</p>
</div>
<div class="paragraph">
<p>对两个子关系 <code>R1</code> 和 <code>R2</code>，只要满足以下 <strong>任意一条</strong>，就是无损连接：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong><code>R1 ∩ R2 → R1 - R2 ∈ F⁺</code></strong>
<strong>或</strong>
<strong><code>R1 ∩ R2 → R2 - R1 ∈ F⁺</code></strong></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>说明：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>R1 ∩ R2</code>: 两个子关系的<strong>交集属性</strong></p>
</li>
<li>
<p><code>R1 - R2</code>: <code>R1</code> 中独有的属性</p>
</li>
<li>
<p><code>F⁺</code>: 函数依赖集合 <code>F</code> 的<strong>闭包</strong></p>
</li>
</ul>
</div>
<hr>
<div class="paragraph">
<p>判断步骤（口诀）：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>求交集</strong> <code>R1 ∩ R2</code></p>
</li>
<li>
<p><strong>求差集</strong> <code>R1 - R2</code> 和 <code>R2 - R1</code></p>
</li>
<li>
<p>判断交集属性能否推出任意一个差集（在 <code>F⁺</code> 中）</p>
<div class="ulist">
<ul>
<li>
<p>如果能推出 ⇒ ✅ 无损连接</p>
</li>
<li>
<p>否则 ⇒ ❌ 有损连接</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<hr>
<div class="paragraph">
<p>小结一句话：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>只要两个表的交集属性能推出任意一边的差集，就一定是无损连接。</strong></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><strong>举例说明：</strong></p>
</div>
<div class="paragraph">
<p>假设：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>原关系：R(A, B, C)</p>
</li>
<li>
<p>函数依赖：F = { A → B }</p>
</li>
<li>
<p>分解为：</p>
<div class="ulist">
<ul>
<li>
<p>R1(A, B)</p>
</li>
<li>
<p>R2(A, C)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>分析：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>R1 ∩ R2 = A</p>
</li>
<li>
<p>R1 - R2 = B</p>
</li>
<li>
<p>R2 - R1 = C</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们去判断：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A → B ∈ F⁺ ✅ 是的！所以满足第一条 ⇒ 无损连接！</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>即使：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A → C ❌ 不成立也无所谓！</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_9_1_3_保持函数依赖">9.1.3 保持函数依赖</h4>
<div class="paragraph">
<p>给定关系模式R(A1，A2，A3，A4)上的函数依赖集F={A1A3&#8594;A2,A2&#8594;A3}。若将R分解为p ={(A1,A2),(A1,A3)}，则该分解是（D）的。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 无损联接且不保持函数依赖
B 无损联接且保持函数依赖
C 有损联接且保持函数依赖
D 有损联接且不保持函数依赖</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>原始函数依赖分析，给定函数依赖集：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>F = { A1A3 -&gt; A2, A2 -&gt; A3 }</pre>
</div>
</div>
<div class="paragraph">
<p>分析依赖是否在子关系中完整保留</p>
</div>
<div class="ulist">
<ul>
<li>
<p>依赖 A1A3 &#8594; A2：</p>
<div class="ulist">
<ul>
<li>
<p>涉及属性：A1, A3, A2</p>
</li>
<li>
<p>子关系为：</p>
<div class="ulist">
<ul>
<li>
<p>R1 = (A1, A2)</p>
</li>
<li>
<p>R2 = (A1, A3)</p>
</li>
</ul>
</div>
</li>
<li>
<p>该依赖所涉及的所有属性并不完全存在于某一个子关系中。</p>
</li>
</ul>
</div>
</li>
<li>
<p>依赖 A2 &#8594; A3：</p>
<div class="ulist">
<ul>
<li>
<p>涉及属性：A2, A3</p>
</li>
<li>
<p>子关系中：</p>
<div class="ulist">
<ul>
<li>
<p>R1 包含 A2，但不包含 A3</p>
</li>
<li>
<p>R2 包含 A3，但不包含 A2</p>
</li>
</ul>
</div>
</li>
<li>
<p>同样，该依赖也不完全存在于任一子关系中。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>结论：该分解 <strong>不保持函数依赖</strong>。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
如果 F 中两个依赖的任何一个不能从 F1 ∪ F2 推导出，那就不保持函数依赖。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
无损联接使用前面的方法进行判断。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_9_2_关系代数表达式">9.2 关系代数表达式</h3>
<div class="paragraph">
<p>给定关系 R(A，B，C，D) 和关系 S(A，D，E，F)</p>
</div>
<div class="ulist">
<ul>
<li>
<p>若对这两个关系进行自然连接运算 R▷◁S 后的属性列有（ ）个;</p>
</li>
<li>
<p>关系代数表达式 σR.B&gt;S.F(R▷◁S) 与（ ）等价。</p>
<div class="literalblock">
<div class="content">
<pre>A  σ2&gt;8(RxS)
B  π1，2，3，4，7，8(σ1=5^2&gt;8^4=6(R×S)
C  σ"2"&gt;"8"(RxS)
D  π1，2，3，4，7，8(σ1=5^"2"&gt;"8"^4=6(RxS))</pre>
</div>
</div>
</li>
</ul>
</div>
<hr>
<div class="paragraph">
<p><strong>理解题目中的符号和概念‌</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>‌关系（表）的结构‌</p>
<div class="ulist">
<ul>
<li>
<p>R(A, B, C, D)‌：这是一个名为 R 的表，有 4 列（属性），分别是 A, B, C, D。</p>
</li>
<li>
<p>S(A, D, E, F)‌：这是一个名为 S 的表，有 4 列（属性），分别是 A, D, E, F。</p>
</li>
</ul>
</div>
</li>
<li>
<p>‌自然连接（Natural Join, R▷◁S）‌</p>
<div class="ulist">
<ul>
<li>
<p>作用‌：将两个表按照‌相同的列名‌自动连接起来，并‌合并相同名称的列‌。</p>
</li>
<li>
<p>规则‌：</p>
<div class="ulist">
<ul>
<li>
<p>如果两个表有相同名称的列（这里是 A 和 D），则连接时只保留一份。</p>
</li>
<li>
<p>最终结果的列是所有‌不重复的列‌的组合。</p>
</li>
</ul>
</div>
</li>
<li>
<p>举例‌：</p>
<div class="ulist">
<ul>
<li>
<p>R 的列：A, B, C, D</p>
</li>
<li>
<p>S 的列：A, D, E, F</p>
</li>
<li>
<p><mark>自然连接后，A 和 D 只保留一份，所以结果是：A, B, C, D, E, F（共 6 列）。</mark></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>‌选择运算（σ）‌</p>
<div class="ulist">
<ul>
<li>
<p>作用‌：从表中筛选出满足条件的行（类似于 SQL 的 WHERE）。</p>
</li>
<li>
<p>例如：σR.B &gt; S.F(R▷◁S) 表示从 R▷◁S 的结果中筛选出 R.B &gt; S.F 的行。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
希腊字母 σ（sigma） 的中文读音是 “西格玛”（拼音：xī gé mǎ）。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_9_2_1_问题1">9.2.1 问题1</h4>
<div class="paragraph">
<p>问题1‌：自然连接 R▷◁S 后有多少列？</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们已经知道：</p>
<div class="ulist">
<ul>
<li>
<p>R 的列：A, B, C, D</p>
</li>
<li>
<p>S 的列：A, D, E, F</p>
</li>
</ul>
</div>
</li>
<li>
<p>自然连接会合并相同名称的列（A 和 D），所以结果是：</p>
<div class="ulist">
<ul>
<li>
<p>A, B, C, D, E, F（共 6 列）。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_9_2_2_问题2">9.2.2 问题2</h4>
<div class="paragraph">
<p>问题2‌：σR.B &gt; S.F(R▷◁S) 等价于哪个选项？</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们需要找到一个等价的关系代数表达式。</p>
</li>
<li>
<p>题目给出的选项是：</p>
<div class="literalblock">
<div class="content">
<pre>A: σ2&gt;8(R×S)
B: π1,2,3,4,7,8(σ1=5∧2&gt;8∧4=6(R×S))
C: σ"2"&gt;"8"(R×S)
D: π1,2,3,4,7,8(σ1=5∧"2"&gt;"8"∧4=6(R×S))</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>关键点‌：</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>R×S 是‌笛卡尔积‌（Cartesian Product），即 R 和 S 的所有可能组合，会有 4 + 4 = 8 列：</p>
<div class="ulist">
<ul>
<li>
<p>列顺序：R.A, R.B, R.C, R.D, S.A, S.D, S.E, S.F（即第1-8列）。</p>
</li>
</ul>
</div>
</li>
<li>
<p>自然连接 R▷◁S 实际上是：</p>
<div class="ulist">
<ul>
<li>
<p>先做 R×S，</p>
</li>
<li>
<p>然后筛选 R.A = S.A 且 R.D = S.D 的行（因为自然连接要求相同列的值相等），</p>
</li>
<li>
<p>最后去掉重复的 A 和 D（即保留 R.A, R.B, R.C, R.D, S.E, S.F）。</p>
</li>
</ul>
</div>
</li>
<li>
<p>σR.B &gt; S.F(R▷◁S) 的意思是：</p>
<div class="ulist">
<ul>
<li>
<p>在自然连接的结果中，筛选 R.B &gt; S.F 的行。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>如何用 R×S 表示？‌</strong> 我们需要：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>先做 R×S（8列）。</p>
</li>
<li>
<p>筛选 R.A = S.A（即第1列 = 第5列）和 R.D = S.D（即第4列 = 第6列）。</p>
</li>
<li>
<p>再筛选 R.B &gt; S.F（即第2列 &gt; 第8列）。</p>
</li>
<li>
<p>最后投影需要的列（A, B, C, D, E, F，即第 1,2,3,4,7,8 列）。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>对应选项‌：</p>
</div>
<div class="paragraph">
<p>π1,2,3,4,7,8(σ1=5∧2&gt;8∧4=6(R×S))（选项B）：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1=5：R.A = S.A
4=6：R.D = S.D
2&gt;8：R.B &gt; S.F
π1,2,3,4,7,8：保留 A, B, C, D, E, F。</pre>
</div>
</div>
<div class="paragraph">
<p>为什么其他选项不对？‌</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A: 缺少 R.A = S.A 和 R.D = S.D 的条件。
C: 引号错误（"2"&gt;"8" 是字符串比较，不是列号）。
D: 引号错误（同C）。</pre>
</div>
</div>
<div class="paragraph">
<p>第三步：总结答案‌</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>自然连接 R▷◁S 后有 ‌6列‌（A, B, C, D, E, F）。</p>
</li>
<li>
<p>σR.B &gt; S.F(R▷◁S) 等价于 ‌选项B‌：</p>
<div class="ulist">
<ul>
<li>
<p>π1,2,3,4,7,8(σ1=5∧2&gt;8∧4=6(R×S))。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_9_2_3_举一个具体例子">9.2.3 举一个具体例子‌</h4>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<caption class="title">R 表：</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">D</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<caption class="title">S 表：</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>自然连接 R▷◁S 的结果‌：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>匹配 R.A = S.A 且 R.D = S.D：</p>
<div class="ulist">
<ul>
<li>
<p>第1行：(1,5,10,20) 和 (1,20,100,3) → (1,5,10,20,100,3)</p>
</li>
<li>
<p>第2行：(2,8,15,30) 和 (2,30,200,7) → (2,8,15,30,200,7)</p>
</li>
</ul>
</div>
</li>
<li>
<p>结果：</p>
<table class="tableblock frame-all grid-all" style="width: 75%;">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">F</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
<div class="paragraph">
<p>筛选 R.B &gt; S.F‌：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>第1行：5 &gt; 3 → 保留</p>
</li>
<li>
<p>第2行：8 &gt; 7 → 保留</p>
</li>
<li>
<p>结果和上面一样。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>用选项 B 的方式计算‌：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>先做 R×S（4 行 8 列）：</p>
<div class="ulist">
<ul>
<li>
<p>第1行：(1,5,10,20,1,20,100,3)</p>
</li>
<li>
<p>第2行：(1,5,10,20,2,30,200,7)</p>
</li>
<li>
<p>第3行：(2,8,15,30,1,20,100,3)</p>
</li>
<li>
<p>第4行：(2,8,15,30,2,30,200,7)</p>
</li>
</ul>
</div>
</li>
<li>
<p>筛选 1=5 且 4=6 且 2&gt;8：</p>
<div class="ulist">
<ul>
<li>
<p>第1行：1=1 且 20=20 且 5&gt;3 → 保留</p>
</li>
<li>
<p>第4行：2=2 且 30=30 且 8&gt;7 → 保留</p>
</li>
</ul>
</div>
</li>
<li>
<p>投影 1,2,3,4,7,8：</p>
<div class="ulist">
<ul>
<li>
<p>第1行：(1,5,10,20,100,3)</p>
</li>
<li>
<p>第4行：(2,8,15,30,200,7)</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>结果和自然连接一致。</p>
</div>
<div class="paragraph">
<p>最终答案‌</p>
</div>
<div class="ulist">
<ul>
<li>
<p>自然连接后的列数：‌6列‌</p>
</li>
<li>
<p>等价的关系代数表达式：‌选项B‌</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_9_3_数据库模式">9.3 数据库模式</h3>
<div class="paragraph">
<p>数据的物理独立性和逻辑独立性分别是通过修改（ ）来完成的。</p>
</div>
<div class="paragraph">
<p>A 外模式与内模式之间的映像、模式与内模式之间的映像</p>
</div>
<div class="paragraph">
<p>B 外模式与内模式之间的映像、外模式与模式之间的映像</p>
</div>
<div class="paragraph">
<p>C 外模式与模式之间的映像、模式与内模式之间的映像</p>
</div>
<div class="paragraph">
<p>D 模式与内模式之间的映像、外模式与模式之间的映像</p>
</div>
<div class="paragraph">
<p>答案：D</p>
</div>
</div>
<div class="sect2">
<h3 id="_9_4_数据库设计">9.4 数据库设计</h3>
<div class="paragraph">
<p>确定系统边界和关系规范化分别在数据库设计的（A）阶段进行。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 需求分析和逻辑设计
B 需求分析和概念设计
C 需求分析和物理设计
D 逻辑设计和概念设计</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>在数据库设计中，确定系统边界和关系规范化分别对应不同的阶段：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>确定系统边界</strong>：这是在<strong>需求分析</strong>阶段进行的，目的是明确系统的范围和功能需求，确定哪些数据需要被纳入数据库系统。</p>
</li>
<li>
<p><strong>关系规范化</strong>：这是在<strong>逻辑设计</strong>阶段进行的，目的是通过范式（如1NF、2NF、3NF等）优化关系模式，减少数据冗余和异常。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>因此，正确答案是：<strong>A. 需求分析和逻辑设计</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_9_5_数据库锁">9.5 数据库锁</h3>
<div class="paragraph">
<p>若事务T1对数据A已加排它锁，那么其它事务对数据A（D） 。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 加共享锁成功，加排它锁失败
B 加排它锁成功，加共享锁失败
C 加共享锁、加排它锁都成功
D 加共享锁、加排它锁都失败</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>解析：本题考查的是数据库事务处理方面的基础知识。并发事务如果对数据读写时不加以控制，会破坏事务的隔离性和一致性。</p>
</div>
<div class="paragraph">
<p>控制手段就是加锁，在事务执行时限制其他事务对数据的读取。在并发控制中引入两种锁：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>排他锁（Exclusive Locks，X锁）</p>
</li>
<li>
<p>共享锁（Share Locks，S锁）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>排它锁又称为写锁，用于对数据进行写操作时进行锁定。如果事务T对数据A加上X锁后，就只允许事务T对数据A进行读取和修改，其他事务对数据A不能再加任何锁，从而也不能读取和修改数据A，直到事务T释放A上的锁。</p>
</div>
<div class="paragraph">
<p>共享锁又称为读锁，用于对数据进行读取时进行锁定。如果事务T对数据A加上了S锁之后，事务T就只能对数据A进行读
取操作，但不可以修改。其他事务可以再对数据A加S锁来读取，只要数据A上有S锁，任何事务都只能对其加S锁读取而不能加X锁修改。因此，正确答案是D</p>
</div>
</div>
<div class="sect2">
<h3 id="_9_6_not_exists">9.6 NOT EXISTS</h3>
<div class="paragraph">
<p>设供应商供应零件的关系模式为 SP(Sno，Pno，Qty)，其中 Sno 表示供应商号，Pno 表示零件号，Qty 表示零件数量。查询至少包含了供应商 “168” 所供应的全部零件的供应商号的 SQL 语句如下：</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
注意这是一张零件表
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="css"><span></span><span class="tok-nt">SELECT</span><span class="tok-w"> </span><span class="tok-nt">Sno</span>
<span class="tok-nt">FROM</span><span class="tok-w"> </span><span class="tok-nt">SP</span><span class="tok-w"> </span><span class="tok-nt">SPX</span>
<span class="tok-nt">WHERE</span><span class="tok-w"> </span><span class="tok-o">(</span><span class="tok-nt">空1</span><span class="tok-o">)</span>

<span class="tok-o">(</span>
<span class="tok-w">  </span><span class="tok-nt">SELECT</span><span class="tok-w"> </span><span class="tok-o">*</span>
<span class="tok-w">  </span><span class="tok-nt">FROM</span><span class="tok-w"> </span><span class="tok-nt">SP</span><span class="tok-w"> </span><span class="tok-nt">SPY</span>
<span class="tok-w">  </span><span class="tok-nt">WHERE</span><span class="tok-w"> </span><span class="tok-o">(</span><span class="tok-nt">空2</span><span class="tok-o">)</span><span class="tok-w"> </span><span class="tok-nt">AND</span><span class="tok-w"> </span><span class="tok-nt">NOT</span><span class="tok-w"> </span><span class="tok-nt">EXISTS</span><span class="tok-w"> </span><span class="tok-o">(</span>
<span class="tok-w">    </span><span class="tok-nt">SELECT</span><span class="tok-w"> </span><span class="tok-o">*</span>
<span class="tok-w">    </span><span class="tok-nt">FROM</span><span class="tok-w"> </span><span class="tok-nt">SP</span><span class="tok-w"> </span><span class="tok-nt">SPZ</span>
<span class="tok-w">    </span><span class="tok-nt">WHERE</span><span class="tok-w"> </span><span class="tok-o">(</span><span class="tok-nt">空3</span><span class="tok-o">)</span>
<span class="tok-w">  </span><span class="tok-o">)</span>
<span class="tok-o">);</span></code></pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>解：理解题意后要找的是：哪些供应商供应的零件，至少包含了供应商 168 所供应的所有零件？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="css"><span></span><span class="tok-nt">SELECT</span><span class="tok-w"> </span><span class="tok-nt">Sno</span><span class="tok-w"> </span><span class="tok-nt">FROM</span><span class="tok-w"> </span><span class="tok-nt">SP</span><span class="tok-w"> </span><span class="tok-nt">SPX</span>
<span class="tok-w">    </span><span class="tok-nt">WHERE</span><span class="tok-w"> </span><span class="tok-nt">NOT</span><span class="tok-w"> </span><span class="tok-nt">EXISTS</span><span class="tok-w"> </span><span class="tok-o">(</span>
<span class="tok-w">        </span><span class="tok-nt">SELECT</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nt">FROM</span><span class="tok-w"> </span><span class="tok-nt">SP</span><span class="tok-w"> </span><span class="tok-nt">SPY</span>
<span class="tok-w">            </span><span class="tok-nt">WHERE</span><span class="tok-w"> </span><span class="tok-nt">SPY</span><span class="tok-p">.</span><span class="tok-nc">Sno</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-s1">&#39;168&#39;</span><span class="tok-w"> </span><span class="tok-nt">AND</span><span class="tok-w"> </span><span class="tok-nt">NOT</span><span class="tok-w"> </span><span class="tok-nt">EXISTS</span><span class="tok-w"> </span><span class="tok-o">(</span>
<span class="tok-w">                </span><span class="tok-nt">SELECT</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nt">FROM</span><span class="tok-w"> </span><span class="tok-nt">SP</span><span class="tok-w"> </span><span class="tok-nt">SPZ</span>
<span class="tok-w">                    </span><span class="tok-nt">WHERE</span><span class="tok-w"> </span><span class="tok-nt">SPZ</span><span class="tok-p">.</span><span class="tok-nc">Sno</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-nt">SPX</span><span class="tok-p">.</span><span class="tok-nc">Sno</span>
<span class="tok-w">                    </span><span class="tok-nt">AND</span><span class="tok-w"> </span><span class="tok-nt">SPZ</span><span class="tok-p">.</span><span class="tok-nc">Pno</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-nt">SPY</span><span class="tok-p">.</span><span class="tok-nc">Pno</span>
<span class="tok-w">                </span><span class="tok-o">)</span>
<span class="tok-w">    </span><span class="tok-o">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这种查询模式被称为"关系除法"，是SQL中解决"包含所有"这类问题的标准方法。它使用了双重否定(NOT EXISTS中嵌套NOT EXISTS)来表达"全部包含"的概念。</p>
</div>
<div class="sect3">
<h4 id="_9_6_1_如何理解该_sql">9.6.1 如何理解该 SQL</h4>
<div class="paragraph">
<p>当子查询嵌套得很深时，如何调试、打印每一层的结果？</p>
</div>
<div class="paragraph">
<p>解法思路总结：虽然不能直接在嵌套的 SQL 中“打印”每一层结果，但可以把子查询单独拎出来，用具体的值代入，然后逐层测试每一层子查询的结果。可以将其拆分为三层，每层都可以单独执行、理解。</p>
</div>
<div class="paragraph">
<p>我们用一个简化的 SP 表作为例子：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Sno</th>
<th class="tableblock halign-left valign-top">Pno</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">168</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">168</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>第一层：SPY（最简单）</strong></p>
</div>
<div class="literalblock">
<div class="content">
<pre>SELECT * FROM SP SPY WHERE SPY.Sno = '168';</pre>
</div>
</div>
<div class="paragraph">
<p>这会列出供应商 168 供应的所有零件。这一步用于获取“需要包含的全部零件清单”。</p>
</div>
<div class="paragraph">
<p><strong>第二层：SPZ（检查某个供应商是否包含指定零件）</strong></p>
</div>
<div class="paragraph">
<p>假设想测试 SPX.Sno = 'S1'，可以这样写：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>SELECT * FROM SP SPZ WHERE SPZ.Sno = 'S1' AND SPZ.Pno = 'A';</pre>
</div>
</div>
<div class="paragraph">
<p>可以反复用不同的 Pno 测试：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>SELECT * FROM SP SPZ WHERE SPZ.Sno = 'S1' AND SPZ.Pno = 'B';</pre>
</div>
</div>
<div class="paragraph">
<p>这两条 SQL 用来测试：S1 是否供应了零件 A 和 B。如果返回结果为空，就说明它没有供应这个零件。</p>
</div>
<div class="paragraph">
<p><strong>第三层：完整的 SPY + SPZ 联动检查（某个供应商是否漏了168的某个零件）</strong></p>
</div>
<div class="literalblock">
<div class="content">
<pre>SELECT * FROM SP SPY WHERE SPY.Sno = '168' AND NOT EXISTS (
SELECT * FROM SP SPZ WHERE SPZ.Sno = 'S1'   -- 假设我们现在测试 S1
                     AND SPZ.Pno = SPY.Pno
);</pre>
</div>
</div>
<div class="paragraph">
<p>这条 SQL 的含义是：找出供应商 168 的哪些零件 S1 没供应。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果这条查询结果是空的，说明 S1 拥有 168 所有的零件。</p>
</li>
<li>
<p>如果这条查询结果不为空，说明 S1 缺少一些零件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>最外层：整个结构逐个测试</strong></p>
</div>
<div class="paragraph">
<p>遍历所有供应商（Sno），一个一个代入上面这条 SQL：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>-- 替换 SPZ.Sno = 'S1' 为 S2 ...
SELECT *
FROM SP SPY
WHERE SPY.Sno = '168'
  AND NOT EXISTS (
      SELECT *
      FROM SP SPZ
      WHERE SPZ.Sno = 'S2'
        AND SPZ.Pno = SPY.Pno
  );</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>如果返回结果为空 ⇒ S2 包含所有零件</p>
</li>
<li>
<p>如果有返回 ⇒ S2 少某些零件</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>最后就是用 NOT EXISTS 取出相应的 Pno 了</strong></p>
</div>
<div class="literalblock">
<div class="content">
<pre>SELECT Pno FROM SP SPX WHERE NOT EXISTS (
    -- 把上面的 SQL 放进来
)</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_10_网络模型">10 网络模型</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_10_1_osi_七层模型与_tcpip_四层模型">10.1 OSI 七层模型与 TCP/IP 四层模型</h3>
<div class="paragraph">
<p>考生需要掌握 OSI七层模型 的每一层的功能和作用</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">OSI 的七层模型</caption>
<colgroup>
<col style="width: 15.3846%;">
<col style="width: 7.6923%;">
<col style="width: 30.7692%;">
<col style="width: 15.3846%;">
<col style="width: 15.3846%;">
<col style="width: 15.3847%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">子网</th>
<th class="tableblock halign-left valign-top">速记</th>
<th class="tableblock halign-center valign-top" colspan="2">过去标准7层</th>
<th class="tableblock halign-left valign-top">将来标准5层</th>
<th class="tableblock halign-left valign-top">实际应用4层</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle" rowspan="3"><p class="tableblock">资源子网</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FTP、SMTP、POP3(IMAP)、HTTP(s)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7 应用层</p></td>
<td class="tableblock halign-left valign-middle" rowspan="3"><p class="tableblock">5 应用层（报文）</p></td>
<td class="tableblock halign-left valign-middle" rowspan="3"><p class="tableblock">4 应用层</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">试</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据格式转换 / 数据加解密 / 数据解压缩</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6 表示层</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">会</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">建立、维护、释放、管理、控制连接</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5 会话层</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle" rowspan="4"><p class="tableblock">通信子网</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">叔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP/UDP（报文段） 端到端的数据传输服务</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 传输层</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 传输层（报文段）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3 传输层（TCP/UDP）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">网</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在路由器上实现 ICMP、ARP、RARP、IP、IGMP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3 网络层</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3 网络层（数据报）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 网络层</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">链</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">交换机(可以连接多个以太网的网桥)、网桥（封装成帧、差错控制CRC、流量控制ppp协议）&#8594; 一组bit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 数据链路层</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 数据链路层（帧）</p></td>
<td class="tableblock halign-left valign-middle" rowspan="2"><p class="tableblock">1 网络接口层</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">物</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">集线器(模拟信号)、中继器(数字信号)来传输比特流&#8594;单个bit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 物理层</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 物理层（比特）</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>下面是个参考图，注意理解一下概念和三要素:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/osi7layer-2025-05-10-180416.png" alt="OSI" width="840">
</div>
</div>
<div class="sect3">
<h4 id="_10_1_1_example">10.1.1 Example</h4>
<div class="paragraph">
<p>好的，以下是一些关于OSI七层模型和TCP/IP四层模型的真题，适合软件设计师考试的难度：</p>
</div>
<h4 id="_选择题" class="discrete">选择题</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>关于OSI模型和TCP/IP模型的描述，以下正确的是（ ）</strong></p>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p>OSI模型的传输层与TCP/IP模型的传输层功能完全相同。</p>
</li>
<li>
<p>TCP/IP模型的网络接口层包括了OSI模型的数据链路层和物理层的功能。</p>
</li>
<li>
<p>OSI模型的应用层和TCP/IP模型的应用层功能完全相同。</p>
</li>
<li>
<p>TCP/IP模型比OSI模型层次更多。
<strong>答案：B</strong></p>
</li>
</ol>
</div>
</li>
<li>
<p><strong>在OSI模型中，负责将数据分段并提供可靠传输的是（ ）</strong></p>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p>物理层</p>
</li>
<li>
<p>数据链路层</p>
</li>
<li>
<p>网络层</p>
</li>
<li>
<p>传输层
<strong>答案：D</strong></p>
</li>
</ol>
</div>
</li>
<li>
<p><strong>以下协议中，属于TCP/IP模型网络层的是（ ）</strong></p>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p>HTTP</p>
</li>
<li>
<p>TCP</p>
</li>
<li>
<p>IP</p>
</li>
<li>
<p>FTP
<strong>答案：C</strong></p>
</li>
</ol>
</div>
</li>
<li>
<p><strong>在OSI模型中，负责建立、维护和终止会话的是（ ）</strong></p>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p>表示层</p>
</li>
<li>
<p>会话层</p>
</li>
<li>
<p>传输层</p>
</li>
<li>
<p>应用层
<strong>答案：B</strong></p>
</li>
</ol>
</div>
</li>
<li>
<p><strong>以下关于TCP和UDP的描述，正确的是（ ）</strong></p>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p>TCP是无连接的协议，UDP是面向连接的协议。</p>
</li>
<li>
<p>UDP提供可靠传输，TCP提供不可靠传输。</p>
</li>
<li>
<p>TCP适用于对实时性要求较高的场景，UDP适用于对可靠性要求较高的场景。</p>
</li>
<li>
<p>TCP和UDP都工作在TCP/IP模型的传输层。
<strong>答案：D</strong></p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<h4 id="_填空题" class="discrete">填空题</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>在OSI模型中，负责将数据帧传输到物理介质上的是<em>_</em>___层。</strong>
<strong>答案：物理层</strong></p>
</li>
<li>
<p><strong>TCP/IP模型的<em>_</em>___层包括了OSI模型的数据链路层和物理层的功能。</strong>
<strong>答案：网络接口层</strong></p>
</li>
<li>
<p><strong>在TCP/IP模型中，负责数据包路由和转发的是<em>_</em>___层。</strong>
<strong>答案：网络层</strong></p>
</li>
<li>
<p><strong>OSI模型的<em>_</em>___层负责数据的格式化、加密和压缩。</strong>
<strong>答案：表示层</strong></p>
</li>
<li>
<p><strong>TCP/IP模型的<em>_</em>___层提供端到端的通信服务。</strong>
<strong>答案：传输层</strong></p>
</li>
</ol>
</div>
<h4 id="_简答题" class="discrete">简答题</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>简述OSI七层模型中传输层的主要功能，并说明TCP和UDP的区别。</strong>
<strong>答案：</strong></p>
<div class="ulist">
<ul>
<li>
<p><strong>传输层功能</strong>：负责端到端的数据传输服务，包括数据分段、错误检测与纠正、流量控制等。</p>
</li>
<li>
<p><strong>TCP与UDP的区别</strong>：</p>
</li>
<li>
<p>TCP是面向连接的协议，提供可靠传输，适用于对数据完整性要求较高的场景。</p>
</li>
<li>
<p>UDP是无连接的协议，提供不可靠传输，适用于对实时性要求较高的场景。</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>OSI模型和TCP/IP模型的主要区别是什么？</strong>
<strong>答案：</strong></p>
<div class="ulist">
<ul>
<li>
<p>OSI模型是理论模型，层次划分更细（七层），主要用于教学和理论研究。</p>
</li>
<li>
<p>TCP/IP模型是实际应用模型，层次更精简（四层），是现代网络通信的基石。</p>
</li>
<li>
<p>OSI模型的会话层、表示层和应用层在TCP/IP模型中被合并为应用层；OSI模型的数据链路层和物理层在TCP/IP模型中被合并为网络接口层。</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>简述TCP/IP模型中网络接口层的主要功能。</strong>
<strong>答案：</strong></p>
<div class="ulist">
<ul>
<li>
<p>网络接口层负责网络包在物理网络中的传输，包括MAC寻址、错误检测以及通过网卡传输网络帧等。它将IP数据报封装成适合物理网络传输的帧格式，并负责将帧发送到物理介质上。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_10_2_网络层">10.2 网络层</h3>
<div class="sect3">
<h4 id="_10_2_1_ip_数据报分片">10.2.1 IP 数据报分片</h4>
<div class="imageblock">
<div class="content">
<img src="img/ip-data-2025-05-10-193237.png" alt="总体" width="840">
</div>
<div class="title">Figure 12. 总体:</div>
</div>
<div class="imageblock">
<div class="content">
<img src="img/ip-data-2025-05-10-193246.png" alt="细节" width="840">
</div>
<div class="title">Figure 13. 细节:</div>
</div>
<div class="paragraph">
<p><a href="https://www.bilibili.com/video/BV1UM41167sP" class="bare">https://www.bilibili.com/video/BV1UM41167sP</a></p>
</div>
<div class="paragraph">
<p><a href="https://www.bilibili.com/video/BV1Ce411N7Ph" class="bare">https://www.bilibili.com/video/BV1Ce411N7Ph</a></p>
</div>
<div class="sect4">
<h5 id="_10_2_1_1_example1">10.2.1.1 Example1</h5>
<div class="paragraph">
<p>数据报总长度4000B</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/ip-data-2025-05-10-193257.png" alt="例题" width="840">
</div>
<div class="title">Figure 14. 例题</div>
</div>
<div class="paragraph">
<p><a href="https://www.bilibili.com/video/BV1Ce411N7Ph" class="bare">https://www.bilibili.com/video/BV1Ce411N7Ph</a></p>
</div>
</div>
<div class="sect4">
<h5 id="_10_2_1_2_example2">10.2.1.2 Example2</h5>
<h3 id="_ip_数据报分片的描述" class="discrete"><strong>IP 数据报分片的描述</strong></h3>
<div class="paragraph">
<p><strong>题目</strong>：假设一个 IP 数据报总长度为 4000 字节，要经过一段 MTU 为 1500 字节的链路，该 IP 数据报必须经过分片才能通过该链路。以下关于分片的描述中，正确的是（ ）</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A. 该原始 IP 数据报是 IPv6 数据报</p>
</li>
<li>
<p>B. 分片后的数据报将在通过该链路后的路由器进行重组</p>
</li>
<li>
<p>C. 数据报需分为三片，这三片的总长度为 4000 字节</p>
</li>
<li>
<p>D. 分片中的最后一片，标志位 Flag 为 0，Offset 字段为 370</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>答案</strong>：D</p>
</div>
<hr>
<div class="paragraph">
<p><strong>解析</strong>：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A. 选项:</p>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>IPv6 数据报在设计上尽量避免分片。根据 IPv6 的协议规定，源端和目的端之间的链路必须能够支持至少1280字节的MTU（最大传输单元）。如果一个 IPv6 数据报的长度超过了链路的 MTU，那么在 IPv6 中，通常是由源端来处理分片问题，而不是像 IPv4 那样由中间路由器进行分片。而且，题目中提到的 4000 字节的IP数据报需要经过 MTU 为 1500 字节的链路进行分片，这种场景更符合 IPv4 的分片机制。</p>
</li>
<li>
<p>IPv6 更倾向于使用路径MTU发现机制，即在数据报发送之前，通过探测路径上的最小MTU来避免分片。如果发现路径上的MTU小于数据报长度，IPv6会返回一个“分片需要但不允许分片”（Fragmentation Needed but Don&#8217;t Fragment was Set）的ICMPv6错误消息，而不是像IPv4那样直接进行分片。</p>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>B. 选项也是错误的。</p>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>原因分析，在 IP 协议中，无论是 IPv4 还是 IPv6，分片和重组的机制都有明确的规定：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>IPv4分片和重组机制</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>在 IPv4 中，分片是由中间路由器完成的。当一个 IPv4 数据报的长度超过链路的 MTU 时，中间路由器会将其分割成多个较小的分片。</p>
</li>
<li>
<p>重组则是在<strong>最终目的主机</strong>上完成的，而不是在中间路由器上。中间路由器只负责转发分片的数据报，不会对分片进行重组。</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>IPv6 分片和重组机制</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>IPv6 尽量避免中间路由器进行分片。如果需要分片，通常是在<strong>源端</strong>进行分片。</p>
</li>
<li>
<p>重组同样是在<strong>最终目的主机</strong>上完成的。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>因此，无论是 IPv4 还是 IPv6，分片后的数据报都是在<strong>最终目的主机</strong>上进行重组的，而不是在中间路由器上。</p>
</div>
</div>
</div>
</li>
<li>
<p>C. 分包后多了 2 个 20B，所以肯定大于 4000B</p>
</li>
<li>
<p>D. 正确分析</p>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>数据报总长度为 4000 字节，IP首部通常为 20 字节，因此数据部分为 3980 字节。</p>
</li>
<li>
<p>MTU为 1500 字节，减去 IP 首部后，每个分片的数据部分最大为 1480 字节。</p>
</li>
<li>
<p>分片情况如下：</p>
<div class="ulist">
<ul>
<li>
<p>第一片：20字节首部 + 1480字节数据 + 偏移 0</p>
</li>
<li>
<p>第二片：20字节首部 + 1480字节数据 + 偏移 185 （1480/8=185）</p>
</li>
<li>
<p>第三片：20字节首部 + 1020字节数据 + 偏移 370</p>
</li>
</ul>
</div>
</li>
<li>
<p>最后一片的标志位 MF 为 0，表示这是最后一片。</p>
</li>
<li>
<p>偏移量为 370，表示最后一片在原始数据报中的位置。</p>
</li>
</ul>
</div>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_10_2_1_3_example3">10.2.1.3 Example3</h5>
<h3 id="_ip数据报分片计算" class="discrete"><strong>IP数据报分片计算</strong></h3>
<div class="paragraph">
<p><strong>题目</strong>：假设一个IP数据报总长度为 3000 字节，要经过一段 MTU 为 1500 字节的链路，该 IP 数据报必须经过分片才能通过该链路。该原始 IP 数据报需被分成（ ）个片，若 IP 首部没有可选字段，则最后一个片首部中的 Offset 字段为（ ）。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A. 2</p>
</li>
<li>
<p>B. 3</p>
</li>
<li>
<p>C. 4</p>
</li>
<li>
<p>D. 5</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>答案</strong>：B</p>
</div>
<div class="paragraph">
<p><strong>Offset字段选项</strong>：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A. 370</p>
</li>
<li>
<p>B. 740</p>
</li>
<li>
<p>C. 1480</p>
</li>
<li>
<p>D. 2960</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>答案</strong>：A</p>
</div>
<div class="paragraph">
<p><strong>解析</strong>：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>数据报总长度为 3000 字节，IP 首部为 20 字节，数据部分为 2980 字节。</p>
</li>
<li>
<p>每个分片的最大数据部分为 1480 字节（1500 - 20）。1480/8 能除浄</p>
</li>
<li>
<p>分片情况如下：</p>
<div class="ulist">
<ul>
<li>
<p>第一片：20字节首部 + 1480字节数据</p>
</li>
<li>
<p>第二片：20字节首部 + 1480字节数据</p>
</li>
<li>
<p>第三片：20字节首部 + 20字节数据</p>
</li>
</ul>
</div>
</li>
<li>
<p>最后一片的偏移量为 370</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_10_2_1_4_example4">10.2.1.4 Example4</h5>
<h3 id="_ip_数据报分片字段的作用" class="discrete">IP 数据报分片字段的作用</h3>
<div class="paragraph">
<p><strong>题目</strong>：IP 数据报的分段和重装配要用到报文头部的（ ）个字段。其中，分片偏移字段（段偏置值）表示数的单位是（ ）字节；标记字段M标志（MF位）为 0 表示（ ）。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A. 1</p>
</li>
<li>
<p>B. 2</p>
</li>
<li>
<p>C. 3</p>
</li>
<li>
<p>D. 4</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>答案</strong>：D</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A. 4</p>
</li>
<li>
<p>B. 8</p>
</li>
<li>
<p>C. 1</p>
</li>
<li>
<p>D. 13</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>答案</strong>：B</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A. 不能分片</p>
</li>
<li>
<p>B. 允许分片</p>
</li>
<li>
<p>C. 之后还有分片</p>
</li>
<li>
<p>D. 最后一个分片</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>答案</strong>：D</p>
</div>
<div class="paragraph">
<p><strong>解析</strong>：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>分片需要使用 总长度、标识符、标志字段（MF位）、分片偏移字段共 4 个字段。具体解释参下面详解。</p>
</li>
<li>
<p>分片偏移字段的单位是 8 字节。</p>
</li>
<li>
<p>MF 位为 0 表示这是最后一个分片。</p>
</li>
</ul>
</div>
<hr>
<div class="paragraph">
<p>IP 数据报的分段与重装配涉及以下 ‌4 个关键字段‌：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>总长度（Total Length）‌，16 位字段，表示数据报首部与数据部分的总长度（单位为字节），用于分片后重组数据报‌。</p>
</li>
<li>
<p>标识符（Identification）‌，16 位字段，唯一标识同一数据报的所有分片，确保重装时归属正确‌。</p>
</li>
<li>
<p>标记字段（Flags）‌，3 位字段，包含：</p>
<div class="ulist">
<ul>
<li>
<p>MF（More Fragments）位‌：值为 0 时表示当前分片是最后一个分片，为 1 时表示后续还有分片‌。</p>
</li>
<li>
<p>DF（Don’t Fragment）位‌：控制是否允许分片（值为 1 表示禁止分片）‌。</p>
</li>
</ul>
</div>
</li>
<li>
<p>分片偏移(Fragment Offset)，13 位字段，指示分片在原数据报中的相对位置，单位是 ‌8 字节‌（例如偏移值 1 对应实际位置 8 字节）‌。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>总结‌: 题目中“报文头部的字段数”明确为 ‌4 个‌（标识符、总长度、分片偏移、标记字段）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_10_2_2_ip_地址分类">10.2.2 IP 地址分类</h4>
<div class="imageblock">
<div class="content">
<img src="img/ip-type-2025-05-10-193726.png" alt="ip地址分类" width="720">
</div>
</div>
<div class="paragraph">
<p>A类:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>0.0.0.0 不能用（特殊IP）</p>
</li>
<li>
<p>0.255.255.255 不能用（特殊IP）</p>
</li>
<li>
<p>128-2 就剩下 126 个了</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>B类:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>注意网络号是从 128.1 开始的</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_10_2_3_ip_地址特殊情况">10.2.3 IP 地址特殊情况</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NetID 网络号</th>
<th class="tableblock halign-left valign-top">HostID 主机号</th>
<th class="tableblock halign-left valign-top">作为源地址发送</th>
<th class="tableblock halign-left valign-top">作为目的地址接收</th>
<th class="tableblock halign-left valign-top">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">全 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="olist arabic">
<ol class="arabic">
<li>
<p>在本网络内，表示本机</p>
<div class="ulist">
<ul>
<li>
<p>如尚未分配IP的设备，比如DHCP请求时<br></p>
</li>
<li>
<p>webserver 启动时配置为 0.0.0.0 表示本机</p>
</li>
</ul>
</div>
</li>
<li>
<p>在路由表中表示默认路由，意思是“所有未匹配的流量都应该走这个路由”</p>
</li>
</ol>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">全 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">特定值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本网某个特定主机。如 0.0.0.5 表示“当前网络中的主机 5”  (<mark>现代网络不用了</mark>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">全 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本网广播地址 255.255.255.255</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">特定值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">网络地址，表示一个网络</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">特定值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对特定网络所有主机广播地址</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">127</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何非全 0/1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本地回环测试，回环地址</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_10_2_4_子网掩码计算子网号">10.2.4 子网掩码计算子网号</h4>
<div class="paragraph">
<p>目标 IP 地址与子网掩码进行按位与(&amp;)操作，得到子网地址</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/ip-subnet-2025-05-10-201820.png" alt="ip-subnet-mask" width="1080">
</div>
</div>
<div class="sect4">
<h5 id="_10_2_4_1_子网数计算_1">10.2.4.1 子网数计算 1</h5>
<div class="paragraph">
<p>A类网络是很大的网络，每个A类网络中可以有（\(2^{24}\)）个网络地址。
实际使用中必须把A类网络划分为子网，如果指定的子网掩码为255.255.192.0，则该网络被划分为（1024）个子网。</p>
</div>
<div class="paragraph">
<p>解答:</p>
</div>
<div class="paragraph">
<p>一、A类网络能有多少个网络地址？</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>IP地址分类背景</p>
<div class="ulist">
<ul>
<li>
<p>A 类地址范围是：<code>0.0.0.0</code> 到 <code>126.255.255.255</code></p>
</li>
<li>
<p>默认子网掩码是：<code>255.0.0.0</code>，即网络部分是 <strong>前8位</strong>，剩下的 <strong>24位用于主机地址</strong>。</p>
</li>
<li>
<p>所以每个A类网络的格式是：<code>网络号.主机号.主机号.主机号</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>一个A类网络中的地址数：</p>
<div class="ulist">
<ul>
<li>
<p>有24位可用于主机号 → 共有 \(2^{24}\) 个地址</p>
</li>
<li>
<p>其中通常有两个地址是保留的（网络地址和广播地址），但这道题问的是“<strong>可以有多少个网络地址</strong>”，实际指的是<strong>地址空间的数量</strong>。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>二、如果子网掩码为255.255.192.0，该A类网络被划分为多少个子网？</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>255.255.192.0 转换为二进制：</p>
<div class="ulist">
<ul>
<li>
<p>即：<code>11111111.11111111.11000000.00000000</code></p>
</li>
<li>
<p>这是 <strong>前18位是网络位</strong>（8 位原始 + 新增 10 位子网位）</p>
</li>
</ul>
</div>
</li>
<li>
<p>子网位数：</p>
<div class="ulist">
<ul>
<li>
<p>A类默认是 8 位网络号</p>
</li>
<li>
<p>现在掩码变成了 18 位网络位 → 多出了 <strong>10位用于划分子网</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>子网数计算：</p>
<div class="ulist">
<ul>
<li>
<p>有10位子网位 → 子网数 = \(2^{10} = 1024\)</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>总结：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A类网络地址数: 24位主机位 → \(2^{24}\) 个主机地址</p>
</li>
<li>
<p>子网掩码变化: 从8位网络位扩展到18位 → 有10位可用作子网划分</p>
</li>
<li>
<p>可划分子网数: \(2^{10} = 1024\) 个子网</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_10_2_4_2_子网数计算_2">10.2.4.2 子网数计算 2</h5>
<div class="paragraph">
<p>分配给某校园网的地址块是202.105.192.0/19，该校园网包含（D）个C类网络。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 8
B 16
C 30
D 32</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>分配给校园网的地址块是202.105.192.0/19。C类网络的默认子网掩码是/24。
两者的前缀差为24-19=5位，因此该地址块可划分的C类网络数量为\(2^5 = 32\)。</p>
</div>
<div class="paragraph">
<p><strong>验证过程：</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>CIDR前缀差计算</strong>：/19与/24相差5位，每个C类网络需要5位扩展，故子网数量为\(2^5=32\)。</p>
</li>
<li>
<p><strong>地址范围分析</strong>：第三个字节的前3位固定（对应192的二进制`11000000`），后5位允许变化（范围192到223），共32个值，对应32个/24网络。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>答案：D 32</strong></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_10_2_5_ipv6_协议">10.2.5 IPv6 协议</h4>
<div class="imageblock">
<div class="content">
<img src="img/ip-v6-2025-05-10-202903.png" alt="ipv6" width="1024">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_10_2_6_rip_协议">10.2.6 RIP 协议</h4>
<div class="paragraph">
<p>RIP（Routing Information Protocol，路由信息协议）是一种内部网关协议（IGP），用于在小型或中等规模的自治系统（AS）内部的路由器之间交换路由信息。RIP 是最早被广泛使用的动态路由协议之一。</p>
</div>
<div class="paragraph">
<p>实际上这是应用层协议，走 UDP</p>
</div>
<div class="paragraph">
<p>RIP 报文最大为 20B * 25 + 4 = 504B</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/rip-2025-05-10-203457.png" alt="rip1" width="1024">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="img/rip-2025-05-10-203513.png" alt="rip2" width="1024">
</div>
</div>
<div class="sect4">
<h5 id="_10_2_6_1_example">10.2.6.1 Example</h5>
<div class="imageblock">
<div class="content">
<img src="img/rip-2025-05-10-203533.png" alt="rip-example" width="1024">
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_10_2_7_bgp_协议">10.2.7 BGP 协议</h4>
<div class="paragraph">
<p>实际上这是应用层协议，走 TCP</p>
</div>
<div class="paragraph">
<p><a href="https://www.bilibili.com/video/BV1xe411N7GP" class="bare">https://www.bilibili.com/video/BV1xe411N7GP</a></p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/RIP_OSPF_BGP-2025-05-10-204201.png" alt="bgp" width="1024">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_10_2_8_ip_确定主机范围">10.2.8 IP 确定主机范围</h4>
<div class="paragraph">
<p>IP 地址块 <code>155.32.80.192/26</code> 包含了（C）个主机地址，以下 IP 地址中，不属于这个网络的地址是（D）。</p>
</div>
<div class="paragraph">
<p>主机数量选项：</p>
</div>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p>15</p>
</li>
<li>
<p>32</p>
</li>
<li>
<p>62</p>
</li>
<li>
<p>64</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>待判断的 IP 地址选项：</p>
</div>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p>155.32.80.202</p>
</li>
<li>
<p>155.32.80.195</p>
</li>
<li>
<p>155.32.80.253</p>
</li>
<li>
<p>155.32.80.191</p>
</li>
</ol>
</div>
<hr>
<div class="paragraph">
<p>第一步：确定子网的范围</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IP 地址块：<code>155.32.80.192/26</code></p>
</li>
<li>
<p>子网掩码：<code>/26</code> → <code>255.255.255.192</code> → 最后一个字节为 <code>11000000</code></p>
</li>
<li>
<p>可用地址总数：2^(32 - 26) = 64</p>
</li>
<li>
<p>网络地址：<code>155.32.80.192</code></p>
</li>
<li>
<p>广播地址：<code>155.32.80.255</code></p>
</li>
<li>
<p>可分配主机地址范围：<code>155.32.80.193</code> ～ <code>155.32.80.254</code></p>
</li>
<li>
<p>可用主机地址数：64 - 2 = <code>62</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，正确选项为：<code>C. 62</code></p>
</div>
<hr>
<div class="paragraph">
<p>第二步：判断给出的 IP 地址是否属于该子网</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">选项</th>
<th class="tableblock halign-left valign-top">IP 地址</th>
<th class="tableblock halign-left valign-top">是否属于 155.32.80.192/26？</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">155.32.80.202</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是，介于 193～254 之间</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">155.32.80.195</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是，介于 193～254 之间</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">155.32.80.253</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是，介于 193～254 之间</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">155.32.80.191</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">否，它属于前一子网（155.32.80.128/26）</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>因此，不属于该子网的 IP 是：<code>D. 155.32.80.191</code></p>
</div>
<hr>
<div class="paragraph">
<p>最终答案：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>主机数量正确选项：<code>C. 62</code></p>
</li>
<li>
<p>不属于该网络的地址：<code>D. 155.32.80.191</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_10_2_9_子网掩码">10.2.9 子网掩码</h4>
<div class="paragraph">
<p>一个 C 类网段中划分 5 个子网，每个子网最少使用 20 台主机，应使用的子网掩码是（C）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 255.255.255.128
B 255.255.255.240
C 255.255.255.224
D 255.255.255.192</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>C 类地址前 3 个字节即 24 是网络号，其中需要 5 个子网，至少 3 位；</p>
</div>
<div class="paragraph">
<p>每个子网 20 个主机，至少 5 位。</p>
</div>
<div class="paragraph">
<p>因此子网掩码 255.255.255.11100000 即 255.255.255.224，选C。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_编程语言">11 编程语言</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_11_1_c_语言">11.1 C 语言</h3>
<div class="paragraph">
<p>已知函数 f()、g()）的定义如下所示，调用函数 f 时传递给形参 x 的值是 5。<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p>若 g(a) 采用<strong>引用调用（callbyreference）</strong>方式传递参数，则函数 f 的返回值为（请作答此空）；</p>
</li>
<li>
<p>若 g(a) 采用<strong>值调用（callbyvalue）</strong>的方式传递参数，则函数 f 的返回值（ ）。</p>
</li>
<li>
<p>其中，表达式 “x&gt;&gt;1” 的含义是将 x 的值右移 1 位，相当于 x 除以 2。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">f(int x)</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-kt">int</span><span class="tok-w"> </span><span class="tok-n">a</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">x</span><span class="tok-w"> </span><span class="tok-o">&gt;&gt;</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">;</span>
<span class="tok-n">g</span><span class="tok-p">(</span><span class="tok-n">a</span><span class="tok-p">);</span>
<span class="tok-k">return</span><span class="tok-w"> </span><span class="tok-n">a</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-n">x</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">g(int x)</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-n">x</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">x</span><span class="tok-w"> </span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">x</span><span class="tok-w"> </span><span class="tok-o">+</span><span class="tok-w"> </span><span class="tok-mi">1</span><span class="tok-p">);</span>
<span class="tok-k">return</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>选项:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A 35</p>
</li>
<li>
<p>B 32</p>
</li>
<li>
<p>C 11</p>
</li>
<li>
<p>D 7</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>答案: 第一空为 C; 第二空为 D</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>传值调用：形参取的是实参的值，形参的改变不会导致调用点所传的实参的值发生改变。</p>
</li>
<li>
<p>引用（传址）调用：形参取的是实参的地址，即相当于实参存储单元的地址引用，因此其值的改变同时就改变了实参的值。</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>本题中，a=x&gt;&gt;1，x 值为 5，右移操作相当于除以 2，如果结果出现小数部分，则自动向下取整，所以 a=2；</p>
</li>
<li>
<p>采用传值调用时，由于 g(a) 对数据 x 的运算不会影响原来 x 的值，所以 a + x = 2 + 5 = 7；</p>
</li>
<li>
<p>采用引用调用时，由于 g(a) 对数据 x 的运算会影响原来 x 的值，当执行 g(a) 后 x 的值为 6，所以 a + x = 6 + 5 = 11 。</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_12_软件测试">12 软件测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对以下的程序伪代码（用缩进表示程序块）进行路径覆盖测试，至少需要（4）个测试用例。
采用McCabe度量法计算其环路复杂度为（4）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="python"><span></span><span class="tok-n">输入</span> <span class="tok-n">x</span><span class="tok-p">,</span> <span class="tok-n">y</span><span class="tok-p">,</span> <span class="tok-n">z</span>
<span class="tok-n">语句</span> <span class="tok-mi">1</span>
<span class="tok-k">if</span> <span class="tok-n">x</span> <span class="tok-o">&gt;</span> <span class="tok-mi">0</span><span class="tok-p">:</span>
    <span class="tok-n">语句</span> <span class="tok-mi">2</span>
    <span class="tok-k">if</span> <span class="tok-n">y</span> <span class="tok-o">&gt;</span> <span class="tok-mi">0</span><span class="tok-p">:</span>
        <span class="tok-n">语句</span> <span class="tok-mi">3</span>
    <span class="tok-k">else</span><span class="tok-p">:</span>
        <span class="tok-n">语句</span> <span class="tok-mi">4</span>
<span class="tok-k">else</span><span class="tok-p">:</span>
    <span class="tok-n">语句</span> <span class="tok-mi">5</span>
    <span class="tok-k">if</span> <span class="tok-n">z</span> <span class="tok-o">&gt;</span> <span class="tok-mi">0</span><span class="tok-p">:</span>
        <span class="tok-n">语句</span> <span class="tok-mi">6</span>
    <span class="tok-k">else</span><span class="tok-p">:</span>
        <span class="tok-n">语句</span> <span class="tok-mi">7</span>
<span class="tok-n">输出语句</span></code></pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>本题考查软件测试的相关知识，要求考生能够熟练掌握典型的白盒测试方法。路径覆盖就是设计若干个测试用例，运行被测程序，使得程序中每条路径至少运行一次。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-test-2025-05-11-125828.svg" alt="diagram test 2025 05 11 125828" width="310" height="481">
</div>
<div class="title">Figure 15. 画出上述伪代码的流程图如下：</div>
</div>
<div class="paragraph">
<p>从图中很容易看出有四条路径：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>x &gt; 0 且 y &gt; 0（执行语句 1→2→3）</p>
</li>
<li>
<p>x &gt; 0 且 y ≤ 0（执行语句 1→2→4）</p>
</li>
<li>
<p>x ≤ 0 且 z &gt; 0（执行语句 1→5→6）</p>
</li>
<li>
<p>x ≤ 0 且 z ≤ 0（执行语句 1→5→7）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此设计 4 个测试用例分别运行上述四个路径即可满足路径覆盖。</p>
</div>
<hr>
<div class="paragraph">
<p><strong>数判定节点（推荐！）</strong></p>
</div>
<div class="paragraph">
<p>公式：V(G)=判定节点数+1</p>
</div>
<div class="paragraph">
<p>步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在代码中数出所有的 if、else if、while、for、case 等分支语句。</p>
</li>
<li>
<p>每个分支语句算 1个判定节点。</p>
<div class="ulist">
<ul>
<li>
<p>判定节点数 = 3（x&gt;0、y&gt;0、z&gt;0）</p>
</li>
</ul>
</div>
</li>
<li>
<p>最后 +1 就是环路复杂度</p>
<div class="ulist">
<ul>
<li>
<p>V(G) = 3 + 1 = 4</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_12_1_example_mccabe度量法计算其环路复杂度">12.1 Example McCabe度量法计算其环路复杂度</h3>
<div class="paragraph">
<p>采用McCabe度量法计算下图的环路复杂度为（C）。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 2
B 3
C 4
D 5</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-2025-05-13-155805.svg" alt="diagram 2025 05 13 155805" width="184" height="448">
</div>
</div>
<div class="paragraph">
<p><strong>数判定节点（推荐！）</strong></p>
</div>
<div class="paragraph">
<p>公式：V(G) = 判定节点数 + 1</p>
</div>
<div class="paragraph">
<p>步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在代码中数出所有的 if、else if、while、for、case 等分支语句。</p>
</li>
<li>
<p>每个分支语句算 1个判定节点。</p>
<div class="ulist">
<ul>
<li>
<p>判定节点数 = 3（while、i&gt;0、n==0）</p>
</li>
</ul>
</div>
</li>
<li>
<p>最后 +1 就是环路复杂度</p>
<div class="ulist">
<ul>
<li>
<p>V(G) = 3 + 1 = 4</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
该题有个 while 循环，容易被忽略！
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_12_2_等价类划分测">12.2 等价类划分测</h3>
<div class="paragraph">
<p>在某班级管理系统中，班级的班委有班长、副班长、学习委员和生活委员，且学生年龄在15\~25岁。若用等价类划分来进行相关测试，则（ ）不是好的测试用例。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A (队长，15)
B (班长，20)
C (班长，15)
D (队长，12)</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>等价类划分测试题解析</p>
</div>
<div class="paragraph">
<p>本题考查的是 <strong>等价类划分测试方法</strong>，该方法用于将输入条件分为有效和无效的等价类，以设计具有代表性的测试用例，从而提高测试效率。</p>
</div>
<div class="paragraph">
<p>题设信息分析</p>
</div>
<div class="ulist">
<ul>
<li>
<p>班委职位限定为：<code>班长</code>、<code>副班长</code>、<code>学习委员</code>、<code>生活委员</code></p>
<div class="ulist">
<ul>
<li>
<p>→ 合法职位等价类为上述四个</p>
</li>
<li>
<p>→ 其他职位（如`队长`）属于无效等价类</p>
</li>
</ul>
</div>
</li>
<li>
<p>学生年龄限定为：`15~25`岁（含边界）</p>
<div class="ulist">
<ul>
<li>
<p>→ 有效等价类：15 ≤ 年龄 ≤ 25</p>
</li>
<li>
<p>→ 无效等价类：年龄 &lt; 15 或 年龄 &gt; 25</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. 选项逐一分析</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">选项</th>
<th class="tableblock halign-left valign-top">分析</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A. <code>(队长, 15)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">职位为无效等价类，年龄为有效边界值 → 组合合理，用于测试非法职位
<em>→ 是一个有效的测试用例</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">B. <code>(班长, 20)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">职位与年龄均为有效等价类，属于正常输入
<em>→ 是一个有效的测试用例</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C. <code>(班长, 15)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">职位有效，年龄处于边界值（15）
<em>→ 是一个边界值测试用例，合理有效</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">D. <code>(队长, 12)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">职位和年龄均为无效等价类，无法判断失败原因
<em>→ <strong>不是一个好的测试用例</strong></em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>正确答案：</strong> <code>D</code>
因为选项 D 同时落在两个无效等价类中，不利于定位具体的错误来源，因此不是一个好的测试用例。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_13_设计模式">13 设计模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>（A）设计模式将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 命令（Command）
B 责任链（Chain of Responsibility）
C 观察者（Observer）
D 策略（Strategy）</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>本题考查设计模式的基本概念。每种设计模式都有特定的意图，描述一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心，使该方案能够重用而不必做重复劳动。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>命令(Command)将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p>
</li>
<li>
<p>责任链(Chain of Responsibility)使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
</li>
<li>
<p>观察者(Observer)模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</li>
<li>
<p>策略(Strategy)定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化。</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_13_1_软件过程模型">13.1 软件过程模型</h3>
<div class="paragraph">
<p>在开发一个字处理软件时，首先快速发布了一个提供基本文件管理、编辑和文档生成功能的版本，接着发布提供更完善的编辑和文档生成功能的版本，最后发布提供拼写和语法检查功能的版本，这里采用了____过程模型。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 瀑布
B 快速原型
C 增量
D 螺旋</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>本题考查软件过程模型的基础知识。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>瀑布模型从一种非常高层的角度描述了软件开发过程中进行的活动，并且提出了要求开发人员经过的事件序列。</p>
</li>
<li>
<p>原型模型允许开发人员快速地构造整个系统或系统的一部分以理解或澄清问题。</p>
</li>
<li>
<p>增量开发是把软件产品作为一系列的增量构件来设计、编码、集成和测试，系统功能在增量中不断完善或者增加。</p>
</li>
<li>
<p>螺旋模型把开发活动和风险管理结合起来，以将风险减到最小并控制风险。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_14_uml_图">14 UML 图</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_14_1_类图符号">14.1 类图符号</h3>
<div class="paragraph">
<p>符号	含义	示例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>实心菱形	组合（Composition）	房子包含房间</p>
</li>
<li>
<p>空心菱形	聚合（Aggregation）	班级聚合学生</p>
</li>
<li>
<p>空心三角形箭头	泛化（继承）	猫继承自动物</p>
</li>
<li>
<p>普通箭头/连线	关联	员工参与项目</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_14_2_活动图">14.2 活动图</h3>
<div class="paragraph">
<p>某软件项目的活动图如下图所示，其中顶点表示项目里程碑，连接顶点的边表示活动，边上的数字表示该活动所需的天数，则完成该项目的最少时间为（ ）天。活动BD最多可以晚（ ）天开始而不会影响整个项目的进度。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz_critical-path-2025-05-11-104921.svg" alt="graphviz critical path 2025 05 11 104921" width="909" height="214">
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>A 9
B 15
C 22
D 24</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>解析:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>根据上图计算出关键路径为 A-B-C-E-F-I-K-L，其长度为 24，关键路径上的活动均为关键活动。</p>
</li>
<li>
<p>活动BD不在关键路径上，包含该活动的最长路径为 A-B-D-G-I-K-L，其长度为 22，因此松弛时间为 2。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_14_2_1_复杂的例子">14.2.1 复杂的例子</h4>
<div class="paragraph">
<p>某工程的进度计划网络图如下，其中包含了 10 个节点，节点之间的箭线表示作业及其进度方向，箭线旁标注了作业所需的时间（单位：周）。设起始节点 A 的时间为0，则节点 E 的最早时间和最迟时间分别为（D）周。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 9,19
B 9,18
C 15,17
D 15,16</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="img/graphviz_critical-path-2025-05-14-132756.svg" alt="graphviz critical path 2025 05 14 132756" width="688" height="353">
</div>
<div class="title">Figure 16. 如图所示</div>
</div>
<div class="paragraph">
<p>分析：关键路线是 ACDFGIJ，共 28 周。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>节点 E 的最早时间：找前面最长的路径为 <strong>ACDE=15</strong> (因为 E 要等最长的路径完成才能开始)</p>
</li>
<li>
<p>节点 E 的最迟时间：E 后面最长的路径为 <strong>EGIJ=12</strong>，所以 E 要在第 12 周之前开始。</p>
<div class="ulist">
<ul>
<li>
<p>总共是 28 周，所以 E 最晚要在第 <strong>28 - 12 = 16</strong> 周开始。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以答案是：D</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_14_3_用例图">14.3 用例图</h3>
<div class="paragraph">
<p>现有两个用例 UC1 和 UC2，其中 UC2 是一个完整的用例，可被实例化，而 UC1 需要 UC2 中的事件流才可被实例化，且 UC1 指定了使用 UC2 的精确位置，则 UC1 和 UC2 间的关系是"（A）" 。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A include
B extend
C generalize
D call</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>分析：根据题干表述 U1 需要 U2 才能完整执行，两者属于包含关系。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>UC2 是完整用例，可独立实例化（即 UC2 能单独执行）。</p>
</li>
<li>
<p>UC1 需要 UC2 的事件流才能实例化（即 UC1 依赖 UC2）。</p>
</li>
<li>
<p>UC1 指定了使用 UC2 的精确位置（即 UC1 主动调用 UC2）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>UML 用例图的标准关系只有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>include（包含）</p>
</li>
<li>
<p>extend（扩展）</p>
</li>
<li>
<p>generalization（泛化/继承）</p>
</li>
<li>
<p>association（关联，通常用于参与者和用例之间）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>没有 call 这个标准关系，所以选项 D 是干扰项。</p>
</div>
</div>
<div class="sect2">
<h3 id="_14_4_uml面向对象建模">14.4 UML面向对象建模</h3>
<div class="paragraph">
<p>在某销售系统中，客户采用扫描二维码进行支付。若采用面向对象方法开发该销售系统，则客户类属于（B）类， 二维码类属于（A）类。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A 接口
B 实体
C 控制
D 状态</pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>解析：</p>
</div>
<div class="paragraph">
<p>类可以分为三种：实体类、接口类（边界类）和控制类。</p>
</div>
<div class="paragraph">
<p>实体类的对象表示现实世界中真实的实体，如人、物等。</p>
</div>
<div class="paragraph">
<p>接口类（边界类）的对象为用户提供一种与系统合作交互的方式，分为人和系统两大类，其中人的接口可以是显示屏、窗口、Web窗体、对话框、菜单、列表框、其他显示控制、条形码、二维码或者用户与系统交互的其他方法。系统接口涉及到把数据发送到其他系统，或者从其他系统接收数据。</p>
</div>
<div class="paragraph">
<p>控制类的对象用来控制活动流，充当协调者。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_信息安全">15 信息安全</h2>
<div class="sectionbody">
<div class="paragraph">
<p>集合 \(\mathbb{Z}_{26}\) 表示的是从 0 到 25 的整数集合：
\(\mathbb{Z}_{26} = \{0, 1, 2, \dots, 25\}\)</p>
</div>
<div class="paragraph">
<p>加密函数定义如下：
\(E_k(i) = (k \cdot i) \bmod 26\)</p>
</div>
<div class="paragraph">
<p>现在给定密钥 \(k = 7\)，加密函数为：
\(E_7(i) = (7 \cdot i) \bmod 26\)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
把 i 乘以 7，然后对 26 取余，结果还是一个 0 到 25 之间的数。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>问：这个加密函数属于以下哪种函数类型？ <strong>答案为 D</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>A. 单射但非满射</p>
</li>
<li>
<p>B. 满射但非单射</p>
</li>
<li>
<p>C. 非单射且非满射</p>
</li>
<li>
<p>D. 双射（既是单射也是满射）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>术语解释</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>单射</strong>：不同的输入不会被映射成相同的输出，即 \(E(i) = E(j) \Rightarrow i = j\)。</p>
</li>
<li>
<p><strong>满射</strong>：输出值可以覆盖到所有 \(\mathbb{Z}_{26}\) 中的值。</p>
</li>
<li>
<p><strong>双射</strong>：既是单射又是满射，一一对应且全覆盖。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>正确答案：<strong>D. 双射</strong></p>
</div>
<hr>
<div class="paragraph">
<p>怎么判断是否是双射？</p>
</div>
<div class="paragraph">
<p>有个简单的数学规则：只要 7 和 26 没有公因数（除了1），这个函数就是双射。</p>
</div>
<div class="paragraph">
<p>我们检查一下：gcd(7,26)=1</p>
</div>
<div class="paragraph">
<p>说明：7 和 26 没有共同因数（比如 2、3、13 这些），所以它们是 <strong>互质</strong> 的。</p>
</div>
<div class="paragraph">
<p>结论：这个加密函数是 双射，也就是说它：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不会把两个不同的数字加密成同一个结果（单射）</p>
</li>
<li>
<p>所有可能的加密结果（0 到 25）都能被产生出来（满射）</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_16_专业英语">16 专业英语</h2>
<div class="sectionbody">

</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-05-24 00:24:30 +0800
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>