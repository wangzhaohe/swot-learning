:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3

= 软件设计师例题精讲

++++
<button id="toggleButton">Table of Contents</button>
<script>
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () => {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
</script>
++++

== 数据表示


=== 校验码（在OSI的数据链路层）


==== 奇偶校验
奇校验：原始数据增加一个校验位，使 1 的个数为奇数。

    原始数据    校验位
    10010100    0   -> 1 的个数为奇数，所以校验位为 0

偶校验：原始数据增加一个校验位，使 1 的个数为偶数。

    原始数据    校验位
    10010100    1   -> 1 的个数为奇数，所以校验位为 1


* 奇偶校验只有在出错二进制位个数是 #奇数# 的情况下才有效。
* 奇偶校验只能检错，不能纠错。


码字：编码后的信息单元，由若干个二进制位组成。

距离：将两个码字逐位进行对比，具有不相同的位的个数称为两个码字间的距离。

  ** 1011101 和 1001001 之间的距离是 2。

    1011101
    1001001
      x x   -> 2 位不同

  ** 奇偶校验的码距为 2
     *** 以奇校验为例：如下面完整码字的任意两个奇数个 1 的码字之间，至少要改两个比特才能从一个合法码字变成另一个合法码字。所以码距是 2。
+
[caption=]
.举例说明奇校验码距为 2
[cols="1,1,1",options="header"]
|===
| 数据位 | 校验位（奇校验） | 完整码字 
| 000   | 1             | 0001 
| 001   | 0             | 0010 
| 010   | 0             | 0100 
| 011   | 1             | 0111 
| 100   | 0             | 1000 
| 101   | 1             | 1011 
| 110   | 1             | 1101 
| 111   | 0             | 1110 
|===

码距：一种编码方案可能有若干个合法码字，各合法码字间的 #最小距离# 称为“码距”。

计算（偶校验为例）：各信息位进行异或（模2加）运算，得到的结果即为「偶校验位」。

  * 如 1001101 异或结果为 0，所以偶校验位为 0。
  * 则最后发送的数据为 10011010（假设将校验位放在最后面）

验证（偶校验为例）：收到方验证数据

  * 将收到的数据 10011010 按位异或结果为 0，说明数据正确。

https://www.bilibili.com/video/BV1qp421D7B3  0:00 -> 02:44

==== 循环冗余校验码‌（CRC校验）
给定待发送的数据为: 101001

要求的校验码多项式为: stem:[G(x) = x^3 + x^2 + 1]

***

1. 根据多项式确定 CRC 校验码位数
  ** 因为多项式最高次幂为 3，所以校验码位数为 3。

2. 数据左移校验码位数
  ** 数据补 3 个 0 为: 101001000

3. 确定多项式的值
  ** 根据多项式确定
  stem:[G(x) = x^3 + x^2 + 1] ->
  stem:[1 \cdot x^3 + 1 \cdot x^2 + 0 \cdot x^1 + 1 \cdot x^0]
  -> 1101

4. 计算 CRC 值（除法异或运算）
+
  1010 01000 ÷ 1101
  1101        (生成多项式)
  ----
  01110 1000  (第一步 XOR 结果)
   1101
   ----
   001110 00  (第二步 XOR 结果)
     1101
     -----
     001100   (第三步 XOR 结果)
       1101
       ----
       0001   (CRC 余数为 1，则 3 位校验位为 001)

5. 生成发送数据 = 传输数据 + CRC校验码
  ** 101001+001 -> 101001001

---
https://www.bilibili.com/video/BV1qp421D7B3

  * 从低到高举例 12:27 -> end

==== 海明码
* 可检错和纠错，海明码的标准码距是 3

* 可发现 2 位错，纠正 1 位错

* 用到了奇偶校验中的偶校验。

* ##计算 k 位数公式：stem:[2^k \geq n + k + 1]##
  ** n 为信息码长度
  ** k 为校验码长度（需要通过上面公式，自己代出来即可）
  ** ##校验码位置：stem:[2^{i-1}] ( i 从 1 -> k，如1、2、4、8 )##

* ##异或校验整个海明码，都为 0 正确。##

---

视频教学

* https://www.youtube.com/watch?v=5it44QcOtQQ 从高到低举例
* https://www.bilibili.com/video/BV1qp421D7B3 从低到高举例 02:44 -> 12:27

===== Example1 计算海明码
例如: 信息码 101101100，采用海明码校验，问最终海明码是多少?

1. 确定校验位数量 k，原信息码位数为 n=9，代入公式:
  * stem:[2^k \geq n+k+1]，得 stem:[2^k \geq 9+k+1]
  * 若 k=4，则 stem:[2^4 \geq 9+4+1]，即 16>14，满足公式。
  * 确定校验位数量为 4 位

2. 确定校验码位置: 代入公式 stem:[2^{i-1}] ( i 从 1-> k=4，得 1、2、4、8 )，即下面 k1、k2、k4、k8 的 4 个位置。
+
[plantuml, target=img/diagram-haimingcode1, format=png]
....
@startebnf
<style>
element {
  ebnf {
    Backgroundcolor pink
    note {
      Backgroundcolor pink
    }
  }
}
</style>

校验位位置=k1(*1*),k2(*2*),"1"(*3*),k4(*4*),"0"(*5*),"1"(*6*),"1"(*7*),
k8(*8*),"0"(*9*),"1"(*10*),"1"(*11*),"0"(*12*),"0"(*13*);

@endebnf
....

3. 确定校验位与数据位对应关系
  * 即 kx 分别对应哪些数据位
+
[caption=]
[cols="6*"]
|===
2.2+^.^|校验位对应数据位表 (为1则对应)                          4+^|4个校验位
                         |k8 (9,10,11,12,13) |k4 (5,6,7,12,13) |k2 (3,6,7,10,11) |k1 (3,5,7,9,11,13)
.9+^.^|9个数据位对应校验位关系
        | 3 -> 0011 -> k1, k2     |0                  |0               |1                 |1
        | 5 -> 0101 -> k1, k4     |0                  |1               |0                 |1
        | 6 -> 0110 -> k2, k4     |0                  |1               |1                 |0
        | 7 -> 0111 -> k1, k2, k4 |0                  |1               |1                 |1
        | 9 -> 1001 -> k1, k8     |1                  |0               |0                 |1
        |10 -> 1010 -> k2, k8     |1                  |0               |1                 |0
        |11 -> 1011 -> k1, k2, k8 |1                  |0               |1                 |1
        |12 -> 1100 -> k4, k8     |1                  |1               |0                 |0
        |13 -> 1101 -> k1, k4, k8 |1                  |1               |0                 |1
|===

4. 计算校验位的值
  * 异或结果为 kx 的值
+
[caption=]
[cols="8*"]
|===
| k1 对应位   |3 | 5 | 7 | 9  | 11 | 13    | 异或结果为 k1
| 信息码对应值 |1 | 0 | 1 | 0  | 1  | 0  ^.^| 1
| k2 对应位   |3 | 6 | 7 | 10 | 11 |       | 异或结果为 k2
| 信息码对应值 |1 | 1 | 1 | 1  | 1  |    ^.^| 1
| k3 对应位   |5 | 6 | 7 | 12 | 13 |       | 异或结果为 k3
| 信息码对应值 |0 | 1 | 1 | 0  | 0  |    ^.^| 0
| k4 对应位   |9 | 10| 11| 12 | 13 |       | 异或结果为 k4
| 信息码对应值 |0 | 1 | 1 | 0  | 0  |    ^.^| 0
|===

5. 插入校验位 k1 k2 k4 k8
+
[plantuml, target=img/diagram-haimingcode2, format=png]
....
@startebnf
<style>
element {
  ebnf {
    Backgroundcolor pink
    note {
      Backgroundcolor pink
    }
  }
}
</style>

插入校验位 = k1(*1*), k2(*2*),"1"(*3*),k4(*4*), "0"(*5*),"1"(*6*),"1"(*7*),k8(*8*), "0"(*9*),"1"(*10*),"1"(*11*),"0"(*12*),"0"(*13*)
           |1(*1*),  1(*2*),"1"(*3*), 0(*4*), "0"(*5*),"1"(*6*),"1"(*7*), 0(*8*), "0"(*9*),"1"(*10*),"1"(*11*),"0"(*12*),"0"(*13*);
(* 海明码为: 1110011001100 *)
@endebnf
....

6. 接收方检错和纠错判断
  * 接收方接收正确数据时: 1110011001100，按《4. 计算校验位的值》中的表进行异或（含 kx 值），都为 0 为正确。
  * 接收方接收错误数据时: 1110111001100，按《4. 计算校验位的值》中的表进行异或（含 kx 值），若有 1 为错误。
    ** 此例为数值位 5 由 0 变成了 1
    ** 如何知道是数据位 5 发生了变化？ -> #将异或结果由 k8 k4 k2 k1 排序为 0 1 0 1，即是十进制的位置 5。#

+
[caption=]
[cols="8*", stripes=odd]
|===
| k1 | 3      | 5       | 7 | 9  | 11 | 13 | 异或结果
| 1  | 1      | 0 -> 1  | 1 | 0  | 1  | 0  | 1 错
| k2 | 3      | 6       | 7 | 10 | 11 |    | 异或结果
| 1  | 1      | 1       | 1 | 1  | 1  |    | 0
| k4 | 5      | 6       | 7 | 12 | 13 |    | 异或结果
| 0  | 0 -> 1 | 1       | 1 | 0  | 0  |    | 1 错
| k8 | 9      | 10      | 11| 12 | 13 |    | 异或结果
| 0  | 0      | 1       | 1 | 0  | 0  |    | 0
|===

== 数据结构


=== 二叉树小根堆
对于 n 个元素的关键字序列 { k1,k2, ...kn }，当且仅当满足关系 ki ≤ k2i 且 ki ≤ k2i+1 {i=1.2...[n/2]} 时称其为小根堆(小顶堆)。

以下序列中，（ ）不是小根堆(小顶堆)。

    A 16,25,40,55,30,50,45
    B 16,40,25,50,45,30,55
    C 16,25,39,41,45,43,50
    D 16,40,25,53,39,55,45

***

这是根据完全二叉树在数组中的存储方式来判断的。小根堆是一种完全二叉树结构的堆，在顺序存储时具有以下规律：

.link:img/mermaid-2025-05-09-174131.svg[D 16,40,25,53,39,55,45]
[mermaid, target=img/mermaid-2025-05-09-174131, format=svg]
....
flowchart TD
    16((16)) --- 40((40))
    40((40)) --- 53((53))
    40((40)) ---|违反小根堆性质| 39((39))

    16((16)) --- 25((25))
    25((25)) --- 55((55))
    25((25)) --- 45((45))
....

*答案为 D*

=== 二叉树遍历顺序
已知一棵二叉树的先序遍历结果为 ABCDEF，中序遍历结果为 CBAEDF，则后序遍历结果为（ ）。

    A CBEFDA
    B FEDCBA
    C CBEDFA
    D 不确定

***

我们根据 **先序遍历** 和 **中序遍历** 来还原这棵二叉树，再求出它的 **后序遍历**。

.遍历就是访问树中所有节点的一种方式
****
1. **先序遍历（Preorder）**: 访问顺序：**根 → 左子树 → 右子树**

2. **中序遍历（Inorder）**: 访问顺序：**左子树 → 根 → 右子树**

3. **后序遍历（Postorder）**: 访问顺序：**左子树 → 右子树 → 根**
****

给定：

- 先序遍历（Preorder）：`A B C D E F`
- 中序遍历（Inorder）： `C B A E D F`

[discrete]
=== 步骤一：构建二叉树

先序遍历的第一个节点是根节点：

- **根节点：A**

查找 A 在中序遍历中的位置：

- 中序遍历：`C B | A | E D F`

所以 A 的左子树是 `C B`，右子树是 `E D F`。

[discrete]
==== 处理左子树：

先序遍历中 A 的左子树部分是：`B C`

- 根是 B（先序中紧跟 A 之后）
- 中序左子树为 `C B`，B 是根，C 在左边 ⇒ C 是 B 的左子

左子树构建为：

```
   B
  /
C
```

[discrete]
==== 处理右子树：

先序遍历中 A 的右子树部分是：`D E F`（剩下的）

- 根是 D（下一个未使用的先序元素）
- 中序右子树是 `E D F`

D 在中序中的位置中间，所以：

- 左子树：E
- 右子树：F

右子树构建为：

```
   D
  / \
 E   F
```

[discrete]
==== 整体树结构为：

```
       A
     /   \
    B     D
   /     / \
  C     E   F
```

[discrete]
=== 步骤二：求后序遍历（Postorder）

后序遍历顺序是：**左 → 右 → 根**

按照树结构遍历：

- 左子树（B 的子树）：C → B
  
- 右子树（D 的子树）：E → F → D
  
- 根：A

合起来是：`C B E F D A`

[discrete]
==== 答案：**A. CBEFDA**

***

=== 哈夫曼树(最优二叉树)
若一棵哈夫曼(Huffman)树共有 9 个顶点，则其叶子结点的个数为（ ）。

    A 4
    B 5
    C 6
    D 7

答案为：B

先推个公式出来：

正确的构建流程（4 个叶子结点：A、B、C、D）：

初始结点：A、B、C、D（都是叶子）

第一步：合并权值最小的两个（比如 A 和 B）⇒ 生成中间结点 P

第二步：合并权值最小的两个（比如 C 和 D）⇒ 生成中间结点 Q

第三步：合并 P 和 Q ⇒ 得到根结点 R

树的结构应该是这样的：

        R
       / \
      P   Q
     / \ / \
    A  B C  D

总结点数验证：

- 叶子结点：A、B、C、D ⇒ 4 个

- 中间结点：P、Q、R ⇒ 3 个

- 总结点数：4 + 3 = 7 = 2×4 - 1

所以有公式: ##总结点数 = 叶子结点数 + 内部结点数 = n+(n−1) = 2n−1##

9 个顶点代入公式： 9 = 2n - 1 -> n = 5

=== 无向图顶点度数
无向图中一个顶点的度是指图中与该顶点相邻接的顶点数。若无向图 G 中的顶点数为 n，边数为 e，则所有顶点的度数之和为（ ）

* A n*e 
* B n+e 
* C 2n 
* D 2e

答案：D

****

定义：在无向图中，一个顶点的度数（Degree）是指与该顶点相连的边的数量。度数是描述顶点在图中连接程度的一个重要指标。

这个题考查的是图论中无向图的一个基本性质：

在一个无向图中，所有顶点的度数之和等于边数的两倍。

原因解释：
每条边连接两个顶点，因此会被两个顶点各“贡献一次”度数。所以总的度数是边数的两倍。

设：

* 顶点数为 n
* 边数为 e
* 公式中的 vi 指顶点

则： stem:[\sum_{i=1}^{n} \deg(v_i) = 2e]
****

== 操作系统


=== 进程同步与互斥（PV 操作）


==== 前趋图
前趋图（Precedence Graph）是一种用于表示任务或进程之间执行顺序关系的图形表示方法。它通常用于项目管理、操作系统的进程调度、编译原理中的指令调度等领域，以帮助确定任务或进程的执行顺序和依赖关系。

前趋图的特点：

1. **节点（Vertices）**：图中的每个节点代表一个任务或进程。
2. **有向边（Directed Edges）**：图中的边表示任务或进程之间的依赖关系。如果存在一条从节点 A 指向节点 B 的有向边，那么它表示任务 A 必须在任务 B 之前完成。

前趋图的作用：

- **确定执行顺序**：通过分析前趋图，可以确定哪些任务可以并行执行，哪些任务必须按顺序执行。
- **避免死锁**：在操作系统中，前趋图可以帮助设计避免死锁的资源分配策略。
- **优化调度**：在编译器设计中，前趋图可以帮助优化指令的执行顺序，提高程序的执行效率。

前趋图的示例：

假设有四个任务 A、B、C、D，其中：
- 任务 A 必须在任务 B 和 C 之前完成。
- 任务 B 和 C 必须在任务 D 之前完成。

前趋图可以表示为：

```
  A
  │
  ▼
  B---C
  │    │
  ▼    ▼
    D
```

在这个图中，A 是 B 和 C 的前趋，B 和 C 是 D 的前趋。

在操作系统的进程调度中，前趋图可以帮助操作系统确定进程的执行顺序，确保系统资源的有效利用和进程的正确执行。

==== PV 操作
PV操作是操作系统中用于进程同步与互斥的一种机制，由两部分组成：P操作（Proberen，荷兰语中的“测试”）和V操作（Verhogen，荷兰语中的“增加”）。这种机制通常与信号量（Semaphore）一起使用，信号量是一个整数变量，用于控制对共享资源的访问。

* P操作（等待操作）

    ** P操作用于申请资源。当一个进程需要访问共享资源时，它会执行P操作。如果信号量的值大于0，表示资源可用，信号量减1，进程继续执行。如果信号量的值为0，表示资源不可用，进程将被阻塞，直到信号量的值变为正数。

* V操作（释放操作）

    ** V操作用于释放资源。当一个进程完成对共享资源的访问后，它会执行V操作。这会使信号量的值增加1。如果此时有其他进程因为资源不可用而被阻塞，那么V操作会唤醒其中一个阻塞的进程，使其可以继续执行。

* 信号量的类型

    1. **整型信号量**：信号量的值可以是任意整数，用于表示资源的数量。当信号量的值为0时，表示没有资源可用。
    2. **二进制信号量**：信号量的值只能是0或1，用于实现互斥锁。0表示锁被占用，1表示锁可用。

PV操作广泛应用于操作系统中的进程同步、互斥、死锁避免等领域。例如：

- **进程同步**：确保多个进程按照特定的顺序执行。
- **互斥访问**：确保在任何时刻只有一个进程可以访问共享资源。
- **避免死锁**：通过控制资源的分配和释放，避免系统进入死锁状态。

通过合理使用PV操作，可以有效地管理进程间的协作和资源共享，提高系统的稳定性和效率。

==== Example
进程 P1、P2、P3、P4、P5 的 link:img/graphviz-pv-2025-05-08-193314.png[前趋图] 如下：

[graphviz, target="img/graphviz-pv-2025-05-08-193314", format=png]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape = circle];

    P1 -> P3;
    P2 -> P3;
    P3 -> P4;
    P3 -> P5;
}
....

若用 PV 操作控制进程并发执行的过程，则需要设置 4 个信号量 S1、S2、S3、S4，且信号量初值都等于零。下面 link:img/graphviz-2025-05-08-194149.png[PV图] 中 a 和 b 应分别填写（），c 和 d 应分别填写（），e 和 f 应分别填写（）。

[graphviz, target="img/graphviz-2025-05-08-194149", format=png]
....
digraph PetriNet {
    rankdir=TB;
    node [shape=circle]; P1 P2;
    node [shape=box]; P3 P4 P5 a b c d e f;
    end1 [label="", shape=circle];
    end2 [label="", shape=circle];

    P1 -> a [label="P1执行"];
    P2 -> b [label="P2执行"];
    c  -> P3
    P3 -> d [label="P3执行"];
    e -> P4
    P4 -> end1
    f -> P5
    P5 -> end2
}
....

*答案解析：*

- **a 和 b 处**：当 P1 和 P2 执行完毕后，它们需要通过执行 V 操作来增加信号量 S1 和 S2 的值，从而通知 P3 可以开始执行。因此，a 处应填写 V(S1)，b 处应填写 V(S2)。

- **c 和 d 处**：进程 P3 在开始执行前，需要通过执行 P 操作来检查 S1 和 S2 的值是否大于 0。如果 S1 和 S2 的值都大于 0，表示 P1 和 P2 已经执行完毕，P3 可以开始执行。因此，c 处应填写 P(S1)，d 处应填写 P(S2)。

- **e 和 f 处**：进程 P4 和 P5 在开始执行前，需要通过执行 P 操作来检查 S3 和 S4 的值是否大于 0。如果 S3 和 S4 的值都大于 0，表示 P3 已经执行完毕，P4 和 P5 可以开始执行。因此，e 处应填写 P(S3)，f 处应填写 P(S4)。

== 存储系统与寻址结构


=== 寻址单元数计算
设机器字长为 32 位，一个容量为 16MB 的存储器，CPU 按照半字寻址，其可寻址的单元数是（ ）。

    A 2^24
    B 2^23 正确
    C 2^22
    D 2^21

***

1. ‌明确关键概念‌

* 机器字长‌：32位，即 CPU 一次处理数据的位数为 32bit‌。
* 半字‌：字长的一半，32 位机器的半字为 16位（2字节）‌。
* 存储器容量‌：16MB = 16 × 2²⁰字节 = 2²⁴字节（因1MB = 2²⁰字节）‌。

2. ‌计算总位数‌

存储器容量需转换为位数以便后续计算：

16MB的位数‌ = 16 × 2²⁰字节 × 8位/字节 = 2²⁴ × 8位 = 2²⁷位‌。

3. ‌按半字寻址的单元数‌

* 每个半字大小‌：16位（2字节）‌。
* 总单元数‌ = 存储器总字节数 ÷ 每单元字节数 = 2²⁴字节 ÷ 2字节/单元 = 2²³单元‌。
* （或等价计算：总位数 ÷ 半字位数 = 2²⁷位 ÷ 16位/单元 = 2²³单元）

4. ‌验证与选项对比‌

* 选项B（2²³）‌与计算结果一致‌。

* 其他选项错误原因‌：

    A（2²⁴）：误用字节寻址（每单元1字节）‌。
    C（2²²）和D（2²¹）：无对应计算逻辑支持‌。

5. 通用公式：

* 可寻址单元数 = 存储器容量（字节） ÷ 每单元字节数‌

本题中：

* 每单元字节数 = 半字大小 = 2字节 → 2²⁴ ÷ 2 = 2²³‌。

通过以上步骤可清晰得出答案为‌B. 2²³‌。

=== 存储体系位示图 (第几个字)(多少字)
某文件管理系统采用位示图(bitmap)记录磁盘的使用情况。
如果系统的字长为 32 位（指计算机一次可以处理的数据位数为32位），
磁盘物理块的大小为 4MB，物理块依次编号为：0、1、2、位示图字依次编号为：0、1、2，
那么 16385 号物理块的使用情况在位示图中的第（ ）个字中描述;
如果磁盘的容量为 1000GB，那么位示图需要（ ）个字来表示。

---

关于 16385 号物理块在位示图中的位置计算，正确的答案确实是‌**512**‌（从0开始编号），而不是511。以下是详细解释：

1. 16385 号物理块的位置计算

- 物理块编号从‌**0**‌开始，因此16385号物理块实际上是第‌**16386**‌个物理块（因为编号0是第1块）‌。
- 每个字长为 32 位，可表示 32 个物理块的状态。
- 计算：
  ** 字数 = 16386​ / 32 = 512.0625
  ** 取整数部分，得到‌**512**‌（从0开始编号的字序号）‌。

2. 1000GB 磁盘的位示图字数计算

- 磁盘容量 = 1000GB = 1000 * 1024MB = 1,024,000MB。
- 每个物理块大小 = 4MB，因此物理块总数 = 1,024,000 / 4 ​= 256,000 个。
- 每个字表示 32 个物理块，所需字数 = 32 * 256,000 = 8,000个字‌。

最终答案：

- 16385号物理块在位示图中的第‌ 512 个字中描述；
- 1000GB磁盘的位示图需要‌ 8,000 个字来表示‌。

---

*继续解释：*

> 每个字长为 32 位（即一个字里有 32 个 bit），**每个 bit 表示一个物理块的状态**，而每个物理块大小为 **4MB**。

换句话说：

- 一个 bit → 表示一个 4MB 的物理块是否已被使用（0 表示空闲，1 表示占用）

- 一个 32 位的字（即 4 字节）→ 可以表示 **32 个 4MB 的物理块** 的使用情况；

- 所以：一个字可管理的总磁盘空间为：`32 × 4MB = 128MB`。

举个简单：

假设磁盘只有 128MB，块大小是 4MB，那么：

- 总共有 `128 ÷ 4 = 32` 个块；
- 只需要一个 32 位的字（4 字节）就能用位示图来表示这 32 个块的使用情况。

总结：“每个字长为 32 位，可表示 32 个物理块的状态”指的是：

- **每个位对应一个 4MB 的物理块**。

=== 存储地址编号
设用 2K×4 位的存储器芯片组成 16K×8 位的存储器（地址单元为 0000H~3FFFH，每个芯片的地址空间连续)，则地址单元 *0B1FH* 所在芯片的最小地址编号为（ ）。

*A* 0000H; *B* 0800H; *C* 2000H; *D* 2800H;

先分析问题：

***

1. 什么是「2K×4位的芯片」？

- 「2K」表示有 **2 × 1024 = 2048** 个地址单元
- 「4位」表示每个地址单元存的是 **4位数据**（半个字节）

2. 我们要做一个「16K × 8位」的存储器

- 「16K」表示有 **16 × 1024 = 16384** 个地址单元
- 每个地址要存 **8 位数据**（1 个字节）

---

*怎么用小芯片拼出大存储器？*

现在有很多个「2K × 4位」的小芯片。要拼成「16K × 8位」的存储器：

第一步：数据宽度

- 每个芯片只有 4 位，但我们需要 8 位 → 所以 **要用两个芯片拼起来**
- 一个管高 4 位，一个管低 4 位，所以每个地址要用 **2 个芯片**。

第二步：地址数量

- 每个芯片能放 2K 个地址，但我们需要 16K 个地址，所以需要
 16K / 2K = **8 组地址区间**

每组地址，需要 2 个芯片（见上一步），所以总共是：**8 组 × 2 个芯片 = 16 个芯片**。

---

看看题目问什么？

> 地址单元 0B1FH（十六进制）是在哪个芯片中？这个芯片的起始地址是多少？

把 0B1F₁₆ 换成十进制 `0B1F₁₆ = 2847₁₀`，然后我们看一下每组芯片的地址范围是多大：

- 每组是 2K 地址 → 2048 个地址

所以地址分组是这样的：

[caption=]
[cols="^1,1",options="header"]
|===
| 区块编号 | 地址范围（十六进制）
| 0   | 0000H ~ 07FFH -> (0000 ~ 2047)
| 1   | 0800H ~ 0FFFH -> (2048 ~ 4095)
| 2   | 1000H ~ 17FFH -> (4096 ~ 6143)
| ……  | ……
| 7   | 3800H ~ 3FFFH -> (14335 ~ 16383)
|===

那 0B1F 属于哪组？

看看 0B1F 在不在 0800H ~ 0FFFH 里？ +
是的！属于 **第 1 组**（编号为 1）

---
所以这个芯片的最小地址是：**0800H**，最后答案是：**B. 0800H**。

