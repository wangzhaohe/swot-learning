<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="swot.20250508123413.1"><vh>@adoc README.adoc</vh>
<v t="swot.20250508123515.1"><vh>Record learning contents</vh>
<v t="swot.20250508125533.1"><vh>Read document</vh></v>
<v t="swot.20250508123848.1"><vh>Asciidoctor</vh></v>
<v t="swot.20250508161823.1"><vh>Git</vh></v>
<v t="swot.20250508123546.1"><vh>LEO-Editor</vh></v>
<v t="swot.20250508162744.1"><vh>Software-Designer</vh></v>
</v>
</v>
<v t="swot.20250508124711.1" descendentVnodeUnknownAttributes="7d710028580b000000302e302e302e322e302e3271017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d323271077573580b000000302e302e302e322e302e3371087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30322d3232710e75735809000000302e302e302e322e34710f7d71105808000000616e6e6f7461746571117d71122858080000007072696f7269747971134d0f27580a000000707269736574646174657114580a000000323032352d30312d3330711575735807000000302e302e302e3371167d71175808000000616e6e6f7461746571187d71192858080000007072696f72697479711a4d0f27580a00000070726973657464617465711b580a000000323032352d30322d3032711c7573752e"><vh>@path asciidoctor</vh>
<v t="swot.20250508105244.1" descendentVnodeUnknownAttributes="7d7100285809000000302e302e322e302e3271017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d3232710775735809000000302e302e322e302e3371087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30322d3232710e75735807000000302e302e322e34710f7d71105808000000616e6e6f7461746571117d71122858080000007072696f7269747971134d0f27580a000000707269736574646174657114580a000000323032352d30312d3330711575735805000000302e302e3371167d71175808000000616e6e6f7461746571187d71192858080000007072696f72697479711a4d0f27580a00000070726973657464617465711b580a000000323032352d30322d3032711c7573752e"><vh>@adoc asciidoctor.adoc</vh>
<v t="swot.20250508114609.1" descendentVnodeUnknownAttributes="7d7100285807000000302e322e302e3271017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d3232710775735807000000302e322e302e3371087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30322d3232710e75735805000000302e322e34710f7d71105808000000616e6e6f7461746571117d71122858080000007072696f7269747971134d0f27580a000000707269736574646174657114580a000000323032352d30312d3330711575735803000000302e3371167d71175808000000616e6e6f7461746571187d71192858080000007072696f72697479711a4d0f27580a00000070726973657464617465711b580a000000323032352d30322d3032711c7573752e"><vh>Asciidoctor</vh>
<v t="swot.20250508105234.1"><vh>asciidoctor-default.css -&gt; custom your export html</vh></v>
<v t="swot.20250508220045.1"><vh>options.rb -&gt; asciidoctor config file</vh>
<v t="swot.20250508220045.2"><vh>data-uri</vh></v>
</v>
<v t="swot.20250508224645.1" descendentVnodeUnknownAttributes="7d7100285805000000302e302e3271017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d3232710775735805000000302e302e3371087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30322d3232710e75735803000000302e34710f7d71105808000000616e6e6f7461746571117d71122858080000007072696f7269747971134d0f27580a000000707269736574646174657114580a000000323032352d30312d333071157573752e"><vh>asciidoctor-diagram local drawing</vh>
<v t="swot.20250508224817.1" descendentVnodeUnknownAttributes="7d7100285803000000302e3271017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d3232710775735803000000302e3371087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30322d3232710e7573752e"><vh>plantuml</vh>
<v t="swot.20250508230637.1"><vh>gantt</vh></v>
<v t="swot.20250508233908.1"><vh>json</vh>
<v t="swot.20250508233908.2"><vh>@ignore-node #edit data/diagram-json1.puml</vh></v>
</v>
<v t="swot.20250509073027.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d323271077573732e"><vh>component</vh>
<v t="swot.20250509073027.2"><vh>Why is the interface needed?</vh></v>
<v t="swot.20250509073027.3"><vh>上图中的虚线和实线表示一样的含义？</vh></v>
<v t="swot.20250509073027.4"><vh>组件图还可以使用 package？</vh></v>
<v t="swot.20250509073027.5"><vh>组件图中的 component 类似软件开发中的什么？</vh></v>
<v t="swot.20250509073027.6"><vh>某官网展示端组件图 home</vh></v>
<v t="swot.20250509073027.7"><vh>某官网展示端组件图 app.js -&gt; clint_news_list.js</vh></v>
<v t="swot.20250509073027.8"><vh>某官网展示端组件图 app.js -&gt; clint_news_detail.js</vh></v>
<v t="swot.20250509073027.9"><vh>某官网展示端组件图 app.js -&gt; other routes</vh></v>
<v t="swot.20250509073027.10"><vh>某官网展示端组件图 app.js -&gt; Directory</vh></v>
</v>
<v t="swot.20250509104746.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d323271077573732e"><vh>deployment</vh>
<v t="swot.20250509104746.2"><vh>某官网部署图</vh></v>
</v>
<v t="swot.20250509111441.1"><vh>WBS (Work Breakdown Structure)</vh></v>
<v t="swot.20250508232203.1"><vh>mindmap</vh></v>
<v t="swot.20250508225006.1"><vh>Salt -&gt; Draw the prototype diagram</vh></v>
<v t="swot.20250508232842.1"><vh>yaml</vh></v>
</v>
<v t="swot.20250509113701.1"><vh>mermaid</vh></v>
<v t="swot.20250510115002.1"><vh>graphviz</vh></v>
<v t="swot.20250509155424.1"><vh>Barcode</vh></v>
<v t="swot.20250509164220.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30312d333071077573732e"><vh>vega &amp; vegalite</vh>
<v t="swot.20250509164220.2"><vh>vegalite_example1 -&gt; values embedded</vh></v>
<v t="swot.20250509164220.3"><vh>vegalite_example2 -&gt; values embedded</vh></v>
<v t="swot.20250509164220.4"><vh>vegalite_example3 -&gt; local Web server supply data</vh></v>
<v t="swot.20250509164220.5"><vh>vega example1</vh></v>
</v>
</v>
<v t="swot.20250509171442.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d303271077573732e"><vh>asciidoctor-kroki server drawing</vh></v>
</v>
</v>
</v>
<v t="swot.20250508105043.2"><vh>@path leo-editor</vh>
<v t="swot.20250508134307.1"><vh>@adoc leo-editor.adoc</vh>
<v t="swot.20250508134351.1"><vh>Learning Leo</vh>
<v t="swot.20250508134253.1"><vh>Install leo-editor from source</vh></v>
<v t="swot.20250508154257.1"><vh>Teaching by leo-editor</vh>
<v t="swot.20250508154257.2"><vh>write document</vh></v>
<v t="swot.20250508154257.3"><vh>write code</vh></v>
<v t="swot.20250508154257.4"><vh>show content</vh></v>
</v>
</v>
</v>
</v>
<v t="swot.20250508160844.1"><vh>@path git</vh>
<v t="swot.20250508161005.1"><vh>@adoc git.adoc</vh>
<v t="swot.20250508161024.1"><vh>Git</vh>
<v t="swot.20250508161032.1"><vh>git-filter-repo -&gt; delete file from all git commit</vh></v>
</v>
</v>
</v>
<v t="swot.20250508162519.1" descendentVnodeUnknownAttributes="7d71005809000000302e302e302e362e3171017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d313071077573732e"><vh>@path software-designer</vh>
<v t="swot.20250508162628.1" descendentVnodeUnknownAttributes="7d71005807000000302e302e362e3171017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d313071077573732e"><vh>@adoc software-designer.adoc</vh>
<v t="swot.20250508162652.1" descendentVnodeUnknownAttributes="7d71005805000000302e362e3171017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d313071077573732e"><vh>软件设计师例题精讲</vh>
<v t="swot.20250509183134.1"><vh>数据表示</vh>
<v t="swot.20250510214900.1"><vh>浮点数格式</vh></v>
<v t="swot.20250509183157.1"><vh>校验码（在OSI的数据链路层）</vh>
<v t="swot.20250509183417.1"><vh>奇偶校验</vh></v>
<v t="swot.20250509184225.1"><vh>循环冗余校验码‌（CRC校验）</vh></v>
<v t="swot.20250509191942.1"><vh>海明码</vh>
<v t="swot.20250509191942.2"><vh>Example1 计算海明码</vh></v>
</v>
</v>
</v>
<v t="swot.20250509173942.1"><vh>数据结构</vh>
<v t="swot.20250509173947.1"><vh>二叉树小根堆</vh></v>
<v t="swot.20250509175116.1"><vh>二叉树遍历顺序</vh></v>
<v t="swot.20250509175355.1"><vh>哈夫曼树(最优二叉树)</vh></v>
<v t="swot.20250509180254.1"><vh>无向图顶点度数</vh></v>
<v t="swot.20250510204918.1"><vh>拓扑排序</vh></v>
</v>
<v t="swot.20250510124842.1"><vh>状态转换机</vh></v>
<v t="swot.20250509232901.1"><vh>存储系统与寻址结构</vh>
<v t="swot.20250509232946.1"><vh>寻址单元数计算</vh></v>
<v t="swot.20250509235804.1"><vh>存储体系位示图 (第几个字)(多少字)</vh></v>
<v t="swot.20250510083353.1"><vh>存储地址编号</vh></v>
</v>
<v t="swot.20250510111143.1"><vh>指令流水线</vh></v>
<v t="swot.20250508163105.1"><vh>操作系统</vh>
<v t="swot.20250508163140.1"><vh>进程同步与互斥（PV 操作）</vh>
<v t="swot.20250508163626.1"><vh>前趋图</vh></v>
<v t="swot.20250508164139.1"><vh>PV 操作</vh></v>
<v t="swot.20250508192826.1"><vh>Example</vh></v>
</v>
</v>
<v t="swot.20250510131711.1" descendentVnodeUnknownAttributes="7d71005803000000302e3171017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d313071077573732e"><vh>数据库</vh>
<v t="swot.20250510131821.1"><vh>关系模式</vh></v>
<v t="swot.20250510173155.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d313071077573732e"><vh>关系代数表达式</vh>
<v t="swot.20250510173155.2"><vh>问题1</vh></v>
<v t="swot.20250510173155.3"><vh>问题2</vh></v>
<v t="swot.20250510173155.4"><vh>举一个具体例子‌</vh></v>
</v>
<v t="swot.20250510175502.1"><vh>数据库模式</vh></v>
</v>
<v t="swot.20250510180235.1"><vh>网络模型</vh>
<v t="swot.20250510180303.1"><vh>OSI 七层模型与 TCP/IP 四层模型</vh>
<v t="swot.20250510180303.2"><vh>Example</vh></v>
</v>
<v t="swot.20250510182531.1"><vh>网络层</vh>
<v t="swot.20250510182608.1"><vh>IP 数据报分片</vh>
<v t="swot.20250510182608.2"><vh>Example1</vh></v>
<v t="swot.20250510182608.3"><vh>Example2</vh></v>
<v t="swot.20250510182608.4"><vh>Example3</vh></v>
<v t="swot.20250510182608.5"><vh>Example4</vh></v>
</v>
<v t="swot.20250510193659.1"><vh>IP 地址分类</vh></v>
<v t="swot.20250510201445.1"><vh>IP 地址特殊情况</vh></v>
<v t="swot.20250510201742.1"><vh>子网掩码计算子网号</vh></v>
<v t="swot.20250510202838.1"><vh>IPv6 协议</vh></v>
<v t="swot.20250510203357.1"><vh>RIP 协议</vh>
<v t="swot.20250510203357.2"><vh>Example</vh></v>
</v>
<v t="swot.20250510204058.1"><vh>BGP 协议</vh></v>
</v>
</v>
<v t="swot.20250510130542.1"><vh>编程语言</vh>
<v t="swot.20250510130542.2"><vh>C 语言</vh></v>
</v>
<v t="swot.20250510175912.1"><vh>UML 图</vh>
<v t="swot.20250510175912.2"><vh>类图符号</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="swot.20250508105043.2"></t>
<t tx="swot.20250508105234.1">Find it position:

    gem contents asciidoctor | grep asciidoctor-default.css
    ~/.rvm/gems/ruby-2.7.2/gems/asciidoctor-2.0.23/data/stylesheets

Create a hard link:

    ln ~/.rvm/gems/ruby-2.7.2/gems/asciidoctor-2.0.23/data/stylesheets/asciidoctor-default.css leo-editor/
    Now I can edit asciidoctor-default.css in leo-editor.

</t>
<t tx="swot.20250508105244.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3</t>
<t tx="swot.20250508114609.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'none';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250508123413.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3

</t>
<t tx="swot.20250508123515.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'none';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250508123546.1">Leo is a PIM, IDE and outliner that accelerates the work flow of programmers, authors and web designers. 
Outline nodes may appear in more than one place, allowing multiple organizations of data within a single outline.

xref:leo-editor/leo-editor.adoc[ Read leo-editor learning Notes ]

https://leo-editor.github.io/leo-editor/[ Leo’s Home Page ]

https://github.com/leo-editor/leo-editor[ Leo's GitHub repository ]

https://groups.google.com/g/leo-editor[ Leo's forum ]

</t>
<t tx="swot.20250508123848.1">Asciidoctor is a fast, open source, text processor for parsing AsciiDoc into a document model, then converting it to output formats such as HTML 5, DocBook 5, man(ual) pages, PDF, and EPUB 3. Asciidoctor is written in the Ruby programming language.

xref:asciidoctor/asciidoctor.adoc[ Read Asciidoctor learning Notes ]

https://docs.asciidoctor.org/asciidoctor/latest/[ Asciidoctor Documentation ]
</t>
<t tx="swot.20250508124711.1"></t>
<t tx="swot.20250508125533.1">The AsciiDoc file(.adoc) is intended for online viewing, while the HTML file(.html) is for offline access.
</t>
<t tx="swot.20250508134253.1">1. Clone leo-editor source code

    git clone https://github.com/leo-editor/leo-editor.git

2. Install python3

    https://www.python.org/downloads/

3. Create a Python virtual environment

    python3 -m venv your_environment_name
    source your_environment_name/bin/activate

4. Install some packages
+
....
pip install pyqt6
pip install PyQtWebEngine
pip install docutils markdown nbformat numpy matplotlib nbconvert pygments
pip install jupyter-client==6.1.12 qtconsole // &lt;1&gt;
....
+
&lt;1&gt; for python debug in shell
NOTE: jupyter-client-7.3.4 has bug, and can't run `qtconsole`
+
.Change pip source
[NOTE]
====
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
====

5. launch leo-editor

    python launchLeo.py
</t>
<t tx="swot.20250508134307.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3</t>
<t tx="swot.20250508134351.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'none';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250508154257.1"></t>
<t tx="swot.20250508154257.2">@language asciidoc
Teaching documents are typically presented in the form of PowerPoint (PPT) files. However, PPTs are generally used for summarizing and presenting information during live sessions and should be complemented by detailed Word or Markdown files to serve as practical operational aids. 

In programming-related teaching materials, the primary source code of demonstration programs is usually included. Typically, the relevant portions of the source code are copied into the documentation. This practice introduces the challenge of ensuring that the documentation is promptly updated whenever changes are made to the source code.

Therefore, if a method could be devised to write the source code concurrently with the documentation, a significant amount of repetitive labor and time could be saved.


教学文档通常为 ppt 文件，但是 ppt 一般做为临场提纲挈领的演示，需要再配合详尽的 word 或者 markdown 文件来作为实操辅助。

在编程的教学文档里，会包含演示程序的主要源代码。通常会把需要的部分源代码复制到文档里。这样就存在源代码更改后需要再及时更改文档的问题。

所以如果能够在编写文档的同时编写源代码，将会节省大量重复劳动的时间。
</t>
<t tx="swot.20250508154257.3">@language asciidoc
When writing code, it is often necessary to add a lot of explanatory text. The commonly adopted approach is to directly write single-line comments or a large number of block comments in the code.

If these comments in the code could be formatted like an article, the effect would be much better.


在编写代码时，往往需要加入很多说明文字，经常采用的方式是直接在代码里写单行注释或者大量块注释。

如果代码里的这些注释能够有像文章一样的排版体现，效果就会好很多。
</t>
<t tx="swot.20250508154257.4">@language asciidoc
When presenting, making more use of ppt can achieve paginated display of each knowledge node.

If the key documents and main code can be combined and written only once, and presented in the form of nodes, the purpose of integrating the documents, code and presentation can be achieved.


在演示时多采用 ppt，可以实现每个知识节点的分页显示。

如果能够将重点文档和主要代码结合在一起且只写一次，以节点的方式呈现出来，则能达到文档、代码、演示合一的目的。
</t>
<t tx="swot.20250508160844.1"></t>
<t tx="swot.20250508161005.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3</t>
<t tx="swot.20250508161024.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'none';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250508161032.1">https://github.com/newren/git-filter-repo

Install:

    git clone https://github.com/newren/git-filter-repo.git
    cd git-filter-repo
    pip install .
    git-filter-repo --version

To **delete a specific file from all commits in a Git repository**, you can use `git-filter-repo` which is a modern and faster replacement for `git filter-branch`.

Here’s the command to delete a file from all commits:

```bash
git filter-repo --path &lt;path/to/file&gt; --invert-paths
```

Example:

To delete `secret.txt` from all history:

```bash
git filter-repo --path secret.txt --invert-paths
```

Notes:

* This permanently **removes the file from the entire Git history**, including all branches and tags.
* `--invert-paths` means "remove this path instead of keeping it".
* After running this command, you'll likely need to force-push to remote:

```bash
git push --force --all
git push --force --tags
```

&gt; ⚠️ Warning: This rewrites history. All collaborators will need to re-clone or rebase their work.

</t>
<t tx="swot.20250508161823.1">Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.

xref:git/git.adoc[ Read git learning Notes ]

https://git-scm.com/

https://git-scm.com/downloads

</t>
<t tx="swot.20250508162519.1"></t>
<t tx="swot.20250508162628.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3
</t>
<t tx="swot.20250508162652.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250508162744.1">Now only for Chinese.

xref:software-designer/software-designer.adoc[ Read software-designer learning Notes ]

https://bm.ruankao.org.cn/sign/welcome

https://ruankaodaren.com/exam/#/

</t>
<t tx="swot.20250508163105.1"></t>
<t tx="swot.20250508163140.1"></t>
<t tx="swot.20250508163626.1">前趋图（Precedence Graph）是一种用于表示任务或进程之间执行顺序关系的图形表示方法。它通常用于项目管理、操作系统的进程调度、编译原理中的指令调度等领域，以帮助确定任务或进程的执行顺序和依赖关系。

前趋图的特点：

1. **节点（Vertices）**：图中的每个节点代表一个任务或进程。
2. **有向边（Directed Edges）**：图中的边表示任务或进程之间的依赖关系。如果存在一条从节点 A 指向节点 B 的有向边，那么它表示任务 A 必须在任务 B 之前完成。

前趋图的作用：

- **确定执行顺序**：通过分析前趋图，可以确定哪些任务可以并行执行，哪些任务必须按顺序执行。
- **避免死锁**：在操作系统中，前趋图可以帮助设计避免死锁的资源分配策略。
- **优化调度**：在编译器设计中，前趋图可以帮助优化指令的执行顺序，提高程序的执行效率。

前趋图的示例：

假设有四个任务 A、B、C、D，其中：
- 任务 A 必须在任务 B 和 C 之前完成。
- 任务 B 和 C 必须在任务 D 之前完成。

前趋图可以表示为：

```
  A
  │
  ▼
  B---C
  │    │
  ▼    ▼
    D
```

在这个图中，A 是 B 和 C 的前趋，B 和 C 是 D 的前趋。

在操作系统的进程调度中，前趋图可以帮助操作系统确定进程的执行顺序，确保系统资源的有效利用和进程的正确执行。
</t>
<t tx="swot.20250508164139.1">PV操作是操作系统中用于进程同步与互斥的一种机制，由两部分组成：P操作（Proberen，荷兰语中的“测试”）和V操作（Verhogen，荷兰语中的“增加”）。这种机制通常与信号量（Semaphore）一起使用，信号量是一个整数变量，用于控制对共享资源的访问。

* P操作（等待操作）

    ** P操作用于申请资源。当一个进程需要访问共享资源时，它会执行P操作。如果信号量的值大于0，表示资源可用，信号量减1，进程继续执行。如果信号量的值为0，表示资源不可用，进程将被阻塞，直到信号量的值变为正数。

* V操作（释放操作）

    ** V操作用于释放资源。当一个进程完成对共享资源的访问后，它会执行V操作。这会使信号量的值增加1。如果此时有其他进程因为资源不可用而被阻塞，那么V操作会唤醒其中一个阻塞的进程，使其可以继续执行。

* 信号量的类型

    1. **整型信号量**：信号量的值可以是任意整数，用于表示资源的数量。当信号量的值为0时，表示没有资源可用。
    2. **二进制信号量**：信号量的值只能是0或1，用于实现互斥锁。0表示锁被占用，1表示锁可用。

PV操作广泛应用于操作系统中的进程同步、互斥、死锁避免等领域。例如：

- **进程同步**：确保多个进程按照特定的顺序执行。
- **互斥访问**：确保在任何时刻只有一个进程可以访问共享资源。
- **避免死锁**：通过控制资源的分配和释放，避免系统进入死锁状态。

通过合理使用PV操作，可以有效地管理进程间的协作和资源共享，提高系统的稳定性和效率。
</t>
<t tx="swot.20250508192826.1">进程 P1、P2、P3、P4、P5 的 link:img/graphviz-pv-2025-05-08-193314.png[前趋图] 如下：

[graphviz, target="img/graphviz-pv-2025-05-08-193314", format=png]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape = circle];

    P1 -&gt; P3;
    P2 -&gt; P3;
    P3 -&gt; P4;
    P3 -&gt; P5;
}
....

若用 PV 操作控制进程并发执行的过程，则需要设置 4 个信号量 S1、S2、S3、S4，且信号量初值都等于零。下面 link:img/graphviz-2025-05-08-194149.png[PV图] 中 a 和 b 应分别填写（），c 和 d 应分别填写（），e 和 f 应分别填写（）。

[graphviz, target="img/graphviz-2025-05-08-194149", format=png]
....
digraph PetriNet {
    rankdir=TB;
    node [shape=circle]; P1 P2;
    node [shape=box]; P3 P4 P5 a b c d e f;
    end1 [label="", shape=circle];
    end2 [label="", shape=circle];

    P1 -&gt; a [label="P1执行"];
    P2 -&gt; b [label="P2执行"];
    c  -&gt; P3
    P3 -&gt; d [label="P3执行"];
    e -&gt; P4
    P4 -&gt; end1
    f -&gt; P5
    P5 -&gt; end2
}
....

*答案解析：*

- **a 和 b 处**：当 P1 和 P2 执行完毕后，它们需要通过执行 V 操作来增加信号量 S1 和 S2 的值，从而通知 P3 可以开始执行。因此，a 处应填写 V(S1)，b 处应填写 V(S2)。

- **c 和 d 处**：进程 P3 在开始执行前，需要通过执行 P 操作来检查 S1 和 S2 的值是否大于 0。如果 S1 和 S2 的值都大于 0，表示 P1 和 P2 已经执行完毕，P3 可以开始执行。因此，c 处应填写 P(S1)，d 处应填写 P(S2)。

- **e 和 f 处**：进程 P4 和 P5 在开始执行前，需要通过执行 P 操作来检查 S3 和 S4 的值是否大于 0。如果 S3 和 S4 的值都大于 0，表示 P3 已经执行完毕，P4 和 P5 可以开始执行。因此，e 处应填写 P(S3)，f 处应填写 P(S4)。
</t>
<t tx="swot.20250508220045.1">Purpose: It is unnecessary to change the Leo Editor source code to customize the Asciidoctor command used for generating HTML.

Asciidoctor runs in a Ruby environment, and we occasionally need to pass extra parameters. Since Leo Editor uses fixed parameters in the vr3 plugin to generate HTML, and modifying its source code repeatedly isn’t ideal, we developed the following solution.

.Find Ruby LOAD_PATH
[source,console]
----
ruby -e 'puts $LOAD_PATH'

/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/site_ruby/2.7.0
/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/site_ruby/2.7.0/x86_64-darwin21
/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/site_ruby
/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/vendor_ruby/2.7.0
/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/vendor_ruby/2.7.0/x86_64-darwin21
/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/vendor_ruby
/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/2.7.0
/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/2.7.0/x86_64-darwin21
----

.nvim options.rb
[source,ruby]
----
begin
  require 'asciidoctor-diagram'
rescue LoadError
  warn 'asciidoctor-diagram is not installed'
end

# Not use now
#begin
#  require 'asciidoctor-kroki'
#rescue LoadError
#  warn 'asciidoctor-kroki is not installed'
#end

# use data-uri（same as -a data-uri）for embed images base64 string in html page
# Asciidoctor::DEFAULT_ATTRIBUTES['data-uri'] = ''
----

.copy options.rb to site_ruby/2.7.0
[source,console]
----
cp options.rb /Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/site_ruby/2.7.0
----

.Then leo-editor source code only use `-r options` will be ok
[source,python]
----
command = f"{prog} {i_path} -o {o_path} -b html5 -r options"
----

[NOTE]
====
leo-editor source code `-r options` position: +
unl://LeoPyRef.leo#Code--&gt;Core classes--&gt;@file leoMarkup.py--&gt;class MarkupCommands--&gt;markup.command_helper &amp; helpers--&gt;markup.run_asciidoctor
====
</t>
<t tx="swot.20250508220045.2">This line of code:

```ruby
Asciidoctor::DEFAULT_ATTRIBUTES['data-uri'] = ''
```

enables the `data-uri` option in Asciidoctor's default attributes, which means **images will be converted to Base64 and embedded directly into the HTML** instead of being referenced by an external URL.

**Explanation**

By default, Asciidoctor generates HTML with `&lt;img&gt;` tags that load images using file paths or URLs. For example:

```html
&lt;img src="images/example.png"&gt;
```

If the `data-uri` option is enabled, Asciidoctor will convert the image files into Base64 and embed them directly in the HTML, like this:

```html
&lt;img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAA..."&gt;
```

This approach reduces external requests and is suitable for:

* Single-file HTML (e.g., offline documents)
* Better portability (no concerns about image path issues)

**Equivalent Command-Line Option**

This line of code is equivalent to running the following in the command line:

```console
asciidoctor -a data-uri myfile.adoc
```

Or setting it in the AsciiDoc document:

```adoc
:imagesdir: images
:data-uri:
```

**Why Use `Asciidoctor::DEFAULT_ATTRIBUTES`?**

`Asciidoctor::DEFAULT_ATTRIBUTES` is the global default attribute configuration. Setting `data-uri` to an empty string `''` effectively **enables** this option. When Asciidoctor processes attributes:

* If the attribute value is empty (`''`), it is treated as **enabled**
* If the attribute does not exist, it is treated as **disabled**
* If explicitly set as `data-uri=0` or `!data-uri`, it is **disabled**

**Summary**

* Enabling `data-uri` converts images to Base64 and embeds them in the HTML
* Improves document portability by avoiding missing external images
* Suitable for offline HTML documents
* Equivalent to the `-a data-uri` option

If you do not want to embed images as Base64, you can remove this line of code or explicitly disable `data-uri`:

```ruby
Asciidoctor::DEFAULT_ATTRIBUTES.delete('data-uri')
```
</t>
<t tx="swot.20250508224645.1"></t>
<t tx="swot.20250508224817.1">1. https://docs.asciidoctor.org/diagram-extension/latest/diagram_types/plantuml/
2. https://rubygems.org/gems/asciidoctor-diagram-plantuml
3. https://plantuml.com/zh/
4. https://plantuml.com/

安装 plantuml:

    gem install asciidoctor-diagram-plantuml

</t>
<t tx="swot.20250508225006.1">.link:img/diagram-salt-2025-05-08-225243.png[common prototype]
[plantuml, target=img/diagram-salt-2025-05-08-225243, format=png]
....
@startsalt
scale 1.5
{
  Just plain text
  [This is my button]
  ()  Unchecked radio
  (X) Checked radio
  []  Unchecked box
  [X] Checked box
  "Enter text here   "
  ^This is a droplist^
}
@endsalt
....

.link:img/diagram-salt-2025-05-08-225302.png[prototype in flow]
[plantuml, target=img/diagram-salt-2025-05-08-225302, format=png]
....
@startuml
start
repeat :read data;
  :generate diagrams;
repeat while (\n{{\nsalt\n{^"Next step"\n  Do you want to continue? \n[Yes]|[No]\n}\n}}\n)
stop
@enduml
....
</t>
<t tx="swot.20250508230637.1">.link:img/diagram-gantt-2025-05-08-230846.png[gantt]
[plantuml, target=img/diagram-gantt-2025-05-08-230846, format=png]
....
@startgantt
scale 1.5
'skinparam dpi 300
saturday are closed
sunday are closed

Project starts the 1st of january 2021
[Prototype design end] as [TASK1] requires 19 days
[TASK1] is colored in Lavender/LightBlue
[Testing] requires 14 days
[TASK1]-&gt;[Testing]

2021-01-18 to 2021-01-22 are named [End's committee]
2021-01-18 to 2021-01-22 are colored in salmon 
@endgantt
....
</t>
<t tx="swot.20250508232203.1">.link:img/diagram-mindmap-2025-05-08-232219.png[mindmap]
[plantuml, target=img/diagram-mindmap-2025-05-08-232219, format=png]
....
@startmindmap
* Creole on Mindmap
left side
**:==Creole
  This is **bold**
  This is //italics//
  This is ""monospaced""
  This is --stricken-out--
  This is __underlined__
  This is ~~wave-underlined~~
--test Unicode and icons--
  This is &lt;U+221E&gt; long
  This is a &lt;&amp;code&gt; icon
  Use image : &lt;img:https://plantuml.com/logo3.png&gt;
;
**: &lt;b&gt;HTML Creole 
  This is &lt;b&gt;bold&lt;/b&gt;
  This is &lt;i&gt;italics&lt;/i&gt;
  This is &lt;font:monospaced&gt;monospaced&lt;/font&gt;
  This is &lt;s&gt;stroked&lt;/s&gt;
  This is &lt;u&gt;underlined&lt;/u&gt;
  This is &lt;w&gt;waved&lt;/w&gt;
  This is &lt;s:green&gt;stroked&lt;/s&gt;
  This is &lt;u:red&gt;underlined&lt;/u&gt;
  This is &lt;w:#0000FF&gt;waved&lt;/w&gt;
-- other examples --
  This is &lt;color:blue&gt;Blue&lt;/color&gt;
  This is &lt;back:orange&gt;Orange background&lt;/back&gt;
  This is &lt;size:20&gt;big&lt;/size&gt;
;
right side
**:==Creole line
You can have horizontal line
----
Or double line
====
Or strong line
____
Or dotted line
..My title..
Or dotted title
//and title... //
==Title==
Or double-line title
--Another title--
Or single-line title
Enjoy!;
**:==Creole list item
**test list 1**
* Bullet list
* Second item
** Sub item
*** Sub sub item
* Third item
----
**test list 2**
# Numbered list
# Second item
## Sub item
## Another sub item
# Third item
;
@endmindmap
....
</t>
<t tx="swot.20250508232842.1">plantuml show yaml structure， for example Spring Boot's application.yml.
https://plantuml.com/zh/yaml

.link:img/diagram-yaml-2025-05-08-232919.png[yaml]
[plantuml, target=img/diagram-yaml-2025-05-08-232919, format=png]
....
@startyaml
spring:
  application:
    name: mybatis_quickstart-crud
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/general_manager
    username: root
    password: root
  servlet:
    multipart:                  # 上传文件
      max-file-size: 10MB     # 指定单个文件上传的大小
      max-request-size: 100MB  # 指定单次请求上传文件的总大小

mybatis:
  configuration:
    # 指定mybatis输出日志的位置, 输出控制台
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
    #开启驼峰命名自动映射，即从经典数据库列名 a_column 映射到经典 Java 属性 名 aColumn
    map-underscore-to-camel-case: true

# --- 阿里云 OSS ---
# 与之对应引用为 @Vaule("${aliyun.oss.endpoint}")
aliyun:
  oss:
    endpoint: "https://oss-cn-beijing.aliyuncs.com"
    accessKeyId: "LQAI5tJ3drn2qkNAGZrxwpnC"
    accessKeySecret: "cMJ6XHSntg361NsN6swGVlyB0Sks84"
    bucketName: "swot-learn"
@endyaml
....
</t>
<t tx="swot.20250508233908.1">@language asciidoc
Example: Using different styles for highlight -&gt; link:data/diagram-json1.puml[show json source]
Ref: https://plantuml.com/zh/json

    [plantuml, img/diagram-json-2025-05-08-233937, format=png]
    ----
    include::data/diagram-json1.puml[]
    ----

.link:img/diagram-json-2025-05-08-233937.png[draw json image]
[plantuml, img/diagram-json-2025-05-08-233937, format=png]
----
include::data/diagram-json1.puml[]
----
</t>
<t tx="swot.20250508233908.2">@startjson
&lt;style&gt;
  .h1 {
    BackGroundColor green
    FontColor white
    FontStyle italic
  }
  .h2 {
    BackGroundColor red
    FontColor white
    FontStyle bold
  }
&lt;/style&gt;
#highlight "lastName"
#highlight "address" / "city" &lt;&lt;h1&gt;&gt;
#highlight "phoneNumbers" / "0" / "number" &lt;&lt;h2&gt;&gt;
{
  "firstName": "John",
  "lastName": "Smith",
  "isAlive": true,
  "age": 28,
  "address": {
    "streetAddress": "21 2nd Street",
    "city": "New York",
    "state": "NY",
    "postalCode": "10021-3100"
  },
  "phoneNumbers": [
    {
      "type": "home",
      "number": "212 555-1234"
    },
    {
      "type": "office",
      "number": "646 555-4567"
    }
  ],
  "children": [],
  "spouse": null
}
@endjson</t>
<t tx="swot.20250509073027.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032352d30322d32327103752e">**Component diagrams** use **components** and **interfaces** to represent the logical modules of software and their interaction interfaces.

[plantuml, target=img/diagram-component-2025-05-09-095950, format=png]
....
@startuml
component "Frontend" as Frontend
component "Backend API" as Backend
interface "API Interface" as API_Interface

Frontend ..&gt; API_Interface
Backend --|&gt; API_Interface
@enduml
....
</t>
<t tx="swot.20250509073027.10">@language asciidoc
在 app.js 中指定了一些要使用的路径文件。

.Express 展示端组件图
[plantuml, target=img/diagram-component-2025-05-09-103145, format=png]
....
@startuml
package app.js {

    package Directory {
        folder public {
            file css
            file img
            file js
        }
        folder views {
            file index.html
        }
        folder config {
            file jwtSecretKey.js
        }
    }
}
@enduml
....
</t>
<t tx="swot.20250509073027.2">Q: Why introduce an interface when the frontend can just connect directly to the backend in the diagram? Isn’t it redundant? +
问：上图中直接用前端连接后端就可以了，为什么还需要中间来个 interface？是多此一举吗？

A: It’s not redundant, but rather a clearer way to express the system’s structure and separation of concerns. +
答：不算是多此一举**，而是更清晰地表达系统的结构和职责分离。
上图中直接用前端连接后端就可以了，为什么还需要中间来个 interface？是多次一举吗？

***

**1. Why need interface？**

In a component diagram, the interface defines the communication contract between components to clarify architecture. +
在**组件图（Component Diagram）**中，`interface` 的作用是明确**组件之间的通信契约**，让架构更清晰，主要有以下几个原因：

**Decoupling（解耦）**：

- If the Frontend depends directly on the Backend, it requires knowledge of the backend's implementation. +
如果 `Frontend` 直接依赖 `Backend`，说明 `Frontend` 需要知道 `Backend` 的具体实现。

- With API_Interface, the frontend only relies on the API contract and not on backend details. +
**引入 `API_Interface`（接口）后，前端只关心 API 规范，不依赖后端的具体实现**，这样如果后端更换实现方式（如从 `Node.js` 换成 `Spring Boot`），前端无须修改。

**Explicit Role（明确角色）**：

- The frontend cares about the APIs it needs, not which backend provides them. +
  `Frontend` 需要某些 API，它不关心 API 由哪个后端提供。
- The backend may expose different APIs, and interfaces help identify which are for frontend use. +
  `Backend` 可能有多个 API，对外暴露的是 `API_Interface`，这样可以清晰地区分哪些 API 是暴露给前端的，哪些是内部 API。

**Extensibility（扩展性）**：

In future, if there are multiple backend versions like BackendV2, they can implement the same interface. +
如果未来有多个后端实现，比如 `BackendV2`，它们都可以实现相同的 `API_Interface`，前端仍然可以无缝调用 API。

[plantuml, target=img/diagram-component-2025-05-09-100211, format=png]
....
@startuml
component "Frontend" as Frontend
interface "API interface" as API_Interface
component "Backend API v1" as BackendV1
component "Backend API v2" as BackendV2

Frontend ..&gt; API_Interface
BackendV1 --&gt; API_Interface
BackendV2 --&gt; API_Interface
@enduml
....

Now the frontend can switch between BackendV1 and BackendV2 without modifying its code. +
现在，前端可以在 `BackendV1` 和 `BackendV2` 之间自由切换，而无需修改自身代码。

**2. When can you omit the interface?** 什么时候可以省略 interface？

If the system has only one backend and the API won’t change, you can connect Frontend -&gt; Backend directly. +
如果你的系统**只有一个后端实现，并且不会更换 API 结构**，确实可以直接连接 `Frontend -&gt; Backend`。比如：

[plantuml, target=img/diagram-component-2025-05-09-100245, format=png]
....
component "Frontend" as Frontend
component "Backend API" as Backend
Frontend .&gt; Backend : Call API
....

However, this has poor scalability compared to using interfaces. +
但是这种方式在系统扩展性上**没有 `interface` 方案好**，如果未来有多个后端实现或 API 结构变化，前端代码可能需要大改。


**3. Best practices for component diagrams ** 组件图的最佳实践

* Small projects: If the frontend only talks to one backend, you can omit the interface. +
  小型项目：如果 `Frontend` 只与单个 `Backend` 交互，**可以省略 `interface`**。
* Medium/large projects: If multiple backends or clear API boundaries exist, it’s better to use interface. +
  中大型项目：如果 API 由多个 `Backend` 提供，或 API 设计需要清晰的边界，**建议使用 `interface`**。
</t>
<t tx="swot.20250509073027.3">@language asciidoc
在 **PlantUML 组件图（Component Diagram）** 中，**虚线（`..&gt;`）和实线（`--|&gt;`）的含义不同**。

**1. 虚线（`..&gt;`）**
**表示“依赖关系”（Dependency）**
用于表示 **一个组件使用或调用另一个组件**，但它们**不是强绑定**关系。

[plantuml, target=img/diagram-component-2025-05-09-100502, format=png]
....
@startuml
component "前端" as Frontend
interface "API 接口" as API_Interface

Frontend .&gt; API_Interface : 依赖 API
@enduml
....

**含义：** `Frontend` 依赖 `API_Interface`，但 `Frontend` **不一定知道 `API_Interface` 的实现细节**。

**2. 实线（`--&gt;`）**
**表示“实现关系”（Realization）**
用于表示 **一个组件实现了某个接口**（通常用于后端实现 API）。

[plantuml, target=img/diagram-component-2025-05-09-100635, format=png]
....
@startuml
interface "API 接口" as API_Interface
component "后端 API" as Backend

Backend -&gt; API_Interface : 实现 API
@enduml
....

**含义：** `Backend` 提供 `API_Interface` 规范的实现。

**3. 结合示例**

.完整的组件图
[plantuml, target=img/diagram-component-2025-05-09-100733, format=png]
....
@startuml
component "前端" as Frontend
interface "API 接口" as API_Interface
component "后端 API" as Backend

Frontend .&gt; API_Interface : 依赖 API
API_Interface &lt;- Backend  : 实现 API
@enduml
....

**解释：**

1. `Frontend ..&gt; API_Interface`（虚线）：前端**调用** API，但不关心后端的具体实现。
2. `pass:[Backend --&gt; API_Interface]`（实线）：后端**实现** API 规范。
</t>
<t tx="swot.20250509073027.4">在 **组件图（Component Diagram）** 中，`package` 用于**组织组件**，类似于 Java、Python 中的包（namespace）。

[plantuml, target=img/diagram-componet-2025-05-09-103223, format=png]
....
@startuml
package "前端" {
  component "Vue.js 组件" as Vue
  component "UI 组件库" as UI
  Vue ..&gt; UI
}

package "后端" {
  component "express.js API" as API
  interface "API 接口" as API_Interface
  API --&gt; API_Interface
}

package "数据库" {
  database "MySQL"
}

Vue ..&gt; API_Interface
API --&gt; MySQL
@enduml
....

**解释**

1. **`package "前端"`**：表示前端相关的组件，比如 Vue.js 和 UI 组件库。
2. **`package "后端"`**：表示后端的 API，使用 `interface` 定义 API 规范。
3. **`package "数据库"`**：表示数据库存储层。
4. **前端（Vue.js）调用 API（虚线）**，后端 API 实现接口（实线）。
5. **API 连接 MySQL**（数据存储）。后端 API 直接执行 SQL 查询，所以用实线。

---

**什么时候用 `package`？**

✅ 需要**分组**组件时，比如：

- 按照 **前端 / 后端 / 数据库** 组织组件。
- 按照 **微服务 / 模块** 结构化展示。

✅ 需要**增强可读性**，避免组件杂乱无章。如果你的系统有很多组件，**用 `package` 可以让图更加清晰**。
</t>
<t tx="swot.20250509073027.5">在软件开发中，**Component（组件）** 类似于 **模块化的软件单元**，它通常对应于以下概念：  

**1. 模块（Module）**

   - 在前端：Vue 组件（`&lt;MyComponent /&gt;`）、React 组件、Nuxt 模块等。
   - 在后端：Express 路由模块、Spring Boot 服务模块等。
   - 在 Node.js：使用 `require` 或 `import` 导入的模块。

**2. 类（Class）**

   - 在面向对象编程（OOP）中，一个 `component` 可以对应一个 `class`，比如 `UserService`、`DatabaseConnector` 这样的类。

**3. 微服务（Microservice）**

   - 在微服务架构中，每个独立的微服务可以被看作一个组件，比如 `用户管理服务`、`订单处理服务` 等。

**4. 库（Library）或 SDK**

   - 例如 `Axios`（HTTP 请求库）、`Nuxt UI`（组件库），这些也可以用 `component` 表示它们的功能单元。

---

**总结**

- **小范围**：`component` 类似 **前端组件**、**类**、**模块**。
- **大范围**：它也可以表示 **微服务** 或 **系统的某个独立部分**。

所以在 `PlantUML` 组件图中，`component` 主要是用来表示 **可复用的软件单元**，并展示它们之间的关系！
</t>
<t tx="swot.20250509073027.6">@language asciidoc
[plantuml, target=img/diagram-comonent-dayu-2025-05-09-103243, format=png]
....
@startuml
'left to right direction

file "HomePage /" as root
file "router/clint_home.js" as home
file "config/db.js" as db
file "views/index.html" as index

package "controllers/client_homeController.js" as homeCtl {
    component "exports clientHome" as clientHome {
        portout resp
        interface "currentVisit"
        interface "manySQLQuery" #Yellow
        interface "manySQLResult"
        interface "Menu"
    }
    interface "queryFromDatabase()" as queryFromDatabase
    interface "generateMenu()" as generateMenu
    interface "buildThirdLevelMenu()" as buildThirdLevelMenu
    interface "generateMenu3()" as generateMenu3
}

root ..&gt; home
home ..&gt; homeCtl

manySQLResult ..&gt; generateMenu
generateMenu .up.&gt; buildThirdLevelMenu
generateMenu ..&gt; Menu

manySQLResult ..&gt; generateMenu3
generateMenu3 ..&gt; Menu

manySQLQuery ..&gt; queryFromDatabase: 大量查询
queryFromDatabase ..&gt; db: 获取数据
queryFromDatabase ..&gt; manySQLResult
manySQLResult ..&gt; currentVisit: 包含访问量
currentVisit ..&gt; db: 保存访问量

manySQLResult ..&gt; resp: 部分返回
Menu ..&gt; resp
resp ..&gt; index
'index ..&gt; root

@enduml
....
</t>
<t tx="swot.20250509073027.7">@language asciidoc
.Express 展示端组件图
[plantuml, target=img/diagram-component-2025-05-09-102755, format=png]
....
@startuml

package app.js {

    package "router_1" {
        component Industries_list
        component Solutions_list
        component Customization_list
        component CompanyInformation_list
        component NewsandEvents_list
        component Support_list

        file "router/clint_news_list.js" as news

        Industries_list ..&gt; news
        Solutions_list ..&gt; news
        Customization_list ..&gt; news
        CompanyInformation_list .up.&gt; news
        NewsandEvents_list .up.&gt; news
        Support_list .up.&gt; news
    }
}
@enduml
....
</t>
<t tx="swot.20250509073027.8">@language asciidoc
.Express 展示端组件图
[plantuml, target=img/diagram-component-2025-05-09-103024, format=png]
....
@startuml

package app.js {

    package "router_2" {
        component Industries_detail
        component Solutions_detail
        component Customization_detail
        component CompanyInformation_detail
        component NewsandEvents_detail
        component Support_detail

        file "router/clint_news_detail.js" as news_detail

        Industries_detail ..&gt; news_detail
        Solutions_detail ..&gt; news_detail
        Customization_detail ..&gt; news_detail
        CompanyInformation_detail .up.&gt; news_detail
        NewsandEvents_detail .up.&gt; news_detail
        Support_detail .up.&gt; news_detail
    }
}
@enduml
....
</t>
<t tx="swot.20250509073027.9">@language asciidoc
.Express 展示端组件图
[plantuml, target=img/diagram-component-2025-05-09-103049, format=png]
....
@startuml
left to right direction

package app.js {

    package "router_3" {
        component product_list
        component product_detail
        component CoreBusiness_list
        component search_list
        component email_form
        component cookies_form
        component 404

        file "router/clint_case_list.js" as case
        file "router/clint_case_detail.js" as case_detail
        file "router/clint_search_list.js" as search
        file "route/clint_404" as fof
        file "route/clint_email_form.js" as email
        file "route/clint_cookies_form.js" as cookies

        product_list ..&gt; case
        product_detail ..&gt; case_detail
        CoreBusiness_list ..&gt; case

        search_list ..&gt; search
        404 ..&gt; fof
        email_form ..&gt; email
        cookies_form ..&gt; cookies
    }
}
@enduml
....
</t>
<t tx="swot.20250509104746.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032352d30322d32327103752e">部署图（Deployment Diagram） 使用 node 表示服务器或运行环境，database 表示数据库，artifact 表示可执行文件等。

.link:img/diagram-deployment-2025-05-09-110113.png[deployment]
[plantuml, target=img/diagram-deployment-2025-05-09-110113, format=png]
....
@startuml

node "Nginx 服务器" {
    component "Nginx"
}

node "Web 服务器" {
    component "Node.js"
    component "Express.js"
}

node "数据库服务器" {
    database "MySQL"
}

node "前端客户端" {
    component "Vue.js"
}

"Vue.js" ..&gt; "Nginx" : 访问网站
"Nginx" ..&gt; "Node.js" : 反向代理
"Node.js" ..&gt; "MySQL" : 读写数据

@enduml
....

====
- `node "Web 服务器"`：表示一个物理服务器。
    * 在UML部署图中，Node 通常表示硬件或硬件平台，或者是一个可以执行软件的物理设备。
- `component "Node.js"`：表示在该服务器上运行的 Node.js 应用。
- `database "MySQL"`：表示数据库服务器上的 MySQL 实例。
- 组件之间用 `..&gt;` 连接，表示访问或交互关系。
====
</t>
<t tx="swot.20250509104746.2">.link:img/diagram-deployment-2025-05-09-110102.png[Official website deployment]
[plantuml, target=img/diagram-deployment-2025-05-09-110102, format=png]
....
@startuml
node "Ubuntu Linux" {

    folder Webhook {
        artifact "6 Language Front"
        artifact "Admin"
    }

    package "Node.js 运行环境" {
        package "Express Front" as express{
            component "Express.js"
            component "Templates"
            "Templates" -&gt; "Express.js": 强绑定
        }
        package "Nuxt Admin" as nuxt {
            component "Vue.js"
            component "Nitro.js"
        }
    }
    component "Nginx"
    database  "MySQL"

    "Nginx" ..&gt; "express": 反向代理
    "Nginx" ..&gt; "nuxt" : 反向代理

    "Nitro.js" --&gt; "MySQL"
    "Express.js" --&gt; "MySQL"

    "Vue.js" .&gt; "Nitro.js": restful
    "Vue.js" ..&gt; "Express.js": 访问部分api

}

cloud gitee
component "浏览器" as browser

Webhook --&gt; gitee
nuxt -&gt; Webhook
express -&gt; Webhook

browser --&gt; Nginx
@enduml
....
</t>
<t tx="swot.20250509111441.1">.link:img/diagram-wbs-2025-05-09-111742.svg[wbs]
[plantuml, target=img/diagram-wbs-2025-05-09-111742, format=svg]
....
@startwbs
scale 1.2
* Business Process Modelling WBS
** Launch the project
*** Complete Stakeholder Research
*** Initial Implementation Plan
** Design phase
*** Model of AsIs Processes Completed
**** Model of AsIs Processes Completed1
**** Model of AsIs Processes Completed2
*** Measure AsIs performance metrics
*** Identify Quick Wins
** Complete innovate phase
@endwbs
....
</t>
<t tx="swot.20250509113701.1">https://mermaid.js.org/

安装 mermaid-cli:

    npm install -g @mermaid-js/mermaid-cli

查看是否安装成功:

    which mmdc  # 在 Linux/macOS 上
    where mmdc  # 在 Windows 上


.link:img/mermaid-2025-05-09-113732.png[Example1]
[mermaid, target=img/mermaid-2025-05-09-113732, format=png]
....
graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
....


.link:img/mermaid_2025-05-09-113741.png[Example2]
[mermaid, target=img/mermaid_2025-05-09-113741, format=png]
....
sequenceDiagram
    participant Client
    participant Middleware
    participant API Handler

    Client-&gt;&gt;Middleware: 发起请求
    Middleware-&gt;&gt;Middleware: 执行前置逻辑
    Middleware-&gt;&gt;API Handler: 自动路由匹配
    API Handler-&gt;&gt;Middleware: 返回原始数据
    Middleware-&gt;&gt;Middleware: 包装为标准格式
    Middleware-&gt;&gt;Client: 发送最终响应
....
</t>
<t tx="swot.20250509155424.1">https://docs.asciidoctor.org/diagram-extension/latest/diagram_types/barcode/

Install:

    gem install barby
    gem install rqrcode
    gem install chunky_png


Barcdodes can be written codabar:A31117013206375A[target=img/codabar-2025-05-09-162333, format=png, height=15] inline or as blocks.
link:img/codabar-2025-05-09-162333.png[Show codabar]


.link:img/qrcode-2025-05-09-162345.png[Show qrcode]
[qrcode, target=img/qrcode-2025-05-09-162345, format="png", xdim=4, foreground=#199, role="text-left"]
....
Hello World!
....


.link:img/code128-2025-05-09-162354.png[Show code128]
[code128, target=img/code128-2025-05-09-162354, format="png", xdim=2, height=30, foreground=#199]
....
A31117013206375A
....

</t>
<t tx="swot.20250509164220.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032352d30312d33307103752e">Install

    npm install -g vega-cli vega-embed vega-lite vega-themes vega

Edit ~/.zshrc

    export PATH="$PATH:$(npm config get prefix)/bin"
    export NODE_PATH=$(npm root -g)
</t>
<t tx="swot.20250509164220.2">.link:img/vegalite_2025-05-09-165945.png[vegalite_example1]
[vegalite, target=img/vegalite_2025-05-09-165945, format=png]
....
{
  "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
  "description": "A simple bar chart",
  "data": {
    "values": [
      {"category": "A", "value": 28},
      {"category": "B", "value": 55},
      {"category": "C", "value": 43}
    ]
  },
  "mark": "bar",
  "encoding": {
    "x": {"field": "category", "type": "nominal"},
    "y": {"field": "value", "type": "quantitative"}
  }
}
....

</t>
<t tx="swot.20250509164220.3">.link:img/vegalite-2025-05-09-170329.png[vegalite_example2]
[vegalite, target=img/vegalite-2025-05-09-170329, format=png]
....
{
  "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
  "config": {"view": {"stroke": ""}},
  "width": 800,
  "height": 200,
  "data": {
    "values": [
      {"country": "Great Britain", "animal": "cattle", "col": 3},
      {"country": "Great Britain", "animal": "cattle", "col": 2},
      {"country": "Great Britain", "animal": "cattle", "col": 1},
      {"country": "Great Britain", "animal": "pigs", "col": 2},
      {"country": "Great Britain", "animal": "pigs", "col": 1},
      {"country": "Great Britain", "animal": "sheep", "col": 10},
      {"country": "Great Britain", "animal": "sheep", "col": 9},
      {"country": "Great Britain", "animal": "sheep", "col": 8},
      {"country": "Great Britain", "animal": "sheep", "col": 7},
      {"country": "Great Britain", "animal": "sheep", "col": 6},
      {"country": "Great Britain", "animal": "sheep", "col": 5},
      {"country": "Great Britain", "animal": "sheep", "col": 4},
      {"country": "Great Britain", "animal": "sheep", "col": 3},
      {"country": "Great Britain", "animal": "sheep", "col": 2},
      {"country": "Great Britain", "animal": "sheep", "col": 1},
      {"country": "United States", "animal": "cattle", "col": 9},
      {"country": "United States", "animal": "cattle", "col": 8},
      {"country": "United States", "animal": "cattle", "col": 7},
      {"country": "United States", "animal": "cattle", "col": 6},
      {"country": "United States", "animal": "cattle", "col": 5},
      {"country": "United States", "animal": "cattle", "col": 4},
      {"country": "United States", "animal": "cattle", "col": 3},
      {"country": "United States", "animal": "cattle", "col": 2},
      {"country": "United States", "animal": "cattle", "col": 1},
      {"country": "United States", "animal": "pigs", "col": 6},
      {"country": "United States", "animal": "pigs", "col": 5},
      {"country": "United States", "animal": "pigs", "col": 4},
      {"country": "United States", "animal": "pigs", "col": 3},
      {"country": "United States", "animal": "pigs", "col": 2},
      {"country": "United States", "animal": "pigs", "col": 1},
      {"country": "United States", "animal": "sheep", "col": 7},
      {"country": "United States", "animal": "sheep", "col": 6},
      {"country": "United States", "animal": "sheep", "col": 5},
      {"country": "United States", "animal": "sheep", "col": 4},
      {"country": "United States", "animal": "sheep", "col": 3},
      {"country": "United States", "animal": "sheep", "col": 2},
      {"country": "United States", "animal": "sheep", "col": 1}
    ]
  },
  "mark": {"type": "point", "filled": true},
  "encoding": {
    "x": {"field": "col", "type": "ordinal", "axis": null},
    "y": {"field": "animal", "type": "ordinal", "axis": null},
    "row": {"field": "country", "header": {"title": ""}},
    "shape": {
      "field": "animal",
      "type": "nominal",
      "scale": {
        "domain": ["person", "cattle", "pigs", "sheep"],
        "range": [
          "M1.7 -1.7h-0.8c0.3 -0.2 0.6 -0.5 0.6 -0.9c0 -0.6 -0.4 -1 -1 -1c-0.6 0 -1 0.4 -1 1c0 0.4 0.2 0.7 0.6 0.9h-0.8c-0.4 0 -0.7 0.3 -0.7 0.6v1.9c0 0.3 0.3 0.6 0.6 0.6h0.2c0 0 0 0.1 0 0.1v1.9c0 0.3 0.2 0.6 0.3 0.6h1.3c0.2 0 0.3 -0.3 0.3 -0.6v-1.8c0 0 0 -0.1 0 -0.1h0.2c0.3 0 0.6 -0.3 0.6 -0.6v-2c0.2 -0.3 -0.1 -0.6 -0.4 -0.6z",
          "M4 -2c0 0 0.9 -0.7 1.1 -0.8c0.1 -0.1 -0.1 0.5 -0.3 0.7c-0.2 0.2 1.1 1.1 1.1 1.2c0 0.2 -0.2 0.8 -0.4 0.7c-0.1 0 -0.8 -0.3 -1.3 -0.2c-0.5 0.1 -1.3 1.6 -1.5 2c-0.3 0.4 -0.6 0.4 -0.6 0.4c0 0.1 0.3 1.7 0.4 1.8c0.1 0.1 -0.4 0.1 -0.5 0c0 0 -0.6 -1.9 -0.6 -1.9c-0.1 0 -0.3 -0.1 -0.3 -0.1c0 0.1 -0.5 1.4 -0.4 1.6c0.1 0.2 0.1 0.3 0.1 0.3c0 0 -0.4 0 -0.4 0c0 0 -0.2 -0.1 -0.1 -0.3c0 -0.2 0.3 -1.7 0.3 -1.7c0 0 -2.8 -0.9 -2.9 -0.8c-0.2 0.1 -0.4 0.6 -0.4 1c0 0.4 0.5 1.9 0.5 1.9l-0.5 0l-0.6 -2l0 -0.6c0 0 -1 0.8 -1 1c0 0.2 -0.2 1.3 -0.2 1.3c0 0 0.3 0.3 0.2 0.3c0 0 -0.5 0 -0.5 0c0 0 -0.2 -0.2 -0.1 -0.4c0 -0.1 0.2 -1.6 0.2 -1.6c0 0 0.5 -0.4 0.5 -0.5c0 -0.1 0 -2.7 -0.2 -2.7c-0.1 0 -0.4 2 -0.4 2c0 0 0 0.2 -0.2 0.5c-0.1 0.4 -0.2 1.1 -0.2 1.1c0 0 -0.2 -0.1 -0.2 -0.2c0 -0.1 -0.1 -0.7 0 -0.7c0.1 -0.1 0.3 -0.8 0.4 -1.4c0 -0.6 0.2 -1.3 0.4 -1.5c0.1 -0.2 0.6 -0.4 0.6 -0.4z",
          "M1.2 -2c0 0 0.7 0 1.2 0.5c0.5 0.5 0.4 0.6 0.5 0.6c0.1 0 0.7 0 0.8 0.1c0.1 0 0.2 0.2 0.2 0.2c0 0 -0.6 0.2 -0.6 0.3c0 0.1 0.4 0.9 0.6 0.9c0.1 0 0.6 0 0.6 0.1c0 0.1 0 0.7 -0.1 0.7c-0.1 0 -1.2 0.4 -1.5 0.5c-0.3 0.1 -1.1 0.5 -1.1 0.7c-0.1 0.2 0.4 1.2 0.4 1.2l-0.4 0c0 0 -0.4 -0.8 -0.4 -0.9c0 -0.1 -0.1 -0.3 -0.1 -0.3l-0.2 0l-0.5 1.3l-0.4 0c0 0 -0.1 -0.4 0 -0.6c0.1 -0.1 0.3 -0.6 0.3 -0.7c0 0 -0.8 0 -1.5 -0.1c-0.7 -0.1 -1.2 -0.3 -1.2 -0.2c0 0.1 -0.4 0.6 -0.5 0.6c0 0 0.3 0.9 0.3 0.9l-0.4 0c0 0 -0.4 -0.5 -0.4 -0.6c0 -0.1 -0.2 -0.6 -0.2 -0.5c0 0 -0.4 0.4 -0.6 0.4c-0.2 0.1 -0.4 0.1 -0.4 0.1c0 0 -0.1 0.6 -0.1 0.6l-0.5 0l0 -1c0 0 0.5 -0.4 0.5 -0.5c0 -0.1 -0.7 -1.2 -0.6 -1.4c0.1 -0.1 0.1 -1.1 0.1 -1.1c0 0 -0.2 0.1 -0.2 0.1c0 0 0 0.9 0 1c0 0.1 -0.2 0.3 -0.3 0.3c-0.1 0 0 -0.5 0 -0.9c0 -0.4 0 -0.4 0.2 -0.6c0.2 -0.2 0.6 -0.3 0.8 -0.8c0.3 -0.5 1 -0.6 1 -0.6z",
          "M-4.1 -0.5c0.2 0 0.2 0.2 0.5 0.2c0.3 0 0.3 -0.2 0.5 -0.2c0.2 0 0.2 0.2 0.4 0.2c0.2 0 0.2 -0.2 0.5 -0.2c0.2 0 0.2 0.2 0.4 0.2c0.2 0 0.2 -0.2 0.4 -0.2c0.1 0 0.2 0.2 0.4 0.1c0.2 0 0.2 -0.2 0.4 -0.3c0.1 0 0.1 -0.1 0.4 0c0.3 0 0.3 -0.4 0.6 -0.4c0.3 0 0.6 -0.3 0.7 -0.2c0.1 0.1 1.4 1 1.3 1.4c-0.1 0.4 -0.3 0.3 -0.4 0.3c-0.1 0 -0.5 -0.4 -0.7 -0.2c-0.3 0.2 -0.1 0.4 -0.2 0.6c-0.1 0.1 -0.2 0.2 -0.3 0.4c0 0.2 0.1 0.3 0 0.5c-0.1 0.2 -0.3 0.2 -0.3 0.5c0 0.3 -0.2 0.3 -0.3 0.6c-0.1 0.2 0 0.3 -0.1 0.5c-0.1 0.2 -0.1 0.2 -0.2 0.3c-0.1 0.1 0.3 1.1 0.3 1.1l-0.3 0c0 0 -0.3 -0.9 -0.3 -1c0 -0.1 -0.1 -0.2 -0.3 -0.2c-0.2 0 -0.3 0.1 -0.4 0.4c0 0.3 -0.2 0.8 -0.2 0.8l-0.3 0l0.3 -1c0 0 0.1 -0.6 -0.2 -0.5c-0.3 0.1 -0.2 -0.1 -0.4 -0.1c-0.2 -0.1 -0.3 0.1 -0.4 0c-0.2 -0.1 -0.3 0.1 -0.5 0c-0.2 -0.1 -0.1 0 -0.3 0.3c-0.2 0.3 -0.4 0.3 -0.4 0.3l0.2 1.1l-0.3 0l-0.2 -1.1c0 0 -0.4 -0.6 -0.5 -0.4c-0.1 0.3 -0.1 0.4 -0.3 0.4c-0.1 -0.1 -0.2 1.1 -0.2 1.1l-0.3 0l0.2 -1.1c0 0 -0.3 -0.1 -0.3 -0.5c0 -0.3 0.1 -0.5 0.1 -0.7c0.1 -0.2 -0.1 -1 -0.2 -1.1c-0.1 -0.2 -0.2 -0.8 -0.2 -0.8c0 0 -0.1 -0.5 0.4 -0.8z"
        ]
      },
      "legend": null
    },
    "color": {
      "field": "animal",
      "type": "nominal",
      "legend": null,
      "scale": {
        "domain": ["person", "cattle", "pigs", "sheep"],
        "range": [
          "rgb(162,160,152)",
          "rgb(194,81,64)",
          "rgb(93,93,93)",
          "rgb(91,131,149)"
        ]
      }
    },
    "opacity": {"value": 1},
    "size": {"value": 200}
  }
}
....
</t>
<t tx="swot.20250509164220.4">如果数据太大，不方便嵌入，可以用本地 Web 服务器：

    # 数据文件放在 data 目录下，所以需要在 data 的上层目录运行下面命令
    python -m http.server 1919


.link:img/vegalite_2025-05-09-170423.png[vegalite_example3]
[vegalite, target=img/vegalite_2025-05-09-170423, format=png]
....
{
  "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
  "repeat": ["Horsepower", "Miles_per_Gallon", "Acceleration", "Displacement"],
  "columns": 2,
  "spec": {
    "data": {"url": "http://localhost:1919/data/cars.json"},
    "mark": "bar",
    "encoding": {
      "x": {"field": {"repeat": "repeat"}, "bin": true},
      "y": {"aggregate": "count"},
      "color": {"field": "Origin"}
    }
  }
}
....
</t>
<t tx="swot.20250509164220.5">.link:img/vega-2025-05-09-170457.png[vega example1]
[vega, target=img/vega-2025-05-09-170457, format=png]
....
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic grouped bar chart example.",
  "width": 300,
  "height": 240,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"category":"A", "position":0, "value":0.1},
        {"category":"A", "position":1, "value":0.6},
        {"category":"A", "position":2, "value":0.9},
        {"category":"A", "position":3, "value":0.4},
        {"category":"B", "position":0, "value":0.7},
        {"category":"B", "position":1, "value":0.2},
        {"category":"B", "position":2, "value":1.1},
        {"category":"B", "position":3, "value":0.8},
        {"category":"C", "position":0, "value":0.6},
        {"category":"C", "position":1, "value":0.1},
        {"category":"C", "position":2, "value":0.2},
        {"category":"C", "position":3, "value":0.7}
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "height",
      "padding": 0.2
    },
    {
      "name": "xscale",
      "type": "linear",
      "domain": {"data": "table", "field": "value"},
      "range": "width",
      "round": true,
      "zero": true,
      "nice": true
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "position"},
      "range": {"scheme": "category20"}
    }
  ],

  "axes": [
    {"orient": "left", "scale": "yscale", "tickSize": 0, "labelPadding": 4, "zindex": 1},
    {"orient": "bottom", "scale": "xscale"}
  ],

  "marks": [
    {
      "type": "group",

      "from": {
        "facet": {
          "data": "table",
          "name": "facet",
          "groupby": "category"
        }
      },

      "encode": {
        "enter": {
          "y": {"scale": "yscale", "field": "category"}
        }
      },

      "signals": [
        {"name": "height", "update": "bandwidth('yscale')"}
      ],

      "scales": [
        {
          "name": "pos",
          "type": "band",
          "range": "height",
          "domain": {"data": "facet", "field": "position"}
        }
      ],

      "marks": [
        {
          "name": "bars",
          "from": {"data": "facet"},
          "type": "rect",
          "encode": {
            "enter": {
              "y": {"scale": "pos", "field": "position"},
              "height": {"scale": "pos", "band": 1},
              "x": {"scale": "xscale", "field": "value"},
              "x2": {"scale": "xscale", "value": 0},
              "fill": {"scale": "color", "field": "position"}
            }
          }
        },
        {
          "type": "text",
          "from": {"data": "bars"},
          "encode": {
            "enter": {
              "x": {"field": "x2", "offset": -5},
              "y": {"field": "y", "offset": {"field": "height", "mult": 0.5}},
              "fill": [
                {"test": "contrast('white', datum.fill) &gt; contrast('black', datum.fill)", "value": "white"},
                {"value": "black"}
              ],
              "align": {"value": "right"},
              "baseline": {"value": "middle"},
              "text": {"field": "datum.value"}
            }
          }
        }
      ]
    }
  ]
}
....
</t>
<t tx="swot.20250509171442.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032352d30322d30327103752e">https://github.com/asciidoctor/asciidoctor-kroki

    $ gem install asciidoctor-kroki
    $ asciidoctor -r asciidoctor-kroki doc.adoc


[WARNING]
====
1. https://kroki.io 可能需要网络好，不然会报

    [21597:34067:0202/000442.644492:ERROR:ssl_client_socket_impl.cc(982)] handshake failed; returned -1, SSL error code 1, net_error -101

2. https://kroki.io 不能接受太大的 json 数据，会报错:

    414 Request-URI Too Large
    nginx/1.18.0 (Ubuntu) -&gt; 应该是 nginx 的限制，所以可以尝试将数据文件放在公网可以访问的网上来避免该问题（未测试）。

3. 网上 kroki 的图片，保存日期不是永久，可能在某个时刻就不能访问了。

4. 所以还是在本地使用 docker 部署 kroki 服务比较好。
   * 本地部署我还没有研究，文档在这儿 https://docs.kroki.io/kroki/setup/install/
   * 本地部署 kroki 后，不用安装那么多包了，还是很爽的。
====


.nvim doc.adoc
[vegalite, target=img/vegalite_kroki1, format=png]
....
{
  "data": {
    "values": [
      {"category": "A", "value": 28},
      {"category": "B", "value": 55},
      {"category": "C", "value": 43}
    ]
  },
  "mark": "bar",
  "encoding": {
    "x": {"field": "category", "type": "nominal"},
    "y": {"field": "value", "type": "quantitative"}
  }
}
....
</t>
<t tx="swot.20250509173942.1"></t>
<t tx="swot.20250509173947.1">对于 n 个元素的关键字序列 { k1,k2, ...kn }，当且仅当满足关系 ki ≤ k2i 且 ki ≤ k2i+1 {i=1.2...[n/2]} 时称其为小根堆(小顶堆)。

以下序列中，（ ）不是小根堆(小顶堆)。

    A 16,25,40,55,30,50,45
    B 16,40,25,50,45,30,55
    C 16,25,39,41,45,43,50
    D 16,40,25,53,39,55,45

***

这是根据完全二叉树在数组中的存储方式来判断的。小根堆是一种完全二叉树结构的堆，在顺序存储时具有以下规律：

.link:img/mermaid-2025-05-09-174131.svg[D 16,40,25,53,39,55,45]
[mermaid, target=img/mermaid-2025-05-09-174131, format=svg]
....
flowchart TD
    16((16)) --- 40((40))
    40((40)) --- 53((53))
    40((40)) ---|违反小根堆性质| 39((39))

    16((16)) --- 25((25))
    25((25)) --- 55((55))
    25((25)) --- 45((45))
....

*答案为 D*
</t>
<t tx="swot.20250509175116.1">已知一棵二叉树的先序遍历结果为 ABCDEF，中序遍历结果为 CBAEDF，则后序遍历结果为（ ）。

    A CBEFDA
    B FEDCBA
    C CBEDFA
    D 不确定

***

我们根据 **先序遍历** 和 **中序遍历** 来还原这棵二叉树，再求出它的 **后序遍历**。

.遍历就是访问树中所有节点的一种方式
****
1. **先序遍历（Preorder）**: 访问顺序：**根 → 左子树 → 右子树**

2. **中序遍历（Inorder）**: 访问顺序：**左子树 → 根 → 右子树**

3. **后序遍历（Postorder）**: 访问顺序：**左子树 → 右子树 → 根**
****

给定：

- 先序遍历（Preorder）：`A B C D E F`
- 中序遍历（Inorder）： `C B A E D F`

[discrete]
=== 步骤一：构建二叉树

先序遍历的第一个节点是根节点：

- **根节点：A**

查找 A 在中序遍历中的位置：

- 中序遍历：`C B | A | E D F`

所以 A 的左子树是 `C B`，右子树是 `E D F`。

[discrete]
==== 处理左子树：

先序遍历中 A 的左子树部分是：`B C`

- 根是 B（先序中紧跟 A 之后）
- 中序左子树为 `C B`，B 是根，C 在左边 ⇒ C 是 B 的左子

左子树构建为：

```
   B
  /
C
```

[discrete]
==== 处理右子树：

先序遍历中 A 的右子树部分是：`D E F`（剩下的）

- 根是 D（下一个未使用的先序元素）
- 中序右子树是 `E D F`

D 在中序中的位置中间，所以：

- 左子树：E
- 右子树：F

右子树构建为：

```
   D
  / \
 E   F
```

[discrete]
==== 整体树结构为：

```
       A
     /   \
    B     D
   /     / \
  C     E   F
```

[discrete]
=== 步骤二：求后序遍历（Postorder）

后序遍历顺序是：**左 → 右 → 根**

按照树结构遍历：

- 左子树（B 的子树）：C → B
  
- 右子树（D 的子树）：E → F → D
  
- 根：A

合起来是：`C B E F D A`

[discrete]
==== 答案：**A. CBEFDA**

***
</t>
<t tx="swot.20250509175355.1">若一棵哈夫曼(Huffman)树共有 9 个顶点，则其叶子结点的个数为（ ）。

    A 4
    B 5
    C 6
    D 7

答案为：B

先推个公式出来：

正确的构建流程（4 个叶子结点：A、B、C、D）：

初始结点：A、B、C、D（都是叶子）

第一步：合并权值最小的两个（比如 A 和 B）⇒ 生成中间结点 P

第二步：合并权值最小的两个（比如 C 和 D）⇒ 生成中间结点 Q

第三步：合并 P 和 Q ⇒ 得到根结点 R

树的结构应该是这样的：

        R
       / \
      P   Q
     / \ / \
    A  B C  D

总结点数验证：

- 叶子结点：A、B、C、D ⇒ 4 个

- 中间结点：P、Q、R ⇒ 3 个

- 总结点数：4 + 3 = 7 = 2×4 - 1

所以有公式: ##总结点数 = 叶子结点数 + 内部结点数 = n+(n−1) = 2n−1##

9 个顶点代入公式： 9 = 2n - 1 -&gt; n = 5
</t>
<t tx="swot.20250509180254.1">无向图中一个顶点的度是指图中与该顶点相邻接的顶点数。若无向图 G 中的顶点数为 n，边数为 e，则所有顶点的度数之和为（ ）

* A n*e 
* B n+e 
* C 2n 
* D 2e

答案：D

****

定义：在无向图中，一个顶点的度数（Degree）是指与该顶点相连的边的数量。度数是描述顶点在图中连接程度的一个重要指标。

这个题考查的是图论中无向图的一个基本性质：

在一个无向图中，所有顶点的度数之和等于边数的两倍。

原因解释：
每条边连接两个顶点，因此会被两个顶点各“贡献一次”度数。所以总的度数是边数的两倍。

设：

* 顶点数为 n
* 边数为 e
* 公式中的 vi 指顶点

则： stem:[\sum_{i=1}^{n} \deg(v_i) = 2e]
****
</t>
<t tx="swot.20250509183134.1"></t>
<t tx="swot.20250509183157.1"></t>
<t tx="swot.20250509183417.1">奇校验：原始数据增加一个校验位，使 1 的个数为奇数。

    原始数据    校验位
    10010100    0   -&gt; 1 的个数为奇数，所以校验位为 0

偶校验：原始数据增加一个校验位，使 1 的个数为偶数。

    原始数据    校验位
    10010100    1   -&gt; 1 的个数为奇数，所以校验位为 1


* 奇偶校验只有在出错二进制位个数是 #奇数# 的情况下才有效。
* 奇偶校验只能检错，不能纠错。


码字：编码后的信息单元，由若干个二进制位组成。

距离：将两个码字逐位进行对比，具有不相同的位的个数称为两个码字间的距离。

  ** 1011101 和 1001001 之间的距离是 2。

    1011101
    1001001
      x x   -&gt; 2 位不同

  ** 奇偶校验的码距为 2
     *** 以奇校验为例：如下面完整码字的任意两个奇数个 1 的码字之间，至少要改两个比特才能从一个合法码字变成另一个合法码字。所以码距是 2。
+
[caption=]
.举例说明奇校验码距为 2
[cols="1,1,1",options="header"]
|===
| 数据位 | 校验位（奇校验） | 完整码字 
| 000   | 1             | 0001 
| 001   | 0             | 0010 
| 010   | 0             | 0100 
| 011   | 1             | 0111 
| 100   | 0             | 1000 
| 101   | 1             | 1011 
| 110   | 1             | 1101 
| 111   | 0             | 1110 
|===

码距：一种编码方案可能有若干个合法码字，各合法码字间的 #最小距离# 称为“码距”。

计算（偶校验为例）：各信息位进行异或（模2加）运算，得到的结果即为「偶校验位」。

  * 如 1001101 异或结果为 0，所以偶校验位为 0。
  * 则最后发送的数据为 10011010（假设将校验位放在最后面）

验证（偶校验为例）：收到方验证数据

  * 将收到的数据 10011010 按位异或结果为 0，说明数据正确。

https://www.bilibili.com/video/BV1qp421D7B3  0:00 -&gt; 02:44
</t>
<t tx="swot.20250509184225.1">给定待发送的数据为: 101001

要求的校验码多项式为: stem:[G(x) = x^3 + x^2 + 1]

***

1. 根据多项式确定 CRC 校验码位数
  ** 因为多项式最高次幂为 3，所以校验码位数为 3。

2. 数据左移校验码位数
  ** 数据补 3 个 0 为: 101001000

3. 确定多项式的值
  ** 根据多项式确定
  stem:[G(x) = x^3 + x^2 + 1] -&gt;
  stem:[1 \cdot x^3 + 1 \cdot x^2 + 0 \cdot x^1 + 1 \cdot x^0]
  -&gt; 1101

4. 计算 CRC 值（除法异或运算）
+
  1010 01000 ÷ 1101
  1101        (生成多项式)
  ----
  01110 1000  (第一步 XOR 结果)
   1101
   ----
   001110 00  (第二步 XOR 结果)
     1101
     -----
     001100   (第三步 XOR 结果)
       1101
       ----
       0001   (CRC 余数为 1，则 3 位校验位为 001)

5. 生成发送数据 = 传输数据 + CRC校验码
  ** 101001+001 -&gt; 101001001

---
https://www.bilibili.com/video/BV1qp421D7B3

  * 从低到高举例 12:27 -&gt; end
</t>
<t tx="swot.20250509191942.1">* 可检错和纠错，海明码的标准码距是 3

* 可发现 2 位错，纠正 1 位错

* 用到了奇偶校验中的偶校验。

* ##计算 k 位数公式：stem:[2^k \geq n + k + 1]##
  ** n 为信息码长度
  ** k 为校验码长度（需要通过上面公式，自己代出来即可）
  ** ##校验码位置：stem:[2^{i-1}] ( i 从 1 -&gt; k，如1、2、4、8 )##

* ##异或校验整个海明码，都为 0 正确。##

---

视频教学

* https://www.youtube.com/watch?v=5it44QcOtQQ 从高到低举例
* https://www.bilibili.com/video/BV1qp421D7B3 从低到高举例 02:44 -&gt; 12:27
</t>
<t tx="swot.20250509191942.2">例如: 信息码 101101100，采用海明码校验，问最终海明码是多少?

1. 确定校验位数量 k，原信息码位数为 n=9，代入公式:
  * stem:[2^k \geq n+k+1]，得 stem:[2^k \geq 9+k+1]
  * 若 k=4，则 stem:[2^4 \geq 9+4+1]，即 16&gt;14，满足公式。
  * 确定校验位数量为 4 位

2. 确定校验码位置: 代入公式 stem:[2^{i-1}] ( i 从 1-&gt; k=4，得 1、2、4、8 )，即下面 k1、k2、k4、k8 的 4 个位置。
+
[plantuml, target=img/diagram-haimingcode1, format=png]
....
@startebnf
&lt;style&gt;
element {
  ebnf {
    Backgroundcolor pink
    note {
      Backgroundcolor pink
    }
  }
}
&lt;/style&gt;

校验位位置=k1(*1*),k2(*2*),"1"(*3*),k4(*4*),"0"(*5*),"1"(*6*),"1"(*7*),
k8(*8*),"0"(*9*),"1"(*10*),"1"(*11*),"0"(*12*),"0"(*13*);

@endebnf
....

3. 确定校验位与数据位对应关系
  * 即 kx 分别对应哪些数据位
+
[caption=]
[cols="6*"]
|===
2.2+^.^|校验位对应数据位表 (为1则对应)                          4+^|4个校验位
                         |k8 (9,10,11,12,13) |k4 (5,6,7,12,13) |k2 (3,6,7,10,11) |k1 (3,5,7,9,11,13)
.9+^.^|9个数据位对应校验位关系
        | 3 -&gt; 0011 -&gt; k1, k2     |0                  |0               |1                 |1
        | 5 -&gt; 0101 -&gt; k1, k4     |0                  |1               |0                 |1
        | 6 -&gt; 0110 -&gt; k2, k4     |0                  |1               |1                 |0
        | 7 -&gt; 0111 -&gt; k1, k2, k4 |0                  |1               |1                 |1
        | 9 -&gt; 1001 -&gt; k1, k8     |1                  |0               |0                 |1
        |10 -&gt; 1010 -&gt; k2, k8     |1                  |0               |1                 |0
        |11 -&gt; 1011 -&gt; k1, k2, k8 |1                  |0               |1                 |1
        |12 -&gt; 1100 -&gt; k4, k8     |1                  |1               |0                 |0
        |13 -&gt; 1101 -&gt; k1, k4, k8 |1                  |1               |0                 |1
|===

4. 计算校验位的值
  * 异或结果为 kx 的值
+
[caption=]
[cols="8*"]
|===
| k1 对应位   |3 | 5 | 7 | 9  | 11 | 13    | 异或结果为 k1
| 信息码对应值 |1 | 0 | 1 | 0  | 1  | 0  ^.^| 1
| k2 对应位   |3 | 6 | 7 | 10 | 11 |       | 异或结果为 k2
| 信息码对应值 |1 | 1 | 1 | 1  | 1  |    ^.^| 1
| k3 对应位   |5 | 6 | 7 | 12 | 13 |       | 异或结果为 k3
| 信息码对应值 |0 | 1 | 1 | 0  | 0  |    ^.^| 0
| k4 对应位   |9 | 10| 11| 12 | 13 |       | 异或结果为 k4
| 信息码对应值 |0 | 1 | 1 | 0  | 0  |    ^.^| 0
|===

5. 插入校验位 k1 k2 k4 k8
+
[plantuml, target=img/diagram-haimingcode2, format=png]
....
@startebnf
&lt;style&gt;
element {
  ebnf {
    Backgroundcolor pink
    note {
      Backgroundcolor pink
    }
  }
}
&lt;/style&gt;

插入校验位 = k1(*1*), k2(*2*),"1"(*3*),k4(*4*), "0"(*5*),"1"(*6*),"1"(*7*),k8(*8*), "0"(*9*),"1"(*10*),"1"(*11*),"0"(*12*),"0"(*13*)
           |1(*1*),  1(*2*),"1"(*3*), 0(*4*), "0"(*5*),"1"(*6*),"1"(*7*), 0(*8*), "0"(*9*),"1"(*10*),"1"(*11*),"0"(*12*),"0"(*13*);
(* 海明码为: 1110011001100 *)
@endebnf
....

6. 接收方检错和纠错判断
  * 接收方接收正确数据时: 1110011001100，按《4. 计算校验位的值》中的表进行异或（含 kx 值），都为 0 为正确。
  * 接收方接收错误数据时: 1110111001100，按《4. 计算校验位的值》中的表进行异或（含 kx 值），若有 1 为错误。
    ** 此例为数值位 5 由 0 变成了 1
    ** 如何知道是数据位 5 发生了变化？ -&gt; #将异或结果由 k8 k4 k2 k1 排序为 0 1 0 1，即是十进制的位置 5。#

+
[caption=]
[cols="8*", stripes=odd]
|===
| k1 | 3      | 5       | 7 | 9  | 11 | 13 | 异或结果
| 1  | 1      | 0 -&gt; 1  | 1 | 0  | 1  | 0  | 1 错
| k2 | 3      | 6       | 7 | 10 | 11 |    | 异或结果
| 1  | 1      | 1       | 1 | 1  | 1  |    | 0
| k4 | 5      | 6       | 7 | 12 | 13 |    | 异或结果
| 0  | 0 -&gt; 1 | 1       | 1 | 0  | 0  |    | 1 错
| k8 | 9      | 10      | 11| 12 | 13 |    | 异或结果
| 0  | 0      | 1       | 1 | 0  | 0  |    | 0
|===
</t>
<t tx="swot.20250509232901.1"></t>
<t tx="swot.20250509232946.1">设机器字长为 32 位，一个容量为 16MB 的存储器，CPU 按照半字寻址，其可寻址的单元数是（ ）。

    A 2^24
    B 2^23 正确
    C 2^22
    D 2^21

***

1. ‌明确关键概念‌

* 机器字长‌：32位，即 CPU 一次处理数据的位数为 32bit‌。
* 半字‌：字长的一半，32 位机器的半字为 16位（2字节）‌。
* 存储器容量‌：16MB = 16 × 2²⁰字节 = 2²⁴字节（因1MB = 2²⁰字节）‌。

2. ‌计算总位数‌

存储器容量需转换为位数以便后续计算：

16MB的位数‌ = 16 × 2²⁰字节 × 8位/字节 = 2²⁴ × 8位 = 2²⁷位‌。

3. ‌按半字寻址的单元数‌

* 每个半字大小‌：16位（2字节）‌。
* 总单元数‌ = 存储器总字节数 ÷ 每单元字节数 = 2²⁴字节 ÷ 2字节/单元 = 2²³单元‌。
* （或等价计算：总位数 ÷ 半字位数 = 2²⁷位 ÷ 16位/单元 = 2²³单元）

4. ‌验证与选项对比‌

* 选项B（2²³）‌与计算结果一致‌。

* 其他选项错误原因‌：

    A（2²⁴）：误用字节寻址（每单元1字节）‌。
    C（2²²）和D（2²¹）：无对应计算逻辑支持‌。

5. 通用公式：

* 可寻址单元数 = 存储器容量（字节） ÷ 每单元字节数‌

本题中：

* 每单元字节数 = 半字大小 = 2字节 → 2²⁴ ÷ 2 = 2²³‌。

通过以上步骤可清晰得出答案为‌B. 2²³‌。
</t>
<t tx="swot.20250509235804.1">某文件管理系统采用位示图(bitmap)记录磁盘的使用情况。
如果系统的字长为 32 位（指计算机一次可以处理的数据位数为32位），
磁盘物理块的大小为 4MB，物理块依次编号为：0、1、2、位示图字依次编号为：0、1、2，
那么 16385 号物理块的使用情况在位示图中的第（ ）个字中描述;
如果磁盘的容量为 1000GB，那么位示图需要（ ）个字来表示。

---

关于 16385 号物理块在位示图中的位置计算，正确的答案确实是‌**512**‌（从0开始编号），而不是511。以下是详细解释：

1. 16385 号物理块的位置计算

- 物理块编号从‌**0**‌开始，因此16385号物理块实际上是第‌**16386**‌个物理块（因为编号0是第1块）‌。
- 每个字长为 32 位，可表示 32 个物理块的状态。
- 计算：
  ** 字数 = 16386​ / 32 = 512.0625
  ** 取整数部分，得到‌**512**‌（从0开始编号的字序号）‌。

2. 1000GB 磁盘的位示图字数计算

- 磁盘容量 = 1000GB = 1000 * 1024MB = 1,024,000MB。
- 每个物理块大小 = 4MB，因此物理块总数 = 1,024,000 / 4 ​= 256,000 个。
- 每个字表示 32 个物理块，所需字数 = 32 * 256,000 = 8,000个字‌。

最终答案：

- 16385号物理块在位示图中的第‌ 512 个字中描述；
- 1000GB磁盘的位示图需要‌ 8,000 个字来表示‌。

---

*继续解释：*

&gt; 每个字长为 32 位（即一个字里有 32 个 bit），**每个 bit 表示一个物理块的状态**，而每个物理块大小为 **4MB**。

换句话说：

- 一个 bit → 表示一个 4MB 的物理块是否已被使用（0 表示空闲，1 表示占用）

- 一个 32 位的字（即 4 字节）→ 可以表示 **32 个 4MB 的物理块** 的使用情况；

- 所以：一个字可管理的总磁盘空间为：`32 × 4MB = 128MB`。

举个简单：

假设磁盘只有 128MB，块大小是 4MB，那么：

- 总共有 `128 ÷ 4 = 32` 个块；
- 只需要一个 32 位的字（4 字节）就能用位示图来表示这 32 个块的使用情况。

总结：“每个字长为 32 位，可表示 32 个物理块的状态”指的是：

- **每个位对应一个 4MB 的物理块**。
</t>
<t tx="swot.20250510083353.1">设用 2K×4 位的存储器芯片组成 16K×8 位的存储器（地址单元为 0000H~3FFFH，每个芯片的地址空间连续)，则地址单元 *0B1FH* 所在芯片的最小地址编号为（ ）。

*A* 0000H; *B* 0800H; *C* 2000H; *D* 2800H;

先分析问题：

***

1. 什么是「2K×4位的芯片」？

- 「2K」表示有 **2 × 1024 = 2048** 个地址单元
- 「4位」表示每个地址单元存的是 **4位数据**（半个字节）

2. 我们要做一个「16K × 8位」的存储器

- 「16K」表示有 **16 × 1024 = 16384** 个地址单元
- 每个地址要存 **8 位数据**（1 个字节）

---

*怎么用小芯片拼出大存储器？*

现在有很多个「2K × 4位」的小芯片。要拼成「16K × 8位」的存储器：

第一步：数据宽度

- 每个芯片只有 4 位，但我们需要 8 位 → 所以 **要用两个芯片拼起来**
- 一个管高 4 位，一个管低 4 位，所以每个地址要用 **2 个芯片**。

第二步：地址数量

- 每个芯片能放 2K 个地址，但我们需要 16K 个地址，所以需要
 16K / 2K = **8 组地址区间**

每组地址，需要 2 个芯片（见上一步），所以总共是：**8 组 × 2 个芯片 = 16 个芯片**。

---

看看题目问什么？

&gt; 地址单元 0B1FH（十六进制）是在哪个芯片中？这个芯片的起始地址是多少？

把 0B1F₁₆ 换成十进制 `0B1F₁₆ = 2847₁₀`，然后我们看一下每组芯片的地址范围是多大：

- 每组是 2K 地址 → 2048 个地址

所以地址分组是这样的：

[caption=]
[cols="^1,1",options="header"]
|===
| 区块编号 | 地址范围（十六进制）
| 0   | 0000H ~ 07FFH -&gt; (0000 ~ 2047)
| 1   | 0800H ~ 0FFFH -&gt; (2048 ~ 4095)
| 2   | 1000H ~ 17FFH -&gt; (4096 ~ 6143)
| ……  | ……
| 7   | 3800H ~ 3FFFH -&gt; (14335 ~ 16383)
|===

那 0B1F 属于哪组？

看看 0B1F 在不在 0800H ~ 0FFFH 里？ +
是的！属于 **第 1 组**（编号为 1）

---
所以这个芯片的最小地址是：**0800H**，最后答案是：**B. 0800H**。
</t>
<t tx="swot.20250510111143.1">某指令流水线由 4 段组成，各段所需要的时间如下图所示。连续输入 8 条指令时的吞吐率(单位时间内流水线所完成的任务数或输出的结果数)为()

[graphviz, target="img/graphviz-2025-05-10-120508", format=svg]
....
digraph pipeline {
    rankdir=LR;
    node [shape=box];
    start [label="", width=0, height=0, shape=none];
    end   [label="", width=0, height=0, shape=none];

    start -&gt; dt1 -&gt; dt2 -&gt; dt3 -&gt; dt4 -&gt; end;
    start [label=""];
    dt1 [label="Δt"];
    dt2 [label="2Δt"];
    dt3 [label="3Δt"];
    dt4 [label="Δt"];
}
....

A. 8/56Δt
B. 8/32Δt
C. 8/28Δt
D. 8/24Δt

****
根据题目描述，某指令流水线由4段组成，各段所需时间分别为Δt、2Δt、3Δt、Δt。连续输入8条指令时的吞吐率计算如下：

. 流水线周期‌：由最长段决定，即3Δt。
. 总执行时间‌：
  * 第一条指令完成时间 = 各段时间和 = Δt + 2Δt + 3Δt + Δt = 7Δt。
  * 后续7条指令每间隔一个周期（3Δt）完成，因此**总时间 = 7Δt + 7×3Δt = 28Δt**。
. 吞吐率‌：完成任务数（8条）除以总时间（28Δt），即 ‌8/28Δt‌。

因此，正确答案为 ‌C‌。
****
</t>
<t tx="swot.20250510115002.1">https://graphviz.org/download/

Install:

    brew install graphviz


.state machine 状态机
[graphviz, target="img/graphviz-2025-05-10-115048", format=svg]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape = doublecircle]; 2;
    node [shape = circle];

    0 -&gt; 1 [label = "ε"];
    1 -&gt; 2;
}
....

***

.instruction pipeline 指令流水线
[graphviz, target="img/graphviz-2025-05-10-120508", format=svg]
....
digraph pipeline {
    rankdir=LR;
    node [shape=box];
    start [label="", width=0, height=0, shape=none];
    end   [label="", width=0, height=0, shape=none];

    start -&gt; dt1 -&gt; dt2 -&gt; dt3 -&gt; dt4 -&gt; end;
    start [label=""];
    dt1 [label="Δt"];
    dt2 [label="2Δt"];
    dt3 [label="3Δt"];
    dt4 [label="Δt"];
}
....
</t>
<t tx="swot.20250510124842.1">// 编译原理，上下有好几集 https://www.bilibili.com/video/BV1TQ4y1D7Vk

下图所示为一个不确定有限自动机(NFA)的状态转换图，与该 NFA 等价的 DFA 是 ()

.解析：NFA 正规集 0 (0|11*) 0 -&gt; *答案为 C*
[graphviz, target="img/graphviz-2025-05-10-125143-NFA", format=svg]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape = doublecircle]; S5;
    node [shape = circle];
    start [label="", width=0, height=0, shape=none];

    start -&gt; S0;
    S0 -&gt; S1 [label = "0"];
    S1 -&gt; S4 [label = "0"];
    S1 -&gt; S2 [label = "ε"];
    S2 -&gt; S3 [label = "1"];
    S3 -&gt; S2 [label = "ε"];
    S3 -&gt; S4 [label = "ε"];
    S4 -&gt; S5 [label = "0"];
}
....

IMPORTANT: DFA 不允许有 ε 空输入。

.选项 A -&gt; 正规集为 01*0;
[graphviz, target="img/graphviz-2025-05-10-125311-A", format=svg]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape=doublecircle, label=""]; End
    node [shape = circle];
    start [label="", width=0, height=0, shape=none];

    start -&gt; S0;
    S0 -&gt; S1  [label = "0"];
    S1 -&gt; S1  [label = "1"];
    S1 -&gt; End [label = "0"];
}
....

.选项 B -&gt; 正规集为 001*0
[graphviz, target="img/graphviz-2025-05-10-125444-B", format=svg]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape=doublecircle, label=""]; End
    node [shape = circle];
    start [label="", width=0, height=0, shape=none];

    start -&gt; S0;
    S0 -&gt; S1  [label = "0"];
    S1 -&gt; S2  [label = "0"];
    S2 -&gt; S2  [label = "1"];
    S2 -&gt; End [label = "0"];
}
....

.选项 C -&gt; 正规集为 0(0|11*)0
[graphviz, target="img/graphviz-2025-05-10-125457-C", format=svg]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape=doublecircle, label=""]; End
    node [shape = circle];
    start [label="", width=0, height=0, shape=none];

    start -&gt; S0;
    S0 -&gt; S1  [label = "0"];
    S1 -&gt; S2  [label = "0"];
    S1 -&gt; S2  [label = "1"];
    S2 -&gt; S2  [label = "1"];
    S2 -&gt; End [label = "0"];
}
....

.选项 D -》 正规集为 01*00
[graphviz, target="img/graphviz-2025-05-10-125519-D", format=svg]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape=doublecircle, label=""]; End
    node [shape = circle];
    start [label="", width=0, height=0, shape=none];

    start -&gt; S0;
    S0 -&gt; S1  [label = "0"];
    S1 -&gt; S2  [label = "0"];
    S1 -&gt; S1  [label = "1"];
    S2 -&gt; End [label = "0"];
}
....
</t>
<t tx="swot.20250510130542.1"></t>
<t tx="swot.20250510130542.2">已知函数 f()、g()）的定义如下所示，调用函数 f 时传递给形参 x 的值是 5。 +

* 若 g(a) 采用**引用调用（callbyreference）**方式传递参数，则函数 f 的返回值为（请作答此空）；

* 若 g(a) 采用**值调用（callbyvalue）**的方式传递参数，则函数 f 的返回值（ ）。

* 其中，表达式 “x&gt;&gt;1” 的含义是将 x 的值右移 1 位，相当于 x 除以 2。

.f(int x)
[source,c]
----
int a = x &gt;&gt; 1;
g(a);
return a + x;
----

.g(int x)
[source,c]
----
x = x * (x + 1);
return;
----

选项:

* A 35
* B 32
* C 11
* D 7

答案: 第一空为 C; 第二空为 D

****
- 传值调用：形参取的是实参的值，形参的改变不会导致调用点所传的实参的值发生改变。
- 引用（传址）调用：形参取的是实参的地址，即相当于实参存储单元的地址引用，因此其值的改变同时就改变了实参的值。

1. 本题中，a=x&gt;&gt;1，x 值为 5，右移操作相当于除以 2，如果结果出现小数部分，则自动向下取整，所以 a=2；
2. 采用传值调用时，由于 g(a) 对数据 x 的运算不会影响原来 x 的值，所以 a + x = 2 + 5 = 7；
3. 采用引用调用时，由于 g(a) 对数据 x 的运算会影响原来 x 的值，当执行 g(a) 后 x 的值为 6，所以 a + x = 6 + 5 = 11 。
****
</t>
<t tx="swot.20250510131711.1"></t>
<t tx="swot.20250510131821.1">设有关系模式 R（课程，教师，学生，成绩，时间，教室），其中函数依赖集 F 如下：

    F＝{
         课程 -&gt;-&gt; 教师，
        (学生，课程) -&gt; 成绩，
        (时间，教室) -&gt; 课程，
        (时间，教师) -&gt; 教室，
        (时间，学生) -&gt; 教室
    }

问题：

* 关系模式 R 的一个主键是 （1）
* R 规范化程度最高达到 （2）
* 若将关系模式 R 分解为三个关系模式

    R1（课程，教师）
    R2（学生，课程，成绩）
    R3（学生，时间，教室，课程 ），

其中 R2 的规范化程度最高达到 （3） 。

***

[discrete]
==== 该题目简化版为

我们有一个表格 `R`，包含6个字段：
‌**课程、教师、学生、成绩、时间、教室**‌，已知这些字段之间有如下关联规则（函数依赖）：

1. 一门课程可能对应多个教师（课程→→教师）
2. 学生+课程可以确定成绩（学生,课程→成绩）
3. 时间+教室可以确定课程（时间,教室→课程）
4. 时间+教师可以确定教室（时间,教师→教室）
5. 时间+学生可以确定教室（时间,学生→教室）

问题：

1. ‌**主键是什么？**‌
2. ‌**这个表格设计最高满足第几范式（1NF/2NF/3NF/BCNF）？**‌
3. ‌**如果把表格拆成三个小表，其中 R2(学生,课程,成绩) 最高满足第几范式？**‌

---

[discrete]
==== 第一步：找主键（问题1）

‌**主键**‌ 是能唯一确定一行数据的最小字段组合。**怎么找？**‌
尝试用最少的字段组合，看看能否推导出所有其他字段。

‌**候选组合：`(时间,学生)`**‌

- 已知 `时间+学生→教室`（规则5）
- 已知 `时间+教室→课程`（规则3）→ 所以 `时间+学生→课程`
- 已知 `学生+课程→成绩`（规则2）→ 所以 `时间+学生→成绩`
- 课程 -&gt;-&gt; 教师（规则1，但教师是多值依赖，不影响主键）

✅ ‌**结论**‌：`(时间,学生)` 能推出所有字段，是主键。

---

[discrete]
==== 第二步：判断范式（问题2）

‌**范式升级路线**‌：1NF → 2NF → 3NF → BCNF → 4NF
我们逐步检查：

1. ‌**1NF**‌：表格没有重复列（比如没有“电话1,电话2”这种），每个字段都是不可再分的原子数据项，满足 ✅

2. ‌**2NF**‌：要求所有非主属性（成绩、教室、课程、教师）必须‌**完全依赖**‌主键（不能只依赖主键的一部分）。

  - 主键是 `(时间,学生)`，它由两个字段组成。
  - 检查是否有字段只依赖`时间`或只依赖`学生`？
    - `成绩`依赖`(学生,课程)`，而`课程`又依赖`(时间,学生)` → 间接完全依赖主键 ✅
    - `教室`直接依赖`(时间,学生)` ✅
    - `教师`依赖`课程`（多值依赖），但`课程`依赖主键 ✅
  - 满足2NF ✅
3. ‌**3NF**‌：要求非主属性‌**不能传递依赖**‌主键（即不能有 A→B→C 这种链式依赖）。

  - 发现传递依赖：
    `(时间,学生)→教室`，且`(时间,教室)→课程` → 即 `(时间,学生)→教室→课程` ❌
  - 还有多值依赖 `课程→→教师` ❌
  - ‌**不满足3NF**‌，最高到2NF。

---

[discrete]
==== 第三步：分解后的R2范式（问题3）

分解后的小表 `R2(学生,课程,成绩)`：

- ‌**函数依赖**‌：`(学生,课程)→成绩`
- ‌**主键**‌：`(学生,课程)`

检查范式：

1. ‌**1NF**‌：满足 ✅
2. ‌**2NF**‌：非主属性`成绩`完全依赖主键（没有部分依赖） ✅
3. ‌**3NF**‌：没有传递依赖（只有`(学生,课程)→成绩`一条直接依赖） ✅
4. ‌**BCNF**‌：所有依赖的左部都是候选键（这里依赖的左部`(学生,课程)`本身就是主键） ✅

✅ ‌**R2最高满足BCNF**‌。

---

[discrete]
==== 最终答案

1. 主键：‌**(时间,学生)**‌
2. 原表R最高满足：‌**2NF**‌
3. 分解后的R2最高满足：‌**BCNF**‌

---

[discrete]
==== 举个实际例子

假设有一个选课表：

[caption=]
[cols="6*",options="header"]
|===
| 时间  | 学生  | 教室  | 课程  | 教师  | 成绩
| 周一9:00 | 张三  | 101 | 数学  | 王老师 | 90
| 周一9:00 | 李四  | 101 | 数学  | 王老师 | 85
|===

- ‌**主键**‌：`(时间,学生)`（比如“周一9:00+张三”能唯一确定一行）
- ‌**问题**‌：
  * 如果王老师换了，所有相关行都要修改（数据冗余）→ 不满足3NF
  * 拆成小表后（如R2只存学生-课程-成绩），冗余消失 → 满足BCNF

---

[discrete]
==== 你需要记住的套路

1. ‌**找主键**‌：从最小字段组合出发，尝试推导所有其他字段。
2. ‌**判断范式**‌：
  - 2NF：非主属性必须完全依赖主键
  - 3NF：不能有传递依赖
  - BCNF：所有依赖的左部必须是候选键
3. ‌**多值依赖**‌（→→）需 4NF 去解决，但题目中因传递依赖先卡在2NF。

***

该视频 1NF/2NF/3NF 讲得清楚 https://www.youtube.com/watch?v=rHiyuR2bElE

image::img/Snipaste_2025-05-10_17-21-37.png[1NF-2NF-3NF,520]
</t>
<t tx="swot.20250510173155.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032352d30352d31307103752e">给定关系 R(A，B，C，D) 和关系 S(A，D，E，F)

* 若对这两个关系进行自然连接运算 R▷◁S 后的属性列有（ ）个;
* 关系代数表达式 σR.B&gt;S.F(R▷◁S) 与（ ）等价。

    A  σ2&gt;8(RxS)
    B  π1，2，3，4，7，8(σ1=5^2&gt;8^4=6(R×S)
    C  σ"2"&gt;"8"(RxS)
    D  π1，2，3，4，7，8(σ1=5^"2"&gt;"8"^4=6(RxS))

***

*理解题目中的符号和概念‌*

1. ‌关系（表）的结构‌
    * R(A, B, C, D)‌：这是一个名为 R 的表，有 4 列（属性），分别是 A, B, C, D。
    * S(A, D, E, F)‌：这是一个名为 S 的表，有 4 列（属性），分别是 A, D, E, F。

2. ‌自然连接（Natural Join, R▷◁S）‌
    * 作用‌：将两个表按照‌相同的列名‌自动连接起来，并‌合并相同名称的列‌。
    * 规则‌：
        ** 如果两个表有相同名称的列（这里是 A 和 D），则连接时只保留一份。
        ** 最终结果的列是所有‌不重复的列‌的组合。

    * 举例‌：
        ** R 的列：A, B, C, D
        ** S 的列：A, D, E, F
        ** ##自然连接后，A 和 D 只保留一份，所以结果是：A, B, C, D, E, F（共 6 列）。##

3. ‌选择运算（σ）‌
    * 作用‌：从表中筛选出满足条件的行（类似于 SQL 的 WHERE）。
    * 例如：σR.B &gt; S.F(R▷◁S) 表示从 R▷◁S 的结果中筛选出 R.B &gt; S.F 的行。

TIP: 希腊字母 σ（sigma） 的中文读音是 “西格玛”（拼音：xī gé mǎ）。
</t>
<t tx="swot.20250510173155.2">问题1‌：自然连接 R▷◁S 后有多少列？

* 我们已经知道：
    ** R 的列：A, B, C, D
    ** S 的列：A, D, E, F

* 自然连接会合并相同名称的列（A 和 D），所以结果是：
    ** A, B, C, D, E, F（共 6 列）。
</t>
<t tx="swot.20250510173155.3">问题2‌：σR.B &gt; S.F(R▷◁S) 等价于哪个选项？

* 我们需要找到一个等价的关系代数表达式。
* 题目给出的选项是：

    A: σ2&gt;8(R×S)
    B: π1,2,3,4,7,8(σ1=5∧2&gt;8∧4=6(R×S))
    C: σ"2"&gt;"8"(R×S)
    D: π1,2,3,4,7,8(σ1=5∧"2"&gt;"8"∧4=6(R×S))

*关键点‌：*

1. R×S 是‌笛卡尔积‌（Cartesian Product），即 R 和 S 的所有可能组合，会有 4 + 4 = 8 列：
    * 列顺序：R.A, R.B, R.C, R.D, S.A, S.D, S.E, S.F（即第1-8列）。

2. 自然连接 R▷◁S 实际上是：
    * 先做 R×S，
    * 然后筛选 R.A = S.A 且 R.D = S.D 的行（因为自然连接要求相同列的值相等），
    * 最后去掉重复的 A 和 D（即保留 R.A, R.B, R.C, R.D, S.E, S.F）。

3. σR.B &gt; S.F(R▷◁S) 的意思是：
    * 在自然连接的结果中，筛选 R.B &gt; S.F 的行。

*如何用 R×S 表示？‌* 我们需要：

    . 先做 R×S（8列）。
    . 筛选 R.A = S.A（即第1列 = 第5列）和 R.D = S.D（即第4列 = 第6列）。
    . 再筛选 R.B &gt; S.F（即第2列 &gt; 第8列）。
    . 最后投影需要的列（A, B, C, D, E, F，即第 1,2,3,4,7,8 列）。

对应选项‌：

π1,2,3,4,7,8(σ1=5∧2&gt;8∧4=6(R×S))（选项B）：

    1=5：R.A = S.A
    4=6：R.D = S.D
    2&gt;8：R.B &gt; S.F
    π1,2,3,4,7,8：保留 A, B, C, D, E, F。

为什么其他选项不对？‌

    A: 缺少 R.A = S.A 和 R.D = S.D 的条件。
    C: 引号错误（"2"&gt;"8" 是字符串比较，不是列号）。
    D: 引号错误（同C）。

第三步：总结答案‌

1. 自然连接 R▷◁S 后有 ‌6列‌（A, B, C, D, E, F）。
2. σR.B &gt; S.F(R▷◁S) 等价于 ‌选项B‌：
  * π1,2,3,4,7,8(σ1=5∧2&gt;8∧4=6(R×S))。
</t>
<t tx="swot.20250510173155.4">[caption=]
.R 表：
[cols="4*", width=50%]
|===
|A	 |B 	|C 	 |D
|1	 |5	 |10	 |20
|2	 |8	 |15	 |30
|===

[caption=]
.S 表：
[cols="4*", width=50%]
|===
|A |D  |E   |F
|1 |20 |100 |3
|2 |30 |200 |7
|===

自然连接 R▷◁S 的结果‌：

* 匹配 R.A = S.A 且 R.D = S.D：
** 第1行：(1,5,10,20) 和 (1,20,100,3) → (1,5,10,20,100,3)
** 第2行：(2,8,15,30) 和 (2,30,200,7) → (2,8,15,30,200,7)
* 结果：
+
[caption=]
[cols="6*", width=75%]
|===
|A |B	|C 	|D	 |E	  |F
|1 |5	|10	|20	|100	|3
|2 |8	|15	|30	|200	|7
|===

筛选 R.B &gt; S.F‌：

* 第1行：5 &gt; 3 → 保留
* 第2行：8 &gt; 7 → 保留
* 结果和上面一样。

用选项 B 的方式计算‌：

1. 先做 R×S（4 行 8 列）：
    * 第1行：(1,5,10,20,1,20,100,3)
    * 第2行：(1,5,10,20,2,30,200,7)
    * 第3行：(2,8,15,30,1,20,100,3)
    * 第4行：(2,8,15,30,2,30,200,7)

2. 筛选 1=5 且 4=6 且 2&gt;8：
    * 第1行：1=1 且 20=20 且 5&gt;3 → 保留
    * 第4行：2=2 且 30=30 且 8&gt;7 → 保留

3. 投影 1,2,3,4,7,8：
    * 第1行：(1,5,10,20,100,3)
    * 第4行：(2,8,15,30,200,7)

结果和自然连接一致。

最终答案‌

* 自然连接后的列数：‌6列‌
* 等价的关系代数表达式：‌选项B‌
</t>
<t tx="swot.20250510175502.1">数据的物理独立性和逻辑独立性分别是通过修改（ ）来完成的。

A 外模式与内模式之间的映像、模式与内模式之间的映像

B 外模式与内模式之间的映像、外模式与模式之间的映像

C 外模式与模式之间的映像、模式与内模式之间的映像

D 模式与内模式之间的映像、外模式与模式之间的映像

答案：D
</t>
<t tx="swot.20250510175912.1"></t>
<t tx="swot.20250510175912.2">符号	含义	示例：

* 实心菱形	组合（Composition）	房子包含房间

* 空心菱形	聚合（Aggregation）	班级聚合学生

* 空心三角形箭头	泛化（继承）	猫继承自动物

* 普通箭头/连线	关联	员工参与项目

</t>
<t tx="swot.20250510180235.1"></t>
<t tx="swot.20250510180303.1">考生需要掌握 OSI七层模型 的每一层的功能和作用

[caption=]
.OSI 的七层模型
[cols="2,1,4,2,2,2"]
|===
|子网 |速记  2+^|过去标准7层 |将来标准5层 |实际应用4层

.3+.^| 资源子网  |用  |FTP、SMTP、POP3(IMAP)、HTTP(s)                  |7 应用层   .3+.^|5 应用层（报文）   .3+.^|4 应用层
                |试  |数据格式转换 / 数据加解密 / 数据解压缩              |6 表示层
                |会  |建立、维护、释放、管理、控制连接                    |5 会话层

.4+.^| 通信子网  |叔 |TCP/UDP（报文段） 端到端的数据传输服务                   |4 传输层       |4 传输层（报文段）       |3 传输层（TCP/UDP）
                |网 |在路由器上实现 ICMP、ARP、RARP、IP、IGMP           |3 网络层       |3 网络层（数据报）       |2 网络层
                |链 |交换机(可以连接多个以太网的网桥)、网桥（封装成帧、差错控制CRC、流量控制ppp协议）-&gt; 一组bit  |2 数据链路层    |2 数据链路层（帧）  .2+.^|1 网络接口层
                |物 |集线器(模拟信号)、中继器(数字信号)来传输比特流-&gt;单个bit |1 物理层        |1 物理层（比特）
|===


下面是个参考图，注意理解一下概念和三要素:

image::img/osi7layer-2025-05-10-180416.png[OSI,840]
</t>
<t tx="swot.20250510180303.2">好的，以下是一些关于OSI七层模型和TCP/IP四层模型的真题，适合软件设计师考试的难度：

[discrete]
==== 选择题
1. **关于OSI模型和TCP/IP模型的描述，以下正确的是（ ）**
   A. OSI模型的传输层与TCP/IP模型的传输层功能完全相同。
   B. TCP/IP模型的网络接口层包括了OSI模型的数据链路层和物理层的功能。
   C. OSI模型的应用层和TCP/IP模型的应用层功能完全相同。
   D. TCP/IP模型比OSI模型层次更多。
   **答案：B**

2. **在OSI模型中，负责将数据分段并提供可靠传输的是（ ）**
   A. 物理层
   B. 数据链路层
   C. 网络层
   D. 传输层
   **答案：D**

3. **以下协议中，属于TCP/IP模型网络层的是（ ）**
   A. HTTP
   B. TCP
   C. IP
   D. FTP
   **答案：C**

4. **在OSI模型中，负责建立、维护和终止会话的是（ ）**
   A. 表示层
   B. 会话层
   C. 传输层
   D. 应用层
   **答案：B**

5. **以下关于TCP和UDP的描述，正确的是（ ）**
   A. TCP是无连接的协议，UDP是面向连接的协议。
   B. UDP提供可靠传输，TCP提供不可靠传输。
   C. TCP适用于对实时性要求较高的场景，UDP适用于对可靠性要求较高的场景。
   D. TCP和UDP都工作在TCP/IP模型的传输层。
   **答案：D**

[discrete]
==== 填空题
1. **在OSI模型中，负责将数据帧传输到物理介质上的是________层。**
   **答案：物理层**

2. **TCP/IP模型的________层包括了OSI模型的数据链路层和物理层的功能。**
   **答案：网络接口层**

3. **在TCP/IP模型中，负责数据包路由和转发的是________层。**
   **答案：网络层**

4. **OSI模型的________层负责数据的格式化、加密和压缩。**
   **答案：表示层**

5. **TCP/IP模型的________层提供端到端的通信服务。**
   **答案：传输层**

[discrete]
==== 简答题
1. **简述OSI七层模型中传输层的主要功能，并说明TCP和UDP的区别。**
   **答案：**
   - **传输层功能**：负责端到端的数据传输服务，包括数据分段、错误检测与纠正、流量控制等。
   - **TCP与UDP的区别**：
     - TCP是面向连接的协议，提供可靠传输，适用于对数据完整性要求较高的场景。
     - UDP是无连接的协议，提供不可靠传输，适用于对实时性要求较高的场景。

2. **OSI模型和TCP/IP模型的主要区别是什么？**
   **答案：**
   - OSI模型是理论模型，层次划分更细（七层），主要用于教学和理论研究。
   - TCP/IP模型是实际应用模型，层次更精简（四层），是现代网络通信的基石。
   - OSI模型的会话层、表示层和应用层在TCP/IP模型中被合并为应用层；OSI模型的数据链路层和物理层在TCP/IP模型中被合并为网络接口层。

3. **简述TCP/IP模型中网络接口层的主要功能。**
   **答案：**
   - 网络接口层负责网络包在物理网络中的传输，包括MAC寻址、错误检测以及通过网卡传输网络帧等。它将IP数据报封装成适合物理网络传输的帧格式，并负责将帧发送到物理介质上。
</t>
<t tx="swot.20250510182531.1"></t>
<t tx="swot.20250510182608.1">.总体:
image::img/ip-data-2025-05-10-193237.png[总体,840]

.细节:
image::img/ip-data-2025-05-10-193246.png[细节,840]


https://www.bilibili.com/video/BV1UM41167sP

https://www.bilibili.com/video/BV1Ce411N7Ph

</t>
<t tx="swot.20250510182608.2">数据报总长度4000B

.例题
image::img/ip-data-2025-05-10-193257.png[例题,840]

https://www.bilibili.com/video/BV1Ce411N7Ph
</t>
<t tx="swot.20250510182608.3">[discrete]
=== **IP 数据报分片的描述**

**题目**：假设一个 IP 数据报总长度为 4000 字节，要经过一段 MTU 为 1500 字节的链路，该 IP 数据报必须经过分片才能通过该链路。以下关于分片的描述中，正确的是（ ）

- A. 该原始 IP 数据报是 IPv6 数据报
- B. 分片后的数据报将在通过该链路后的路由器进行重组
- C. 数据报需分为三片，这三片的总长度为 4000 字节
- D. 分片中的最后一片，标志位 Flag 为 0，Offset 字段为 370

**答案**：D

---

**解析**：

- A. 选项:
+
====
* IPv6 数据报在设计上尽量避免分片。根据 IPv6 的协议规定，源端和目的端之间的链路必须能够支持至少1280字节的MTU（最大传输单元）。如果一个 IPv6 数据报的长度超过了链路的 MTU，那么在 IPv6 中，通常是由源端来处理分片问题，而不是像 IPv4 那样由中间路由器进行分片。而且，题目中提到的 4000 字节的IP数据报需要经过 MTU 为 1500 字节的链路进行分片，这种场景更符合 IPv4 的分片机制。

* IPv6 更倾向于使用路径MTU发现机制，即在数据报发送之前，通过探测路径上的最小MTU来避免分片。如果发现路径上的MTU小于数据报长度，IPv6会返回一个“分片需要但不允许分片”（Fragmentation Needed but Don't Fragment was Set）的ICMPv6错误消息，而不是像IPv4那样直接进行分片。
====

- B. 选项也是错误的。
+
====
原因分析，在 IP 协议中，无论是 IPv4 还是 IPv6，分片和重组的机制都有明确的规定：

1. **IPv4分片和重组机制**：
   - 在 IPv4 中，分片是由中间路由器完成的。当一个 IPv4 数据报的长度超过链路的 MTU 时，中间路由器会将其分割成多个较小的分片。
   - 重组则是在**最终目的主机**上完成的，而不是在中间路由器上。中间路由器只负责转发分片的数据报，不会对分片进行重组。

2. **IPv6 分片和重组机制**：
   - IPv6 尽量避免中间路由器进行分片。如果需要分片，通常是在**源端**进行分片。
   - 重组同样是在**最终目的主机**上完成的。

因此，无论是 IPv4 还是 IPv6，分片后的数据报都是在**最终目的主机**上进行重组的，而不是在中间路由器上。
====

- C. 分包后多了 2 个 20B，所以肯定大于 4000B

- D. 正确分析
+
====
- 数据报总长度为 4000 字节，IP首部通常为 20 字节，因此数据部分为 3980 字节。
- MTU为 1500 字节，减去 IP 首部后，每个分片的数据部分最大为 1480 字节。
- 分片情况如下：
  ** 第一片：20字节首部 + 1480字节数据 + 偏移 0
  ** 第二片：20字节首部 + 1480字节数据 + 偏移 185 （1480/8=185）
  ** 第三片：20字节首部 + 1020字节数据 + 偏移 370
- 最后一片的标志位 MF 为 0，表示这是最后一片。
- 偏移量为 370，表示最后一片在原始数据报中的位置。
====
</t>
<t tx="swot.20250510182608.4">[discrete]
===  **IP数据报分片计算**

**题目**：假设一个IP数据报总长度为 3000 字节，要经过一段 MTU 为 1500 字节的链路，该 IP 数据报必须经过分片才能通过该链路。该原始 IP 数据报需被分成（ ）个片，若 IP 首部没有可选字段，则最后一个片首部中的 Offset 字段为（ ）。

- A. 2
- B. 3
- C. 4
- D. 5

**答案**：B

**Offset字段选项**：

- A. 370
- B. 740
- C. 1480
- D. 2960

**答案**：A

**解析**：

- 数据报总长度为 3000 字节，IP 首部为 20 字节，数据部分为 2980 字节。
- 每个分片的最大数据部分为 1480 字节（1500 - 20）。1480/8 能除浄

- 分片情况如下：
  * 第一片：20字节首部 + 1480字节数据
  * 第二片：20字节首部 + 1480字节数据
  * 第三片：20字节首部 + 20字节数据
- 最后一片的偏移量为 370

</t>
<t tx="swot.20250510182608.5">[discrete]
=== IP 数据报分片字段的作用

**题目**：IP 数据报的分段和重装配要用到报文头部的（ ）个字段。其中，分片偏移字段（段偏置值）表示数的单位是（ ）字节；标记字段M标志（MF位）为 0 表示（ ）。

- A. 1
- B. 2
- C. 3
- D. 4

**答案**：D

- A. 4
- B. 8
- C. 1
- D. 13

**答案**：B

- A. 不能分片
- B. 允许分片
- C. 之后还有分片
- D. 最后一个分片

**答案**：D

**解析**：

- 分片需要使用 总长度、标识符、标志字段（MF位）、分片偏移字段共 4 个字段。具体解释参下面详解。
- 分片偏移字段的单位是 8 字节。
- MF 位为 0 表示这是最后一个分片。

---

IP 数据报的分段与重装配涉及以下 ‌4 个关键字段‌：

1. 总长度（Total Length）‌，16 位字段，表示数据报首部与数据部分的总长度（单位为字节），用于分片后重组数据报‌。

2. 标识符（Identification）‌，16 位字段，唯一标识同一数据报的所有分片，确保重装时归属正确‌。

3. 标记字段（Flags）‌，3 位字段，包含：

* MF（More Fragments）位‌：值为 0 时表示当前分片是最后一个分片，为 1 时表示后续还有分片‌。
* DF（Don’t Fragment）位‌：控制是否允许分片（值为 1 表示禁止分片）‌。

4. 分片偏移(Fragment Offset)，13 位字段，指示分片在原数据报中的相对位置，单位是 ‌8 字节‌（例如偏移值 1 对应实际位置 8 字节）‌。

总结‌: 题目中“报文头部的字段数”明确为 ‌4 个‌（标识符、总长度、分片偏移、标记字段）。
</t>
<t tx="swot.20250510193659.1">
image::img/ip-type-2025-05-10-193726.png[ip地址分类,720]

A类:

* 0.0.0.0 不能用（特殊IP）
* 0.255.255.255 不能用（特殊IP）
* 128-2 就剩下 126 个了

B类:

* 注意网络号是从 128.1 开始的
</t>
<t tx="swot.20250510201445.1">[cols="1,1,1,1,4"]
|===
| NetID 网络号 | HostID 主机号 | 作为源地址发送 | 作为目的地址接收 | 用途

| 全 0        | 全 0          | Y  | N  a| 1. 在本网络内，表示本机
                                            * 如尚未分配IP的设备，比如DHCP请求时 +
                                            * webserver 启动时配置为 0.0.0.0 表示本机
                                          2. 在路由表中表示默认路由，意思是“所有未匹配的流量都应该走这个路由”
| 全 0        | 特定值         | N  | Y  | 本网某个特定主机。如 0.0.0.5 表示“当前网络中的主机 5”  (#现代网络不用了#)
| 全 1        | 全 1          | N  | Y  | 本网广播地址 255.255.255.255
| 特定值       | 全 0          | N  | N  | 网络地址，表示一个网络  
| 特定值       | 全 1          | N  | Y  | 对特定网络所有主机广播地址  
| 127         | 任何非全 0/1   | Y  | Y  | 本地回环测试，回环地址  
|===
</t>
<t tx="swot.20250510201742.1">目标 IP 地址与子网掩码进行按位与(&amp;)操作，得到子网地址

image::img/ip-subnet-2025-05-10-201820.png[ip-subnet-mask, 1080]

</t>
<t tx="swot.20250510202838.1">
image::img/ip-v6-2025-05-10-202903.png[ipv6,1024]

</t>
<t tx="swot.20250510203357.1">RIP（Routing Information Protocol，路由信息协议）是一种内部网关协议（IGP），用于在小型或中等规模的自治系统（AS）内部的路由器之间交换路由信息。RIP 是最早被广泛使用的动态路由协议之一。

实际上这是应用层协议，走 UDP

RIP 报文最大为 20B * 25 + 4 = 504B

image::img/rip-2025-05-10-203457.png[rip1,1024]

image::img/rip-2025-05-10-203513.png[rip2,1024]


// https://www.bilibili.com/video/BV1184y1k76S
</t>
<t tx="swot.20250510203357.2">image::img/rip-2025-05-10-203533.png[rip-example,1024]
</t>
<t tx="swot.20250510204058.1">实际上这是应用层协议，走 TCP

https://www.bilibili.com/video/BV1xe411N7GP

image::img/RIP_OSPF_BGP-2025-05-10-204201.png[bgp,1024]

</t>
<t tx="swot.20250510204918.1">（ ）是右图的合法拓扑序列。

[graphviz, target="img/graphviz-2025-05-10-205110", format=svg]
....
digraph AOV {
    rankdir=LR;
    node [shape = circle];

    2 -&gt; 1;
    3 -&gt; 1;
    3 -&gt; 2;
    4 -&gt; 2;
    4 -&gt; 3;
    5 -&gt; 2;
    5 -&gt; 4;
    6 -&gt; 3;
    6 -&gt; 4;
}
....

    A 654321
    B 123456
    C 563421
    D 564213

答案：A

***

本题考查数据结构的基础知识。

拓扑排序是将AOV网中所有顶点排成一个线性序列的过程，并且该序列满足：若在AOV网中从顶点vi到vj有一条路径，则在该线性序列中，顶点vi必然在顶点vj之前。

对AOV网进行拓扑排序的方法如下：

(1)在AOV网中选择一个入度为零（没有前驱）的顶点且输出它；

(2)从网中删除该顶点及与该顶点有关的所有边；

(3)重复上述两步，直至网中不存在入度为零的顶点为止。

本题中只有序列“6 5 4 3 2 1”可由上述过程导出。

对有向图进行拓扑排序的结果会有两种情况：一种是所有顶点已输出，此时整个拓扑排序完成，说明网中不存在回路；另一种是尚有未输出的顶点，剩余的顶点均有前驱顶点，表明网中存在回路。
</t>
<t tx="swot.20250510214900.1">某种机器的浮点数表示格式如下(允许非规格化表示)。若阶码以补码表示，尾数以原码表示，则1000100000000001表示的浮点数是（ ）。

    1位      4位      1位      10位
     ↑        ↑       ↑        ↑
    阶符     阶码     数符      尾数

单选：

    A 2^-16 × 2^-10
    B 2^-15 × 2^-10
    C 2^-16 ×（1-2^-10）
    D 2^-15 ×（1-2^-10）

***

题干尾数是原码为：0000000001，数符是 0，这表示该尾数是负数为 2^-10 。

阶码是 0001 是补码，转换成原码是 1111，是十进制的 15，这里注意阶符是 1，这表示阶码是负数，因此该浮点数是 2^-15 ×2^-10 。

NOTE: 这个题用到了负数的补码。
</t>
</tnodes>
</leo_file>
