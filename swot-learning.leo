<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="swot.20250508123413.1"><vh>@adoc README.adoc</vh>
<v t="swot.20250508123515.1"><vh>learning contents</vh>
<v t="swot.20250508125533.1"><vh>Read document</vh></v>
<v t="swot.20250521172443.1"><vh>Learning Structure</vh></v>
<v t="swot.20250508123848.1"><vh>Asciidoctor</vh></v>
<v t="swot.20250508161823.1"><vh>Git</vh></v>
<v t="swot.20250508123546.1"><vh>LEO-Editor</vh></v>
<v t="swot.20250521144332.1"><vh>Nuxt3</vh></v>
<v t="swot.20250927110835.1"><vh>Redis</vh></v>
<v t="swot.20250508162744.1"><vh>Software-Designer</vh></v>
</v>
</v>
<v t="swot.20250906075341.1"><vh>@path docker</vh>
<v t="swot.20250906075354.1"><vh>@adoc docker.adoc</vh>
<v t="swot.20250906075409.1"><vh>Learning Docker</vh>
<v t="swot.20250906082625.1"><vh>Introduction Docker</vh></v>
<v t="swot.20250906075427.1"><vh>Install Docker</vh></v>
<v t="swot.20250906084634.1"><vh>Pull &amp; Run Redis</vh></v>
<v t="swot.20250906093952.1"><vh>Commit &amp; Save &amp; Load &amp; Run 把 redis 容器做成离线镜像包发给学生</vh></v>
<v t="swot.20250916164207.1"><vh>Pull &amp; Run MySQL</vh></v>
<v t="swot.20250921231329.1"><vh>Pull &amp; Run Nginx</vh></v>
</v>
</v>
</v>
<v t="swot.20250906101555.1" descendentVnodeUnknownAttributes="7d71005803000000302e3071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30382d333171077573732e"><vh>@path redis</vh>
<v t="swot.20250906102110.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30382d333171077573732e"><vh>@adoc Redis.adoc</vh>
<v t="swot.20250906102110.2"><vh>Redis 速览</vh>
<v t="swot.20250906102110.3"><vh>1 简介</vh></v>
<v t="swot.20250906102110.4"><vh>2 五大核心特性</vh></v>
<v t="swot.20250906102110.5"><vh>3 安装方式</vh></v>
<v t="swot.20250906102110.6"><vh>4 连接 Redis 的几种方式</vh></v>
<v t="swot.20250906102110.7"><vh>5 最常用的 20 条命令</vh></v>
<v t="swot.20250906102110.8"><vh>6 一分钟体验</vh></v>
<v t="swot.20250906102110.9"><vh>7 Redis 新手厨房：30 道命令边做边学</vh>
<v t="swot.20250906102110.10"><vh>7.1 String 类型 4 例（最简单的“键-值”）</vh></v>
<v t="swot.20250906102110.11"><vh>7.2 Hash 类型 5 例（“对象”缓存）</vh></v>
<v t="swot.20250906102110.12"><vh>7.3 List 类型 7 例（队列 / 栈）</vh></v>
<v t="swot.20250906102110.13"><vh>7.4 Set 类型 4 例（去重 / 抽奖）</vh></v>
<v t="swot.20250906102110.14"><vh>7.5 Sorted Set 类型 6 例（排行榜）</vh></v>
<v t="swot.20250906102110.15"><vh>7.6 Key 生命周期 3 例</vh></v>
<v t="swot.20250906102110.16"><vh>7.7 服务器 / 调试 6 例</vh></v>
<v t="swot.20250906102110.17"><vh>7.8 结语</vh></v>
</v>
</v>
</v>
</v>
<v t="swot.20250811154633.1"><vh>@path threejs</vh>
<v t="swot.20250812085446.1"><vh>@adoc Three.js.adoc</vh>
<v t="swot.20250812085536.1"><vh>Three.js</vh>
<v t="swot.20250812084836.1"><vh>MeshXxxMaterial 对比</vh></v>
<v t="swot.20250811160652.1"><vh>pbr 物理的渲染材质网站</vh>
<v t="swot.20250812210640.1"><vh>use download pbr</vh>
<v t="swot.20250812210658.1"><vh>@file pbr_example/light-sofa.html</vh></v>
<v t="swot.20250812215237.1"><vh>@file pbr_example/light-sofa_低功耗.html</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="swot.20250524213031.1"><vh>@path Q_and_A</vh>
<v t="swot.20250524210117.1"><vh>@adoc Q_and_A.adoc</vh>
<v t="swot.20250524214956.1"><vh>Q_and_A</vh>
<v t="swot.20250524210138.1"><vh>Nuxt3</vh>
<v t="swot.20250524210146.1"><vh>utils vs composables?</vh></v>
<v t="swot.20250524210230.1"><vh>app.config.ts vs nuxt.config.ts?</vh></v>
</v>
<v t="swot.20250528071453.1"><vh>Web</vh>
<v t="swot.20250528071457.1"><vh>http   body 3 种上传数据方式有什么不同？</vh></v>
<v t="swot.20250528073829.1"><vh>httpie body 3 种上传数据方式如何使用？</vh></v>
<v t="swot.20250528074031.1"><vh>httpie 如何显示请求和响应部分的数据</vh></v>
<v t="swot.20250602081407.1"><vh>Web 配色网站哪个好用？</vh></v>
<v t="swot.20250604113830.1"><vh>css</vh></v>
<v t="swot.20250604115240.1"><vh>Web 新框架</vh></v>
</v>
<v t="swot.20250613103138.1"><vh>Chrome</vh>
<v t="swot.20250613103144.1"><vh>打开开发者控制台模式的快捷键是什么？</vh></v>
</v>
<v t="swot.20250524210625.1"><vh>@ignore-tree Vue3</vh>
<v t="swot.20250524210629.1"><vh>ref vs reactive？</vh></v>
</v>
</v>
</v>
</v>
<v t="swot.20250508124711.1" descendentVnodeUnknownAttributes="7d710028580b000000302e302e302e322e302e3271017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d323271077573580b000000302e302e302e322e302e3371087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30322d3232710e75735809000000302e302e302e322e34710f7d71105808000000616e6e6f7461746571117d71122858080000007072696f7269747971134d0f27580a000000707269736574646174657114580a000000323032352d30312d3330711575735807000000302e302e302e3371167d71175808000000616e6e6f7461746571187d71192858080000007072696f72697479711a4d0f27580a00000070726973657464617465711b580a000000323032352d30322d3032711c7573752e"><vh>@path asciidoctor</vh>
<v t="swot.20250508105244.1" descendentVnodeUnknownAttributes="7d7100285809000000302e302e322e302e3271017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d3232710775735809000000302e302e322e302e3371087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30322d3232710e75735807000000302e302e322e34710f7d71105808000000616e6e6f7461746571117d71122858080000007072696f7269747971134d0f27580a000000707269736574646174657114580a000000323032352d30312d3330711575735805000000302e302e3371167d71175808000000616e6e6f7461746571187d71192858080000007072696f72697479711a4d0f27580a00000070726973657464617465711b580a000000323032352d30322d3032711c7573752e"><vh>@adoc asciidoctor.adoc</vh>
<v t="swot.20250508114609.1" descendentVnodeUnknownAttributes="7d7100285807000000302e322e302e3271017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d3232710775735807000000302e322e302e3371087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30322d3232710e75735805000000302e322e34710f7d71105808000000616e6e6f7461746571117d71122858080000007072696f7269747971134d0f27580a000000707269736574646174657114580a000000323032352d30312d3330711575735803000000302e3371167d71175808000000616e6e6f7461746571187d71192858080000007072696f72697479711a4d0f27580a00000070726973657464617465711b580a000000323032352d30322d3032711c7573752e"><vh>Asciidoctor</vh>
<v t="swot.20250508105234.1"><vh>asciidoctor-default.css -&gt; custom your export html</vh></v>
<v t="swot.20250508220045.1"><vh>options.rb -&gt; asciidoctor config file</vh>
<v t="swot.20250508220045.2"><vh>data-uri</vh></v>
</v>
<v t="swot.20250508224645.1" descendentVnodeUnknownAttributes="7d7100285805000000302e302e3271017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d3232710775735805000000302e302e3371087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30322d3232710e75735803000000302e34710f7d71105808000000616e6e6f7461746571117d71122858080000007072696f7269747971134d0f27580a000000707269736574646174657114580a000000323032352d30312d333071157573752e"><vh>asciidoctor-diagram local drawing</vh>
<v t="swot.20250508224817.1" descendentVnodeUnknownAttributes="7d7100285803000000302e3271017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d3232710775735803000000302e3371087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30322d3232710e7573752e"><vh>plantuml</vh>
<v t="swot.20250508230637.1"><vh>gantt</vh></v>
<v t="swot.20250508233908.1"><vh>json</vh>
<v t="swot.20250508233908.2"><vh>@ignore-node #edit data/diagram-json1.puml</vh></v>
</v>
<v t="swot.20250509073027.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d323271077573732e"><vh>component</vh>
<v t="swot.20250509073027.2"><vh>Why is the interface needed?</vh></v>
<v t="swot.20250509073027.3"><vh>上图中的虚线和实线表示一样的含义？</vh></v>
<v t="swot.20250509073027.4"><vh>组件图还可以使用 package？</vh></v>
<v t="swot.20250509073027.5"><vh>组件图中的 component 类似软件开发中的什么？</vh></v>
<v t="swot.20250509073027.6"><vh>某官网展示端组件图 home</vh></v>
<v t="swot.20250509073027.7"><vh>某官网展示端组件图 app.js -&gt; clint_news_list.js</vh></v>
<v t="swot.20250509073027.8"><vh>某官网展示端组件图 app.js -&gt; clint_news_detail.js</vh></v>
<v t="swot.20250509073027.9"><vh>某官网展示端组件图 app.js -&gt; other routes</vh></v>
<v t="swot.20250509073027.10"><vh>某官网展示端组件图 app.js -&gt; Directory</vh></v>
</v>
<v t="swot.20250509104746.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d323271077573732e"><vh>deployment</vh>
<v t="swot.20250509104746.2"><vh>某官网部署图</vh></v>
</v>
<v t="swot.20250509111441.1"><vh>WBS (Work Breakdown Structure)</vh></v>
<v t="swot.20250508232203.1"><vh>mindmap</vh></v>
<v t="swot.20250508225006.1"><vh>Salt -&gt; Draw the prototype diagram</vh></v>
<v t="swot.20250508232842.1"><vh>yaml</vh></v>
</v>
<v t="swot.20250509113701.1"><vh>mermaid</vh></v>
<v t="swot.20250510115002.1"><vh>graphviz</vh></v>
<v t="swot.20250509155424.1"><vh>Barcode</vh></v>
<v t="swot.20250509164220.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30312d333071077573732e"><vh>vega &amp; vegalite</vh>
<v t="swot.20250509164220.2"><vh>vegalite_example1 -&gt; values embedded</vh></v>
<v t="swot.20250509164220.3"><vh>vegalite_example2 -&gt; values embedded</vh></v>
<v t="swot.20250509164220.4"><vh>vegalite_example3 -&gt; local Web server supply data</vh></v>
<v t="swot.20250509164220.5"><vh>vega example1</vh></v>
</v>
</v>
<v t="swot.20250509171442.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30322d303271077573732e"><vh>asciidoctor-kroki server drawing</vh></v>
</v>
</v>
</v>
<v t="swot.20250508105043.2"><vh>@path leo-editor</vh>
<v t="swot.20250508134307.1"><vh>@adoc leo-editor.adoc</vh>
<v t="swot.20250508134351.1"><vh>Learning Leo</vh>
<v t="swot.20250508134253.1"><vh>Install leo-editor from source</vh></v>
<v t="swot.20250609210130.1"><vh>Nav Search</vh></v>
<v t="swot.20250508154257.1"><vh>Teaching by leo-editor</vh>
<v t="swot.20250508154257.3"><vh>write code</vh></v>
<v t="swot.20250508154257.2"><vh>write document</vh></v>
</v>
<v t="swot.20250831095539.1"><vh>基于 x86 的库如何在 macos arm 架构下运行</vh></v>
<v t="swot.20250831100251.1"><vh>列操作模式 rectangle</vh></v>
</v>
</v>
</v>
<v t="swot.20250508160844.1"><vh>@path git</vh>
<v t="swot.20250508161005.1"><vh>@adoc git.adoc</vh>
<v t="swot.20250508161024.1"><vh>Git</vh>
<v t="swot.20250520181051.1"><vh>git worktree</vh></v>
<v t="swot.20250520181057.1"><vh>git subtree</vh></v>
<v t="swot.20250508161032.1"><vh>git-filter-repo -&gt; delete file from all git commit</vh></v>
</v>
</v>
</v>
<v t="swot.20250511104537.1" descendentVnodeUnknownAttributes="7d7100285809000000302e312e302e392e3671017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30342d3237710775735809000000302e312e302e392e3871087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30342d3237710e7573580a000000302e312e302e31302e33710f7d71105808000000616e6e6f7461746571117d71122858080000007072696f7269747971134d0f27580a000000707269736574646174657114580a000000323032352d30342d323771157573580a000000302e312e302e31302e3671167d71175808000000616e6e6f7461746571187d71192858080000007072696f72697479711a4d0f27580a00000070726973657464617465711b580a000000323032352d30352d3031711c7573580a000000302e312e302e31302e39711d7d711e5808000000616e6e6f74617465711f7d71202858080000007072696f7269747971214d0f27580a000000707269736574646174657122580a000000323032352d30342d323771237573580c000000302e312e302e31332e352e3071247d71255808000000616e6e6f7461746571267d71272858080000007072696f7269747971284d0f27580a000000707269736574646174657129580a000000323032352d30352d3330712a7573580c000000302e312e302e31332e362e32712b7d712c5808000000616e6e6f74617465712d7d712e2858080000007072696f72697479712f4d0f27580a000000707269736574646174657130580a000000323032352d30352d333071317573580c000000302e312e302e31332e372e3071327d71335808000000616e6e6f7461746571347d71352858080000007072696f7269747971364d0f27580a000000707269736574646174657137580a000000323032352d30352d333071387573580c000000302e312e302e31332e382e3171397d713a5808000000616e6e6f74617465713b7d713c2858080000007072696f72697479713d4d0f27580a00000070726973657464617465713e580a000000323032352d30352d3330713f7573752e"><vh>@path nuxt/nuxt3</vh>
<v t="swot.20250511104555.1"><vh>Plan</vh>
<v t="swot.20250511104602.1"><vh>How to test nuxt?</vh></v>
</v>
<v t="swot.20250521145258.1" descendentVnodeUnknownAttributes="7d7100285807000000302e302e392e3671017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30342d3237710775735807000000302e302e392e3871087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30342d3237710e75735808000000302e302e31302e33710f7d71105808000000616e6e6f7461746571117d71122858080000007072696f7269747971134d0f27580a000000707269736574646174657114580a000000323032352d30342d3237711575735808000000302e302e31302e3671167d71175808000000616e6e6f7461746571187d71192858080000007072696f72697479711a4d0f27580a00000070726973657464617465711b580a000000323032352d30352d3031711c75735808000000302e302e31302e39711d7d711e5808000000616e6e6f74617465711f7d71202858080000007072696f7269747971214d0f27580a000000707269736574646174657122580a000000323032352d30342d323771237573580a000000302e302e31332e352e3071247d71255808000000616e6e6f7461746571267d71272858080000007072696f7269747971284d0f27580a000000707269736574646174657129580a000000323032352d30352d3330712a7573580a000000302e302e31332e362e32712b7d712c5808000000616e6e6f74617465712d7d712e2858080000007072696f72697479712f4d0f27580a000000707269736574646174657130580a000000323032352d30352d333071317573580a000000302e302e31332e372e3071327d71335808000000616e6e6f7461746571347d71352858080000007072696f7269747971364d0f27580a000000707269736574646174657137580a000000323032352d30352d333071387573580a000000302e302e31332e382e3171397d713a5808000000616e6e6f74617465713b7d713c2858080000007072696f72697479713d4d0f27580a00000070726973657464617465713e580a000000323032352d30352d3330713f7573752e"><vh>@adoc nuxt3.adoc</vh>
<v t="swot.20250521152152.1" descendentVnodeUnknownAttributes="7d7100285805000000302e392e3671017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30342d3237710775735805000000302e392e3871087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30342d3237710e75735806000000302e31302e33710f7d71105808000000616e6e6f7461746571117d71122858080000007072696f7269747971134d0f27580a000000707269736574646174657114580a000000323032352d30342d3237711575735806000000302e31302e3671167d71175808000000616e6e6f7461746571187d71192858080000007072696f72697479711a4d0f27580a00000070726973657464617465711b580a000000323032352d30352d3031711c75735806000000302e31302e39711d7d711e5808000000616e6e6f74617465711f7d71202858080000007072696f7269747971214d0f27580a000000707269736574646174657122580a000000323032352d30342d3237712375735808000000302e31332e352e3071247d71255808000000616e6e6f7461746571267d71272858080000007072696f7269747971284d0f27580a000000707269736574646174657129580a000000323032352d30352d3330712a75735808000000302e31332e362e32712b7d712c5808000000616e6e6f74617465712d7d712e2858080000007072696f72697479712f4d0f27580a000000707269736574646174657130580a000000323032352d30352d3330713175735808000000302e31332e372e3071327d71335808000000616e6e6f7461746571347d71352858080000007072696f7269747971364d0f27580a000000707269736574646174657137580a000000323032352d30352d3330713875735808000000302e31332e382e3171397d713a5808000000616e6e6f74617465713b7d713c2858080000007072696f72697479713d4d0f27580a00000070726973657464617465713e580a000000323032352d30352d3330713f7573752e"><vh>Nuxt Notes</vh>
<v t="swot.20250721131040.1"><vh>VSCode plugins</vh>
<v t="swot.20250721131113.1"><vh>Vue3 Snippets -&gt; Vue3 命令简写</vh></v>
<v t="swot.20250721131156.1"><vh>Vue3 VSCode Snippets -&gt; Vue3 模板简写</vh></v>
</v>
<v t="swot.20250521214125.1"><vh>@file pnpm-workspace.yaml</vh></v>
<v t="swot.20250521112440.1"><vh>@path nuxt3-basic</vh>
<v t="swot.20250520190119.1"><vh>Create a new project</vh></v>
<v t="swot.20250521194811.1"><vh>install packages</vh></v>
<v t="swot.20250522084241.1"><vh>@file nuxt.config.ts</vh></v>
</v>
<v t="swot.20250521181940.1"><vh>@path nuxt3-layout</vh>
<v t="swot.20250528153849.1"><vh>pug 语法介绍</vh></v>
<v t="swot.20250521194704.1"><vh>@file app.vue</vh></v>
</v>
<v t="swot.20250521205725.2"><vh>@path nuxt3-element-plus</vh>
<v t="swot.20250521205725.3"><vh>Install</vh></v>
<v t="swot.20250522084400.1"><vh>@file nuxt.config.ts</vh></v>
<v t="swot.20250521205725.7"><vh>@file pages/elementPlus.vue</vh></v>
<v t="swot.20250521205725.10"><vh>element-plus I18N support</vh>
<v t="swot.20250521205725.11"><vh>@file app.vue</vh></v>
</v>
<v t="swot.20250521205725.14"><vh>报错或警告处理</vh>
<v t="swot.20250521205725.15"><vh>dayjs/dayjs.min.js does not provide an export named 'default'</vh></v>
<v t="swot.20250521205725.16"><vh>Extraneous non-props attributes (data-v-inspector) were passed to component</vh></v>
</v>
</v>
<v t="swot.20250522073435.2"><vh>@path nuxt3-tailwindcss</vh>
<v t="swot.20250522073435.3"><vh>Some Urls</vh></v>
<v t="swot.20250522073435.4"><vh>VSCode plugins</vh></v>
<v t="swot.20250522125304.1"><vh>Install</vh></v>
<v t="swot.20250522084410.1"><vh>@file nuxt.config.ts</vh></v>
<v t="swot.20250526153924.1"><vh>@file assets/css/main.css</vh></v>
<v t="swot.20250522073435.6"><vh>@file pages/easy_example.vue</vh></v>
</v>
<v t="swot.20250522210521.1"><vh>@path nuxt3-font</vh>
<v t="swot.20250522210518.1"><vh>Nuxt3 字体引用《阿里巴巴普惠体》</vh>
<v t="swot.20250522210518.2"><vh>安装字体</vh>
<v t="swot.20250522213957.1"><vh>@file assets/css/main.css</vh></v>
<v t="swot.20250522210741.1"><vh>@file assets/css/main.scss</vh></v>
<v t="swot.20250521114411.1"><vh>@file nuxt.config.ts</vh></v>
</v>
<v t="swot.20250522210518.6"><vh>使用字体</vh>
<v t="swot.20250522210755.1"><vh>@file pages/tailwind/font_example.vue</vh></v>
</v>
</v>
</v>
<v t="swot.20250523083936.1"><vh>@path nuxt3-component</vh>
<v t="swot.20250526154252.1"><vh>@file assets/css/main.css</vh></v>
<v t="swot.20250523084009.1"><vh>Web Footer 页脚开发</vh>
<v t="swot.20250523151308.1"><vh>@file pages/footer.vue</vh></v>
<v t="swot.20250523151314.1"><vh>@file components/Footer.vue</vh></v>
</v>
<v t="swot.20250523171018.1"><vh>Web CookieConsent 许可页面开发</vh>
<v t="swot.20250523171023.1"><vh>@file pages/cookie.vue</vh></v>
<v t="swot.20250523171027.1"><vh>@file components/CookieConsent.vue</vh></v>
</v>
</v>
<v t="swot.20250526234255.1"><vh>@path nuxt3-sitemap</vh>
<v t="swot.20250527002101.1"><vh>静态书写 sitemap -&gt; 需要手动更新内容</vh>
<v t="swot.20250527062943.1"><vh>@file public/sitemap.xml</vh></v>
<v t="swot.20250527062947.1"><vh>@ignore-node #@edit public/sitemap.xsl</vh></v>
</v>
<v t="swot.20250527063027.1"><vh>动态生成 sitemap</vh>
<v t="swot.20250527064512.1"><vh>@file nuxt.config.ts</vh></v>
<v t="swot.20250527095653.1"><vh>@file app.vue</vh></v>
<v t="swot.20250527094846.1"><vh>@file pages/test-sitemap1.vue</vh></v>
<v t="swot.20250527095056.1"><vh>@file pages/test-sitemap2.vue</vh></v>
</v>
</v>
<v t="swot.20250527111518.1" descendentVnodeUnknownAttributes="7d7100285803000000302e3671017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30342d3237710775735803000000302e3871087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30342d3237710e7573752e"><vh>@path nuxt3-sqlite</vh>
<v t="swot.20250527112248.1"><vh>Install knex &amp; sqlite3</vh></v>
<v t="swot.20250527112425.1"><vh>@file knexfile.js</vh></v>
<v t="swot.20250527164127.1"><vh>@file migrations/20250527164201_create_users_table.js</vh></v>
<v t="swot.20250527171946.1"><vh>报错处理: Could not locate the bindings file</vh>
<v t="swot.20250527172139.1"><vh>处理方式: pnpm run build-release</vh></v>
</v>
<v t="swot.20250527181421.1"><vh>@file data/seeds/01_users.js</vh></v>
<v t="swot.20250527181548.1"><vh>@file nuxt.config.ts</vh></v>
<v t="swot.20250527181251.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30342d323771077573732e"><vh>@file shared/types/user.d.ts</vh></v>
<v t="swot.20250527181843.1"><vh>@file server/utils/db.ts</vh></v>
<v t="swot.20250527182106.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30342d323771077573732e"><vh>@file server/api/users/index.get.ts</vh></v>
</v>
<v t="swot.20250527190016.1" descendentVnodeUnknownAttributes="7d7100285803000000302e3371017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30342d3237710775735803000000302e3671087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30352d3031710e75735803000000302e39710f7d71105808000000616e6e6f7461746571117d71122858080000007072696f7269747971134d0f27580a000000707269736574646174657114580a000000323032352d30342d323771157573752e"><vh>@path nuxt3-slug</vh>
<v t="swot.20250527190349.3"><vh>例子说明</vh></v>
<v t="swot.20250527190349.4"><vh>创建迁移表并执行迁移</vh></v>
<v t="swot.20250527190445.1"><vh>@file migrations/20250527190502_add_slug_to_users.js</vh></v>
<v t="swot.20250527195548.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30342d323771077573732e"><vh>@file shared/types/user.d.ts</vh></v>
<v t="swot.20250527195648.1"><vh>@file pages/users/[slug].vue</vh></v>
<v t="swot.20250527210134.1"><vh>@file server/api/users/[slug].get.ts</vh></v>
<v t="swot.20250527223819.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d303171077573732e"><vh>@file server/api/users/index.post.ts</vh></v>
<v t="swot.20250527223814.1"><vh>@file server/api/users/id/[id].put.ts</vh></v>
<v t="swot.20250527222331.1"><vh>@file server/api/users/generate-missing-slugs.post.ts</vh></v>
<v t="swot.20250527223001.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30342d323771077573732e"><vh>@file server/api/users/index.get.ts</vh></v>
</v>
<v t="swot.20250528090941.1"><vh>@path nuxt3-server</vh>
<v t="swot.20250528091411.1"><vh>获取 body 数据</vh>
<v t="swot.20250528091447.1"><vh>x-www-form-urlencoded</vh>
<v t="swot.20250528113522.1"><vh>@file server/api/handle_urlencoded_and_json.ts</vh></v>
<v t="swot.20250528113307.1"><vh>测试发送数据格式 x-www-form-urlencoded (-f --form)</vh></v>
<v t="swot.20250528150736.1"><vh>测试发送数据格式 multipart</vh></v>
</v>
<v t="swot.20250528091447.2"><vh>raw - JSON -&gt; api 同上面 x-www-form-urlencoded</vh>
<v t="swot.20250528113522.1"></v>
<v t="swot.20250528113321.1"><vh>测试发送数据格式 json (-j --json)</vh></v>
<v t="swot.20250528151437.1"><vh>测试发送数据格式 multipart -&gt; 同上所以省略了</vh></v>
</v>
<v t="swot.20250528091441.1"><vh>multipart/form-data</vh>
<v t="swot.20250528093710.1"><vh>@file server/api/handle-multipart.ts</vh></v>
<v t="swot.20250528113332.1"><vh>测试发送数据格式 multipart 不带文件</vh></v>
<v t="swot.20250528145724.1"><vh>测试发送数据格式 multipart 携带文件</vh></v>
</v>
</v>
</v>
<v t="swot.20250528182428.1"><vh>@path nuxt3-i18n</vh>
<v t="swot.20250528191054.1"><vh>@file nuxt.config.ts</vh></v>
<v t="swot.20250528193211.1"><vh>@file pages/i18n-test-1.vue</vh></v>
<v t="swot.20250528213504.2"><vh>@file pages/about.vue</vh></v>
<v t="swot.20250528182428.9"><vh>@edit i18n/locales/en.json</vh></v>
<v t="swot.20250528182428.10"><vh>@edit i18n/locales/zh.json</vh></v>
<v t="swot.20250528182428.11"><vh>@edit i18n/locales/ru.json</vh></v>
</v>
<v t="swot.20250528215800.1" descendentVnodeUnknownAttributes="7d7100285805000000302e352e3071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d3330710775735805000000302e362e3271087d71095808000000616e6e6f74617465710a7d710b2858080000007072696f72697479710c4d0f27580a00000070726973657464617465710d580a000000323032352d30352d3330710e75735805000000302e372e30710f7d71105808000000616e6e6f7461746571117d71122858080000007072696f7269747971134d0f27580a000000707269736574646174657114580a000000323032352d30352d3330711575735805000000302e382e3171167d71175808000000616e6e6f7461746571187d71192858080000007072696f72697479711a4d0f27580a00000070726973657464617465711b580a000000323032352d30352d3330711c7573752e"><vh>@path nuxt3-casl</vh>
<v t="swot.20250528215755.1"><vh>Roles with persisted permissions</vh></v>
<v t="swot.20250530111037.1"><vh>Authentication &amp; Authorization 函数调用组件图</vh></v>
<v t="swot.20250528215755.2"><vh>pnpm 基本命令</vh></v>
<v t="swot.20250529072113.1"><vh>@ignore-node #dit package.json</vh></v>
<v t="swot.20250530202228.1"><vh>数据库迁移文件以及初始数据</vh>
<v t="swot.20250527164127.1"></v>
<v t="swot.20250527190445.1"></v>
<v t="swot.20250528223023.1"><vh>@file migrations/20250528222910_create_roles_table.js</vh></v>
<v t="swot.20250528223030.1"><vh>@file migrations/20250528222920_change_users_table.js</vh></v>
<v t="swot.20250528223034.1"><vh>@file migrations/20250528222930_create_articles_table.js</vh></v>
<v t="swot.20250528223039.1"><vh>@file migrations/20250528222940_add_status_to_users.js</vh></v>
<v t="swot.20250528215755.7"><vh>@file data/seeds/000_delete_tables.js</vh></v>
<v t="swot.20250531092921.1"><vh>@file data/seeds/100_roles.js</vh></v>
<v t="swot.20250531092450.1"><vh>@file data/seeds/101_users.js</vh></v>
</v>
<v t="swot.20250530202305.1" descendentVnodeUnknownAttributes="7d71005803000000302e3071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d333071077573732e"><vh>前后端共享工具和类型</vh>
<v t="swot.20250528215755.12" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d333071077573732e"><vh>@file shared/utils/appAbility.ts</vh></v>
<v t="swot.20250529093531.1"><vh>@file shared/types/user.d.ts</vh></v>
</v>
<v t="swot.20250530202614.1" descendentVnodeUnknownAttributes="7d71005803000000302e3271017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d333071077573732e"><vh>后端工具</vh>
<v t="swot.20250528215755.15"><vh>@file server/utils/findUserBy.ts</vh></v>
<v t="swot.20250528215755.16"><vh>@file server/utils/interpolate.ts</vh></v>
<v t="swot.20250528215755.17" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d333071077573732e"><vh>@file server/utils/permissions.ts</vh></v>
<v t="swot.20250528215755.18"><vh>@file server/utils/agordo.ts</vh></v>
</v>
<v t="swot.20250530202630.1" descendentVnodeUnknownAttributes="7d71005803000000302e3071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d333071077573732e"><vh>后端中间件</vh>
<v t="swot.20250528215755.19" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d333071077573732e"><vh>@file server/middleware/auth.ts</vh></v>
</v>
<v t="swot.20250530202535.1" descendentVnodeUnknownAttributes="7d71005803000000302e3171017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d333071077573732e"><vh>后端 api</vh>
<v t="swot.20250528215755.20"><vh>@file server/api/auth/login.post.ts</vh></v>
<v t="swot.20250529100255.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d333071077573732e"><vh>@file server/api/users/index.get.ts</vh></v>
<v t="swot.20250529100259.1"><vh>@file server/api/users/index.post.ts</vh></v>
<v t="swot.20250530224614.1"><vh>此处您还可以写 Article 的 api，我省略了</vh></v>
</v>
<v t="swot.20250715075203.1"><vh>前端权限判断方案</vh>
<v t="swot.20250715075655.1"><vh>方案一：用 Nuxt3 中间件做权限拦截</vh></v>
<v t="swot.20250715075712.1"><vh>方案二：在跳转前判断权限</vh></v>
<v t="swot.20250715075722.1"><vh>方案三：隐藏菜单+中间件双保险</vh></v>
<v t="swot.20250715075745.1"><vh>总结</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="swot.20250508162519.1" descendentVnodeUnknownAttributes="7d71005809000000302e302e302e382e3171017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d313071077573732e"><vh>@path software-designer</vh>
<v t="swot.20250508162628.1" descendentVnodeUnknownAttributes="7d71005807000000302e302e382e3171017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d313071077573732e"><vh>@adoc software-designer.adoc</vh>
<v t="swot.20250508162652.1" descendentVnodeUnknownAttributes="7d71005805000000302e382e3171017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d313071077573732e"><vh>软件设计师例题精讲上午</vh>
<v t="swot.20250509183134.1"><vh>1 数据表示</vh>
<v t="swot.20250522173932.1"><vh>1.1 原码反码补码移码</vh>
<v t="swot.20250522174032.1"><vh>根据补码计算真值</vh></v>
</v>
<v t="swot.20250510214900.1"><vh>1.2 浮点数格式</vh></v>
<v t="swot.20250509183157.1"><vh>1.3 校验码（在OSI的数据链路层）</vh>
<v t="swot.20250509183417.1"><vh>1.3.1 奇偶校验</vh></v>
<v t="swot.20250509184225.1"><vh>1.3.2 循环冗余校验码‌（CRC校验）</vh></v>
<v t="swot.20250509191942.1"><vh>1.3.3 海明码</vh>
<v t="swot.20250509191942.2"><vh>1.3.3.1 Example1 计算海明码</vh></v>
</v>
</v>
</v>
<v t="swot.20250509173942.1"><vh>2 数据结构</vh>
<v t="swot.20250518093414.1"><vh>2.1 二叉树遍历先序-中序-后序</vh>
<v t="swot.20250518101209.1"><vh>2.1.1 先序遍历</vh></v>
<v t="swot.20250518101214.1"><vh>2.1.2 中序遍历</vh></v>
<v t="swot.20250518101217.1"><vh>2.1.3 后序遍历</vh></v>
</v>
<v t="swot.20250511163631.1"><vh>2.2 二叉排序树关键码序列</vh></v>
<v t="swot.20250512170249.1"><vh>2.3 二叉树最小高度</vh></v>
<v t="swot.20250513093844.1"><vh>2.4 二叉树结点数</vh></v>
<v t="swot.20250509173947.1"><vh>2.5 二叉树小根堆</vh></v>
<v t="swot.20250509175116.1"><vh>2.6 二叉树遍历顺序</vh></v>
<v t="swot.20250516121545.1"><vh>2.7 二叉树哪个效率最差</vh></v>
<v t="swot.20250515160236.1"><vh>2.8 满二叉树判定左右孩子</vh></v>
<v t="swot.20250509175355.1"><vh>2.9 哈夫曼树(最优二叉树)公式</vh></v>
<v t="swot.20250512232041.1"><vh>2.10 哈夫曼树编码</vh></v>
<v t="swot.20250516232218.1"><vh>2.11 哈夫曼树编码计算</vh></v>
<v t="swot.20250509180254.1"><vh>2.12 无向图顶点度数之和</vh></v>
<v t="swot.20250515225119.1"><vh>2.13 无向连通图顶点和边数</vh></v>
<v t="swot.20250514192758.1"><vh>2.14 有向图邻接矩阵</vh></v>
<v t="swot.20250513121934.1"><vh>2.15 某个度的节点数</vh></v>
<v t="swot.20250510204918.1"><vh>2.16 拓扑排序</vh></v>
<v t="swot.20250511223847.1"><vh>2.17 进栈出栈</vh></v>
<v t="swot.20250515211219.1"><vh>2.18 栈的大小计算</vh></v>
<v t="swot.20250518004209.1"><vh>2.19 两栈共享空间</vh>
<v t="swot.20250518081336.1"><vh>2.19.1 先弄懂：两个栈都空时 top[1] = 1、top[2] = n</vh></v>
<v t="swot.20250518083121.1"><vh>2.19.2 再弄懂：栈1的底在 V[1]，栈 2 的底在 V[n]</vh></v>
</v>
<v t="swot.20250513144448.1"><vh>2.20 队列长度</vh></v>
<v t="swot.20250515061953.1"><vh>2.21 线性探查法解决冲突构造哈希表</vh></v>
<v t="swot.20250515113552.1"><vh>2.22 三对角矩阵</vh></v>
</v>
<v t="swot.20250511192258.1"><vh>3 算法</vh>
<v t="swot.20250511182258.1"><vh>3.1 算法策略和时间复杂度</vh>
<v t="swot.20250513200749.1"><vh>3.1.1 插入排序算法时间和空间复杂度</vh>
<v t="swot.20250513220926.1"><vh>3.1.1.1 python 插入排序--源代码</vh></v>
<v t="swot.20250514103808.1"><vh>3.1.1.2 python 插入排序--活动图</vh></v>
</v>
<v t="swot.20250514110224.1"><vh>3.1.2 快速排序算法时间和空间复杂度</vh>
<v t="swot.20250514111022.1"><vh>3.1.2.1 python 快速排序--源代码</vh></v>
<v t="swot.20250514113757.1"><vh>3.1.2.2 python 快速排序--活动图</vh></v>
</v>
<v t="swot.20250515194932.1"><vh>3.1.3 根据代码求时间复杂度</vh></v>
</v>
<v t="swot.20250520115539.1"><vh>3.2 排序</vh>
<v t="swot.20250520115554.1"><vh>3.2.1 简单选择排序（Selection Sort）</vh></v>
<v t="swot.20250516115732.1"><vh>3.2.2 快速排序初始排列</vh></v>
<v t="swot.20250514205841.1"><vh>3.2.3 猜排序算法</vh></v>
</v>
<v t="swot.20250513184634.1"><vh>3.3 背包问题</vh></v>
</v>
<v t="swot.20250510124842.1"><vh>4 状态转换机</vh>
<v t="swot.20250515224205.1"><vh>4.1 正规集识别字符种类个数</vh></v>
<v t="swot.20250520082915.1"><vh>4.2 文法推导正规集</vh></v>
</v>
<v t="swot.20250509232901.1"><vh>5 存储系统与寻址结构</vh>
<v t="swot.20250511180244.1"><vh>5.1 存储单元地址宽度</vh></v>
<v t="swot.20250513124156.1"><vh>5.2 寻址范围计算</vh></v>
<v t="swot.20250509232946.1"><vh>5.3 寻址单元数计算</vh></v>
<v t="swot.20250509235804.1"><vh>5.4 存储体系位示图 (第几个字)(多少字)</vh></v>
<v t="swot.20250510083353.1"><vh>5.5 存储地址编号</vh></v>
<v t="swot.20250511112239.1"><vh>5.6 存储时间计算</vh></v>
<v t="swot.20250511231707.1"><vh>5.7 存储器分类方式</vh></v>
<v t="swot.20250512211150.1"><vh>5.8 存储分页系统</vh>
<v t="swot.20250512220136.1"><vh>5.8.1 求物理地址</vh></v>
<v t="swot.20250512220451.1"><vh>5.8.2 求淘汰页</vh></v>
<v t="swot.20250512220520.1"><vh>5.8.3 求页帧号（接上题淘汰页）</vh></v>
</v>
<v t="swot.20250514114641.1"><vh>5.9 存储磁盘块计算</vh></v>
<v t="swot.20250514115620.1"><vh>5.10 存储磁盘读取文件时间计算</vh></v>
<v t="swot.20250516163128.1"><vh>5.11 磁盘块与缓冲区读取时间计算</vh></v>
<v t="swot.20250515063523.1"><vh>5.12 存储图片需光盘张数</vh></v>
<v t="swot.20250515075939.1"><vh>5.13 地址范围转字节数</vh></v>
<v t="swot.20250515153435.1"><vh>5.14 页式虚拟存储缺页中断分析</vh></v>
<v t="swot.20250519063453.1"><vh>5.15 多级索引文件最大长度</vh></v>
<v t="swot.20250522172243.1"><vh>5.16 数字音频存储大小</vh></v>
</v>
<v t="swot.20250510111143.1"><vh>6 指令流水线</vh>
<v t="swot.20250516063422.1"><vh>6.1 指令之扩展操作码</vh></v>
</v>
<v t="swot.20250514121040.1"><vh>7 程序优化加速比</vh></v>
<v t="swot.20250508163105.1"><vh>8 操作系统</vh>
<v t="swot.20250508163140.1"><vh>8.1 进程同步与互斥（PV 操作）</vh>
<v t="swot.20250508163626.1"><vh>8.1.1 前趋图</vh></v>
<v t="swot.20250508164139.1"><vh>8.1.2 PV 操作</vh></v>
<v t="swot.20250508192826.1"><vh>8.1.3 Example 信号量初值等于 0</vh></v>
<v t="swot.20250512073906.1"><vh>8.1.4 Example 信号量初值不等于 0</vh></v>
<v t="swot.20250520081253.1"><vh>8.1.5 信号量S的取值范围</vh></v>
</v>
<v t="swot.20250512102233.1"><vh>8.2 资源分配图（Resource Allocation Graph, RAG）</vh>
<v t="swot.20250512102652.1"><vh>8.2.1 Example 阻塞节点和死锁</vh></v>
</v>
</v>
<v t="swot.20250510131711.1" descendentVnodeUnknownAttributes="7d71005803000000302e3171017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d313071077573732e"><vh>9 数据库</vh>
<v t="swot.20250510131821.1"><vh>9.1 关系模式</vh>
<v t="swot.20250514154815.1"><vh>9.1.1 求候选键</vh></v>
<v t="swot.20250514185836.1"><vh>9.1.2 无损连接分解</vh></v>
<v t="swot.20250515144631.1"><vh>9.1.3 保持函数依赖</vh></v>
</v>
<v t="swot.20250510173155.1" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032352d30352d313071077573732e"><vh>9.2 关系代数表达式</vh>
<v t="swot.20250510173155.2"><vh>9.2.1 问题1</vh></v>
<v t="swot.20250510173155.3"><vh>9.2.2 问题2</vh></v>
<v t="swot.20250510173155.4"><vh>9.2.3 举一个具体例子‌</vh></v>
</v>
<v t="swot.20250510175502.1"><vh>9.3 数据库模式</vh></v>
<v t="swot.20250511232507.1"><vh>9.4 数据库设计</vh></v>
<v t="swot.20250515105142.1"><vh>9.5 数据库锁</vh></v>
<v t="swot.20250519092543.1"><vh>9.6 NOT EXISTS</vh>
<v t="swot.20250520064315.1"><vh>9.6.1 如何理解该 SQL</vh></v>
</v>
</v>
<v t="swot.20250510180235.1"><vh>10 网络模型</vh>
<v t="swot.20250510180303.1"><vh>10.1 OSI 七层模型与 TCP/IP 四层模型</vh>
<v t="swot.20250510180303.2"><vh>10.1.1 Example</vh></v>
</v>
<v t="swot.20250510182531.1"><vh>10.2 网络层</vh>
<v t="swot.20250510182608.1"><vh>10.2.1 IP 数据报分片</vh>
<v t="swot.20250510182608.2"><vh>10.2.1.1 Example1</vh></v>
<v t="swot.20250510182608.3"><vh>10.2.1.2 Example2</vh></v>
<v t="swot.20250510182608.4"><vh>10.2.1.3 Example3</vh></v>
<v t="swot.20250510182608.5"><vh>10.2.1.4 Example4</vh></v>
</v>
<v t="swot.20250510193659.1"><vh>10.2.2 IP 地址分类</vh></v>
<v t="swot.20250510201445.1"><vh>10.2.3 IP 地址特殊情况</vh></v>
<v t="swot.20250510201742.1"><vh>10.2.4 子网掩码计算子网号</vh>
<v t="swot.20250513074008.1"><vh>10.2.4.1 子网数计算 1</vh></v>
<v t="swot.20250513100958.1"><vh>10.2.4.2 子网数计算 2</vh></v>
</v>
<v t="swot.20250510202838.1"><vh>10.2.5 IPv6 协议</vh></v>
<v t="swot.20250510203357.1"><vh>10.2.6 RIP 协议</vh>
<v t="swot.20250510203357.2"><vh>10.2.6.1 Example</vh></v>
</v>
<v t="swot.20250510204058.1"><vh>10.2.7 BGP 协议</vh></v>
<v t="swot.20250515161644.1"><vh>10.2.8 IP 确定主机范围</vh></v>
<v t="swot.20250520155200.1"><vh>10.2.9 子网掩码</vh></v>
</v>
</v>
<v t="swot.20250510130542.1"><vh>11 编程语言</vh>
<v t="swot.20250510130542.2"><vh>11.1 C 语言</vh></v>
</v>
<v t="swot.20250511123650.1"><vh>12 软件测试</vh>
<v t="swot.20250513155441.1"><vh>12.1 Example McCabe度量法计算其环路复杂度</vh></v>
<v t="swot.20250515150959.1"><vh>12.2 等价类划分测</vh></v>
</v>
<v t="swot.20250512205329.1"><vh>13 设计模式</vh>
<v t="swot.20250515180535.1"><vh>13.1 软件过程模型</vh></v>
</v>
<v t="swot.20250510175912.1"><vh>14 UML 图</vh>
<v t="swot.20250510175912.2"><vh>14.1 类图符号</vh></v>
<v t="swot.20250511103711.1"><vh>14.2 活动图</vh>
<v t="swot.20250514132317.1"><vh>14.2.1 复杂的例子</vh></v>
</v>
<v t="swot.20250511230628.1"><vh>14.3 用例图</vh></v>
<v t="swot.20250515105738.1"><vh>14.4 UML面向对象建模</vh></v>
</v>
<v t="swot.20250514212913.1"><vh>15 信息安全</vh></v>
<v t="swot.20250511233342.1"><vh>16 专业英语</vh></v>
</v>
<v t="swot.20250812113455.1"><vh>软件设计师例题精讲下午</vh>
<v t="swot.20250812113515.1"><vh>第一题：数据流图</vh>
<v t="swot.20250812113624.1"><vh>如何保持数据流图平衡 -- 背下来</vh></v>
</v>
</v>
</v>
</v>
<v t="swot.20250521151644.1"><vh>@edit .gitignore</vh></v>
</vnodes>
<tnodes>
<t tx="swot.20250508105043.2"></t>
<t tx="swot.20250508105234.1">Find it position:

    gem contents asciidoctor | grep asciidoctor-default.css
    ~/.rvm/gems/ruby-2.7.2/gems/asciidoctor-2.0.23/data/stylesheets

Create a hard link:

    ln ~/.rvm/gems/ruby-2.7.2/gems/asciidoctor-2.0.23/data/stylesheets/asciidoctor-default.css leo-editor/
    Now I can edit asciidoctor-default.css in leo-editor.

</t>
<t tx="swot.20250508105244.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3</t>
<t tx="swot.20250508114609.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'none';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250508123413.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3

</t>
<t tx="swot.20250508123515.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'none';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250508123546.1">Leo is a PIM, IDE and outliner that accelerates the work flow of programmers, authors and web designers. 
Outline nodes may appear in more than one place, allowing multiple organizations of data within a single outline.

xref:leo-editor/leo-editor.adoc[ Read leo-editor learning Notes ]

https://leo-editor.github.io/leo-editor/[ Leo’s Home Page ]

https://github.com/leo-editor/leo-editor[ Leo's GitHub repository ]

https://groups.google.com/g/leo-editor[ Leo's forum ]

</t>
<t tx="swot.20250508123848.1">Asciidoctor is a fast, open source, text processor for parsing AsciiDoc into a document model, then converting it to output formats such as HTML 5, DocBook 5, man(ual) pages, PDF, and EPUB 3. Asciidoctor is written in the Ruby programming language.

xref:asciidoctor/asciidoctor.adoc[ Read Asciidoctor learning Notes ]

https://docs.asciidoctor.org/asciidoctor/latest/[ Asciidoctor Documentation ]
</t>
<t tx="swot.20250508124711.1"></t>
<t tx="swot.20250508125533.1">The AsciiDoc file(.adoc) is intended for online viewing, while the HTML file(.html) is for offline access.
</t>
<t tx="swot.20250508134253.1">1. Clone leo-editor source code

    git clone https://github.com/leo-editor/leo-editor.git

2. Install python3

    https://www.python.org/downloads/

3. Create a Python virtual environment

    python3 -m venv your_environment_name
    source your_environment_name/bin/activate

4. Install some packages
+
....
pip install pyqt6
pip install PyQtWebEngine
pip install docutils markdown nbformat numpy matplotlib nbconvert pygments
pip install jupyter-client==6.1.12 qtconsole // &lt;1&gt;
....
+
&lt;1&gt; for python debug in shell
NOTE: jupyter-client-7.3.4 has bug, and can't run `qtconsole`
+
.Change pip source
[NOTE]
====
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
====

5. launch leo-editor

    python launchLeo.py
</t>
<t tx="swot.20250508134307.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3</t>
<t tx="swot.20250508134351.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'none';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250508154257.1"></t>
<t tx="swot.20250508154257.2">@language asciidoc
Teaching documents are typically presented in the form of PowerPoint (PPT) files. However, PPTs are generally used for summarizing and presenting information during live sessions and should be complemented by detailed Word or Markdown files to serve as practical operational aids. 

In programming-related teaching materials, the primary source code of demonstration programs is usually included. Typically, the relevant portions of the source code are copied into the documentation. This practice introduces the challenge of ensuring that the documentation is promptly updated whenever changes are made to the source code.

Therefore, if a method could be devised to write the source code concurrently with the documentation, a significant amount of repetitive labor and time could be saved.


教学文档通常为 ppt 文件，但是 ppt 一般做为临场提纲挈领的演示，需要再配合详尽的 word 或者 markdown 文件来作为实操辅助。

在编程的教学文档里，会包含演示程序的主要源代码。通常会把需要的部分源代码复制到文档里。这样就存在源代码更改后需要再及时更改文档的问题。

所以如果能够在编写文档的同时编写源代码，将会节省大量重复劳动的时间。
</t>
<t tx="swot.20250508154257.3">@language asciidoc
When writing code, it is often necessary to add a lot of explanatory text. The commonly adopted approach is to directly write single-line comments or a large number of block comments in the code.

If these comments in the code could be formatted like an article, the effect would be much better.


在编写代码时，往往需要加入很多说明文字，经常采用的方式是直接在代码里写单行注释或者大量块注释。

如果代码里的这些注释能够有像文章一样的排版体现，效果就会好很多。
</t>
<t tx="swot.20250508160844.1"></t>
<t tx="swot.20250508161005.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3</t>
<t tx="swot.20250508161024.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'none';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250508161032.1">https://github.com/newren/git-filter-repo

Install:

    git clone https://github.com/newren/git-filter-repo.git
    cd git-filter-repo
    pip install .
    git-filter-repo --version

To **delete a specific file from all commits in a Git repository**, you can use `git-filter-repo` which is a modern and faster replacement for `git filter-branch`.

Here’s the command to delete a file from all commits:

```bash
git filter-repo --path &lt;path/to/file&gt; --invert-paths
```

Example:

To delete `secret.txt` from all history:

```bash
git filter-repo --path secret.txt --invert-paths
```

Notes:

* This permanently **removes the file from the entire Git history**, including all branches and tags.
* `--invert-paths` means "remove this path instead of keeping it".
* After running this command, you'll likely need to force-push to remote:

```bash
git push --force --all
git push --force --tags
```

&gt; ⚠️ Warning: This rewrites history. All collaborators will need to re-clone or rebase their work.

</t>
<t tx="swot.20250508161823.1">Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.

xref:git/git.adoc[ Read git learning Notes ]

https://git-scm.com/

https://git-scm.com/downloads

</t>
<t tx="swot.20250508162519.1"></t>
<t tx="swot.20250508162628.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 4
</t>
<t tx="swot.20250508162652.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250508162744.1">Now only for Chinese.

xref:software-designer/software-designer.adoc[ Read software-designer learning Notes ]

https://bm.ruankao.org.cn/sign/welcome

https://ruankaodaren.com/exam/#/

</t>
<t tx="swot.20250508163105.1"></t>
<t tx="swot.20250508163140.1"></t>
<t tx="swot.20250508163626.1">前趋图（Precedence Graph）是一种用于表示任务或进程之间执行顺序关系的图形表示方法。它通常用于项目管理、操作系统的进程调度、编译原理中的指令调度等领域，以帮助确定任务或进程的执行顺序和依赖关系。

前趋图的特点：

1. **节点（Vertices）**：图中的每个节点代表一个任务或进程。
2. **有向边（Directed Edges）**：图中的边表示任务或进程之间的依赖关系。如果存在一条从节点 A 指向节点 B 的有向边，那么它表示任务 A 必须在任务 B 之前完成。

前趋图的作用：

- **确定执行顺序**：通过分析前趋图，可以确定哪些任务可以并行执行，哪些任务必须按顺序执行。
- **避免死锁**：在操作系统中，前趋图可以帮助设计避免死锁的资源分配策略。
- **优化调度**：在编译器设计中，前趋图可以帮助优化指令的执行顺序，提高程序的执行效率。

前趋图的示例：

假设有四个任务 A、B、C、D，其中：

- 任务 A 必须在任务 B 和 C 之前完成。
- 任务 B 和 C 必须在任务 D 之前完成。

前趋图可以表示为：

```
  A
  │
  ▼
  B---C
  │    │
  ▼    ▼
    D
```

在这个图中，A 是 B 和 C 的前趋，B 和 C 是 D 的前趋。

在操作系统的进程调度中，前趋图可以帮助操作系统确定进程的执行顺序，确保系统资源的有效利用和进程的正确执行。
</t>
<t tx="swot.20250508164139.1">PV 操作是操作系统中用于进程同步与互斥的一种机制，由两部分组成：
P 操作（Proberen，荷兰语中的“测试”）和 V 操作（Verhogen，荷兰语中的“增加”）。这种机制通常与信号量（Semaphore）一起使用，信号量是一个整数变量，用于控制对共享资源的访问。

* P 操作（等待操作）

    ** P 操作用于申请资源。当一个进程需要访问共享资源时，它会执行 P操作。如果信号量的值大于 0，表示资源可用，信号量减 1，进程继续执行。如果信号量的值为 0，表示资源不可用，进程将被阻塞，直到信号量的值变为正数。

* V 操作（释放操作）

    ** V 操作用于释放资源。当一个进程完成对共享资源的访问后，它会执行 V操作。这会使信号量的值增加 1。如果此时有其他进程因为资源不可用而被阻塞，那么 V 操作会唤醒其中一个阻塞的进程，使其可以继续执行。

* 信号量的类型

    1. **整型信号量**：信号量的值可以是任意整数，用于表示资源的数量。当信号量的值为 0 时，表示没有资源可用。
    2. **二进制信号量**：信号量的值只能是 0 或 1，用于实现互斥锁。0 表示锁被占用，1 表示锁可用。

PV 操作广泛应用于操作系统中的进程同步、互斥、死锁避免等领域。例如：

- **进程同步**：确保多个进程按照特定的顺序执行。
- **互斥访问**：确保在任何时刻只有一个进程可以访问共享资源。
- **避免死锁**：通过控制资源的分配和释放，避免系统进入死锁状态。

通过合理使用 PV 操作，可以有效地管理进程间的协作和资源共享，提高系统的稳定性和效率。
</t>
<t tx="swot.20250508192826.1">进程 P1、P2、P3、P4、P5 的 link:img/graphviz-pv-2025-05-08-193314.png[前趋图] 如下：

[graphviz, target="img/graphviz-pv-2025-05-08-193314", format=svg]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape = circle];

    P1 -&gt; P3;
    P2 -&gt; P3;
    P3 -&gt; P4;
    P3 -&gt; P5;
}
....

若用 PV 操作控制进程并发执行的过程，则需要设置 4 个信号量 S1、S2、S3、S4，且信号量初值都等于零。下面 link:img/graphviz-2025-05-08-194149.png[PV图] 中 a 和 b 应分别填写（），c 和 d 应分别填写（），e 和 f 应分别填写（）。

[graphviz, target="img/graphviz-2025-05-08-194149", format=png]
....
digraph PetriNet {
    rankdir=TB;
    node [shape=circle]; P1 P2;
    node [shape=box]; P3 P4 P5 a b c d e f;
    end1 [label="", shape=circle];
    end2 [label="", shape=circle];

    P1 -&gt; a [label="P1执行"];
    P2 -&gt; b [label="P2执行"];
    c  -&gt; P3
    P3 -&gt; d [label="P3执行"];
    e -&gt; P4
    P4 -&gt; end1
    f -&gt; P5
    P5 -&gt; end2
}
....

*答案解析：*

- **a 和 b 处**：当 P1 和 P2 执行完毕后，它们需要通过执行 V 操作来增加信号量 S1 和 S2 的值，从而通知 P3 可以开始执行。因此，##a 处应填写 V(S1)，b 处应填写 V(S2)##。

- **c 和 d 处**：进程 P3 在开始执行前，需要通过执行 P 操作来检查 S1 和 S2 的值是否大于 0。如果 S1 和 S2 的值都大于 0，表示 P1 和 P2 已经执行完毕，P3 可以开始执行。因此，##c 处应填写 P(S1) 和 P(S2)##，##d 处应填写 V(S3) 和 V(S4)##。

- **e 和 f 处**：进程 P4 和 P5 在开始执行前，需要通过执行 P 操作来检查 S3 和 S4 的值是否大于 0。如果 S3 和 S4 的值都大于 0，表示 P3 已经执行完毕，P4 和 P5 可以开始执行。因此，##e 处应填写 P(S3)，f 处应填写 P(S4)##。
</t>
<t tx="swot.20250508220045.1">Purpose: It is unnecessary to change the Leo Editor source code to customize the Asciidoctor command used for generating HTML.

Asciidoctor runs in a Ruby environment, and we occasionally need to pass extra parameters. Since Leo Editor uses fixed parameters in the vr3 plugin to generate HTML, and modifying its source code repeatedly isn’t ideal, we developed the following solution.

.Find Ruby LOAD_PATH
[source,console]
----
ruby -e 'puts $LOAD_PATH'

/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/site_ruby/2.7.0
/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/site_ruby/2.7.0/x86_64-darwin21
/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/site_ruby
/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/vendor_ruby/2.7.0
/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/vendor_ruby/2.7.0/x86_64-darwin21
/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/vendor_ruby
/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/2.7.0
/Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/2.7.0/x86_64-darwin21
----

.nvim options.rb
[source,ruby]
----
begin
  require 'asciidoctor-diagram'
rescue LoadError
  warn 'asciidoctor-diagram is not installed'
end

# Not use now
#begin
#  require 'asciidoctor-kroki'
#rescue LoadError
#  warn 'asciidoctor-kroki is not installed'
#end

# use data-uri（same as -a data-uri）for embed images base64 string in html page
# Asciidoctor::DEFAULT_ATTRIBUTES['data-uri'] = ''
----

.copy options.rb to site_ruby/2.7.0
[source,console]
----
cp options.rb /Users/swot/.rvm/rubies/ruby-2.7.2/lib/ruby/site_ruby/2.7.0
----

.Then leo-editor source code only use `-r options` will be ok
[source,python]
----
command = f"{prog} {i_path} -o {o_path} -b html5 -r options"
----

[NOTE]
====
leo-editor source code `-r options` position: +
unl://LeoPyRef.leo#Code--&gt;Core classes--&gt;@file leoMarkup.py--&gt;class MarkupCommands--&gt;markup.command_helper &amp; helpers--&gt;markup.run_asciidoctor
====
</t>
<t tx="swot.20250508220045.2">This line of code:

```ruby
Asciidoctor::DEFAULT_ATTRIBUTES['data-uri'] = ''
```

enables the `data-uri` option in Asciidoctor's default attributes, which means **images will be converted to Base64 and embedded directly into the HTML** instead of being referenced by an external URL.

**Explanation**

By default, Asciidoctor generates HTML with `&lt;img&gt;` tags that load images using file paths or URLs. For example:

```html
&lt;img src="images/example.png"&gt;
```

If the `data-uri` option is enabled, Asciidoctor will convert the image files into Base64 and embed them directly in the HTML, like this:

```html
&lt;img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAA..."&gt;
```

This approach reduces external requests and is suitable for:

* Single-file HTML (e.g., offline documents)
* Better portability (no concerns about image path issues)

**Equivalent Command-Line Option**

This line of code is equivalent to running the following in the command line:

```console
asciidoctor -a data-uri myfile.adoc
```

Or setting it in the AsciiDoc document:

```adoc
:imagesdir: images
:data-uri:
```

**Why Use `Asciidoctor::DEFAULT_ATTRIBUTES`?**

`Asciidoctor::DEFAULT_ATTRIBUTES` is the global default attribute configuration. Setting `data-uri` to an empty string `''` effectively **enables** this option. When Asciidoctor processes attributes:

* If the attribute value is empty (`''`), it is treated as **enabled**
* If the attribute does not exist, it is treated as **disabled**
* If explicitly set as `data-uri=0` or `!data-uri`, it is **disabled**

**Summary**

* Enabling `data-uri` converts images to Base64 and embeds them in the HTML
* Improves document portability by avoiding missing external images
* Suitable for offline HTML documents
* Equivalent to the `-a data-uri` option

If you do not want to embed images as Base64, you can remove this line of code or explicitly disable `data-uri`:

```ruby
Asciidoctor::DEFAULT_ATTRIBUTES.delete('data-uri')
```
</t>
<t tx="swot.20250508224645.1"></t>
<t tx="swot.20250508224817.1">1. https://docs.asciidoctor.org/diagram-extension/latest/diagram_types/plantuml/
2. https://rubygems.org/gems/asciidoctor-diagram-plantuml
3. https://plantuml.com/zh/
4. https://plantuml.com/

安装 plantuml:

    gem install asciidoctor-diagram-plantuml

</t>
<t tx="swot.20250508225006.1">.link:img/diagram-salt-2025-05-08-225243.png[common prototype]
[plantuml, target=img/diagram-salt-2025-05-08-225243, format=png]
....
@startsalt
scale 1.5
{
  Just plain text
  [This is my button]
  ()  Unchecked radio
  (X) Checked radio
  []  Unchecked box
  [X] Checked box
  "Enter text here   "
  ^This is a droplist^
}
@endsalt
....

.link:img/diagram-salt-2025-05-08-225302.png[prototype in flow]
[plantuml, target=img/diagram-salt-2025-05-08-225302, format=png]
....
@startuml
start
repeat :read data;
  :generate diagrams;
repeat while (\n{{\nsalt\n{^"Next step"\n  Do you want to continue? \n[Yes]|[No]\n}\n}}\n)
stop
@enduml
....
</t>
<t tx="swot.20250508230637.1">.link:img/diagram-gantt-2025-05-08-230846.png[gantt]
[plantuml, target=img/diagram-gantt-2025-05-08-230846, format=png]
....
@startgantt
scale 1.5
'skinparam dpi 300
saturday are closed
sunday are closed

Project starts the 1st of january 2021
[Prototype design end] as [TASK1] requires 19 days
[TASK1] is colored in Lavender/LightBlue
[Testing] requires 14 days
[TASK1]-&gt;[Testing]

2021-01-18 to 2021-01-22 are named [End's committee]
2021-01-18 to 2021-01-22 are colored in salmon 
@endgantt
....
</t>
<t tx="swot.20250508232203.1">.link:img/diagram-mindmap-2025-05-08-232219.png[mindmap]
[plantuml, target=img/diagram-mindmap-2025-05-08-232219, format=png]
....
@startmindmap
* Creole on Mindmap
left side
**:==Creole
  This is **bold**
  This is //italics//
  This is ""monospaced""
  This is --stricken-out--
  This is __underlined__
  This is ~~wave-underlined~~
--test Unicode and icons--
  This is &lt;U+221E&gt; long
  This is a &lt;&amp;code&gt; icon
  Use image : &lt;img:https://plantuml.com/logo3.png&gt;
;
**: &lt;b&gt;HTML Creole 
  This is &lt;b&gt;bold&lt;/b&gt;
  This is &lt;i&gt;italics&lt;/i&gt;
  This is &lt;font:monospaced&gt;monospaced&lt;/font&gt;
  This is &lt;s&gt;stroked&lt;/s&gt;
  This is &lt;u&gt;underlined&lt;/u&gt;
  This is &lt;w&gt;waved&lt;/w&gt;
  This is &lt;s:green&gt;stroked&lt;/s&gt;
  This is &lt;u:red&gt;underlined&lt;/u&gt;
  This is &lt;w:#0000FF&gt;waved&lt;/w&gt;
-- other examples --
  This is &lt;color:blue&gt;Blue&lt;/color&gt;
  This is &lt;back:orange&gt;Orange background&lt;/back&gt;
  This is &lt;size:20&gt;big&lt;/size&gt;
;
right side
**:==Creole line
You can have horizontal line
----
Or double line
====
Or strong line
____
Or dotted line
..My title..
Or dotted title
//and title... //
==Title==
Or double-line title
--Another title--
Or single-line title
Enjoy!;
**:==Creole list item
**test list 1**
* Bullet list
* Second item
** Sub item
*** Sub sub item
* Third item
----
**test list 2**
# Numbered list
# Second item
## Sub item
## Another sub item
# Third item
;
@endmindmap
....
</t>
<t tx="swot.20250508232842.1">plantuml show yaml structure， for example Spring Boot's application.yml.
https://plantuml.com/zh/yaml

.link:img/diagram-yaml-2025-05-08-232919.png[yaml]
[plantuml, target=img/diagram-yaml-2025-05-08-232919, format=png]
....
@startyaml
spring:
  application:
    name: mybatis_quickstart-crud
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/general_manager
    username: root
    password: root
  servlet:
    multipart:                  # 上传文件
      max-file-size: 10MB     # 指定单个文件上传的大小
      max-request-size: 100MB  # 指定单次请求上传文件的总大小

mybatis:
  configuration:
    # 指定mybatis输出日志的位置, 输出控制台
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
    #开启驼峰命名自动映射，即从经典数据库列名 a_column 映射到经典 Java 属性 名 aColumn
    map-underscore-to-camel-case: true

# --- 阿里云 OSS ---
# 与之对应引用为 @Vaule("${aliyun.oss.endpoint}")
aliyun:
  oss:
    endpoint: "https://oss-cn-beijing.aliyuncs.com"
    accessKeyId: "LQAI5tJ3drn2qkNAGZrxwpnC"
    accessKeySecret: "cMJ6XHSntg361NsN6swGVlyB0Sks84"
    bucketName: "swot-learn"
@endyaml
....
</t>
<t tx="swot.20250508233908.1">@language asciidoc
Example: Using different styles for highlight -&gt; link:data/diagram-json1.puml[show json source]
Ref: https://plantuml.com/zh/json

    [plantuml, img/diagram-json-2025-05-08-233937, format=png]
    ----
    include::data/diagram-json1.puml[]
    ----

.link:img/diagram-json-2025-05-08-233937.png[draw json image]
[plantuml, img/diagram-json-2025-05-08-233937, format=png]
----
include::data/diagram-json1.puml[]
----
</t>
<t tx="swot.20250508233908.2">@startjson
&lt;style&gt;
  .h1 {
    BackGroundColor green
    FontColor white
    FontStyle italic
  }
  .h2 {
    BackGroundColor red
    FontColor white
    FontStyle bold
  }
&lt;/style&gt;
#highlight "lastName"
#highlight "address" / "city" &lt;&lt;h1&gt;&gt;
#highlight "phoneNumbers" / "0" / "number" &lt;&lt;h2&gt;&gt;
{
  "firstName": "John",
  "lastName": "Smith",
  "isAlive": true,
  "age": 28,
  "address": {
    "streetAddress": "21 2nd Street",
    "city": "New York",
    "state": "NY",
    "postalCode": "10021-3100"
  },
  "phoneNumbers": [
    {
      "type": "home",
      "number": "212 555-1234"
    },
    {
      "type": "office",
      "number": "646 555-4567"
    }
  ],
  "children": [],
  "spouse": null
}
@endjson</t>
<t tx="swot.20250509073027.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032352d30322d32327103752e">**Component diagrams** use **components** and **interfaces** to represent the logical modules of software and their interaction interfaces.

[plantuml, target=img/diagram-component-2025-05-09-095950, format=png]
....
@startuml
component "Frontend" as Frontend
component "Backend API" as Backend
interface "API Interface" as API_Interface

Frontend ..&gt; API_Interface
Backend --|&gt; API_Interface
@enduml
....
</t>
<t tx="swot.20250509073027.10">@language asciidoc
在 app.js 中指定了一些要使用的路径文件。

.Express 展示端组件图
[plantuml, target=img/diagram-component-2025-05-09-103145, format=png]
....
@startuml
package app.js {

    package Directory {
        folder public {
            file css
            file img
            file js
        }
        folder views {
            file index.html
        }
        folder config {
            file jwtSecretKey.js
        }
    }
}
@enduml
....
</t>
<t tx="swot.20250509073027.2">Q: Why introduce an interface when the frontend can just connect directly to the backend in the diagram? Isn’t it redundant? +
问：上图中直接用前端连接后端就可以了，为什么还需要中间来个 interface？是多此一举吗？

A: It’s not redundant, but rather a clearer way to express the system’s structure and separation of concerns. +
答：不算是多此一举**，而是更清晰地表达系统的结构和职责分离。
上图中直接用前端连接后端就可以了，为什么还需要中间来个 interface？是多次一举吗？

***

**1. Why need interface？**

In a component diagram, the interface defines the communication contract between components to clarify architecture. +
在**组件图（Component Diagram）**中，`interface` 的作用是明确**组件之间的通信契约**，让架构更清晰，主要有以下几个原因：

**Decoupling（解耦）**：

- If the Frontend depends directly on the Backend, it requires knowledge of the backend's implementation. +
如果 `Frontend` 直接依赖 `Backend`，说明 `Frontend` 需要知道 `Backend` 的具体实现。

- With API_Interface, the frontend only relies on the API contract and not on backend details. +
**引入 `API_Interface`（接口）后，前端只关心 API 规范，不依赖后端的具体实现**，这样如果后端更换实现方式（如从 `Node.js` 换成 `Spring Boot`），前端无须修改。

**Explicit Role（明确角色）**：

- The frontend cares about the APIs it needs, not which backend provides them. +
  `Frontend` 需要某些 API，它不关心 API 由哪个后端提供。
- The backend may expose different APIs, and interfaces help identify which are for frontend use. +
  `Backend` 可能有多个 API，对外暴露的是 `API_Interface`，这样可以清晰地区分哪些 API 是暴露给前端的，哪些是内部 API。

**Extensibility（扩展性）**：

In future, if there are multiple backend versions like BackendV2, they can implement the same interface. +
如果未来有多个后端实现，比如 `BackendV2`，它们都可以实现相同的 `API_Interface`，前端仍然可以无缝调用 API。

[plantuml, target=img/diagram-component-2025-05-09-100211, format=png]
....
@startuml
component "Frontend" as Frontend
interface "API interface" as API_Interface
component "Backend API v1" as BackendV1
component "Backend API v2" as BackendV2

Frontend ..&gt; API_Interface
BackendV1 --&gt; API_Interface
BackendV2 --&gt; API_Interface
@enduml
....

Now the frontend can switch between BackendV1 and BackendV2 without modifying its code. +
现在，前端可以在 `BackendV1` 和 `BackendV2` 之间自由切换，而无需修改自身代码。

**2. When can you omit the interface?** 什么时候可以省略 interface？

If the system has only one backend and the API won’t change, you can connect Frontend -&gt; Backend directly. +
如果你的系统**只有一个后端实现，并且不会更换 API 结构**，确实可以直接连接 `Frontend -&gt; Backend`。比如：

[plantuml, target=img/diagram-component-2025-05-09-100245, format=png]
....
component "Frontend" as Frontend
component "Backend API" as Backend
Frontend .&gt; Backend : Call API
....

However, this has poor scalability compared to using interfaces. +
但是这种方式在系统扩展性上**没有 `interface` 方案好**，如果未来有多个后端实现或 API 结构变化，前端代码可能需要大改。


**3. Best practices for component diagrams ** 组件图的最佳实践

* Small projects: If the frontend only talks to one backend, you can omit the interface. +
  小型项目：如果 `Frontend` 只与单个 `Backend` 交互，**可以省略 `interface`**。
* Medium/large projects: If multiple backends or clear API boundaries exist, it’s better to use interface. +
  中大型项目：如果 API 由多个 `Backend` 提供，或 API 设计需要清晰的边界，**建议使用 `interface`**。
</t>
<t tx="swot.20250509073027.3">@language asciidoc
在 **PlantUML 组件图（Component Diagram）** 中，**虚线（`..&gt;`）和实线（`--|&gt;`）的含义不同**。

**1. 虚线（`..&gt;`）**
**表示“依赖关系”（Dependency）**
用于表示 **一个组件使用或调用另一个组件**，但它们**不是强绑定**关系。

[plantuml, target=img/diagram-component-2025-05-09-100502, format=png]
....
@startuml
component "前端" as Frontend
interface "API 接口" as API_Interface

Frontend .&gt; API_Interface : 依赖 API
@enduml
....

**含义：** `Frontend` 依赖 `API_Interface`，但 `Frontend` **不一定知道 `API_Interface` 的实现细节**。

**2. 实线（`--&gt;`）**
**表示“实现关系”（Realization）**
用于表示 **一个组件实现了某个接口**（通常用于后端实现 API）。

[plantuml, target=img/diagram-component-2025-05-09-100635, format=png]
....
@startuml
interface "API 接口" as API_Interface
component "后端 API" as Backend

Backend -&gt; API_Interface : 实现 API
@enduml
....

**含义：** `Backend` 提供 `API_Interface` 规范的实现。

**3. 结合示例**

.完整的组件图
[plantuml, target=img/diagram-component-2025-05-09-100733, format=png]
....
@startuml
component "前端" as Frontend
interface "API 接口" as API_Interface
component "后端 API" as Backend

Frontend .&gt; API_Interface : 依赖 API
API_Interface &lt;- Backend  : 实现 API
@enduml
....

**解释：**

1. `Frontend ..&gt; API_Interface`（虚线）：前端**调用** API，但不关心后端的具体实现。
2. `pass:[Backend --&gt; API_Interface]`（实线）：后端**实现** API 规范。
</t>
<t tx="swot.20250509073027.4">在 **组件图（Component Diagram）** 中，`package` 用于**组织组件**，类似于 Java、Python 中的包（namespace）。

[plantuml, target=img/diagram-componet-2025-05-09-103223, format=png]
....
@startuml
package "前端" {
  component "Vue.js 组件" as Vue
  component "UI 组件库" as UI
  Vue ..&gt; UI
}

package "后端" {
  component "express.js API" as API
  interface "API 接口" as API_Interface
  API --&gt; API_Interface
}

package "数据库" {
  database "MySQL"
}

Vue ..&gt; API_Interface
API --&gt; MySQL
@enduml
....

**解释**

1. **`package "前端"`**：表示前端相关的组件，比如 Vue.js 和 UI 组件库。
2. **`package "后端"`**：表示后端的 API，使用 `interface` 定义 API 规范。
3. **`package "数据库"`**：表示数据库存储层。
4. **前端（Vue.js）调用 API（虚线）**，后端 API 实现接口（实线）。
5. **API 连接 MySQL**（数据存储）。后端 API 直接执行 SQL 查询，所以用实线。

---

**什么时候用 `package`？**

✅ 需要**分组**组件时，比如：

- 按照 **前端 / 后端 / 数据库** 组织组件。
- 按照 **微服务 / 模块** 结构化展示。

✅ 需要**增强可读性**，避免组件杂乱无章。如果你的系统有很多组件，**用 `package` 可以让图更加清晰**。
</t>
<t tx="swot.20250509073027.5">在软件开发中，**Component（组件）** 类似于 **模块化的软件单元**，它通常对应于以下概念：  

**1. 模块（Module）**

   - 在前端：Vue 组件（`&lt;MyComponent /&gt;`）、React 组件、Nuxt 模块等。
   - 在后端：Express 路由模块、Spring Boot 服务模块等。
   - 在 Node.js：使用 `require` 或 `import` 导入的模块。

**2. 类（Class）**

   - 在面向对象编程（OOP）中，一个 `component` 可以对应一个 `class`，比如 `UserService`、`DatabaseConnector` 这样的类。

**3. 微服务（Microservice）**

   - 在微服务架构中，每个独立的微服务可以被看作一个组件，比如 `用户管理服务`、`订单处理服务` 等。

**4. 库（Library）或 SDK**

   - 例如 `Axios`（HTTP 请求库）、`Nuxt UI`（组件库），这些也可以用 `component` 表示它们的功能单元。

---

**总结**

- **小范围**：`component` 类似 **前端组件**、**类**、**模块**。
- **大范围**：它也可以表示 **微服务** 或 **系统的某个独立部分**。

所以在 `PlantUML` 组件图中，`component` 主要是用来表示 **可复用的软件单元**，并展示它们之间的关系！
</t>
<t tx="swot.20250509073027.6">@language asciidoc
[plantuml, target=img/diagram-comonent-dayu-2025-05-09-103243, format=png]
....
@startuml
'left to right direction

file "HomePage /" as root
file "router/clint_home.js" as home
file "config/db.js" as db
file "views/index.html" as index

package "controllers/client_homeController.js" as homeCtl {
    component "exports clientHome" as clientHome {
        portout resp
        interface "currentVisit"
        interface "manySQLQuery" #Yellow
        interface "manySQLResult"
        interface "Menu"
    }
    interface "queryFromDatabase()" as queryFromDatabase
    interface "generateMenu()" as generateMenu
    interface "buildThirdLevelMenu()" as buildThirdLevelMenu
    interface "generateMenu3()" as generateMenu3
}

root ..&gt; home
home ..&gt; homeCtl

manySQLResult ..&gt; generateMenu
generateMenu .up.&gt; buildThirdLevelMenu
generateMenu ..&gt; Menu

manySQLResult ..&gt; generateMenu3
generateMenu3 ..&gt; Menu

manySQLQuery ..&gt; queryFromDatabase: 大量查询
queryFromDatabase ..&gt; db: 获取数据
queryFromDatabase ..&gt; manySQLResult
manySQLResult ..&gt; currentVisit: 包含访问量
currentVisit ..&gt; db: 保存访问量

manySQLResult ..&gt; resp: 部分返回
Menu ..&gt; resp
resp ..&gt; index
'index ..&gt; root

@enduml
....
</t>
<t tx="swot.20250509073027.7">@language asciidoc
.Express 展示端组件图
[plantuml, target=img/diagram-component-2025-05-09-102755, format=png]
....
@startuml

package app.js {

    package "router_1" {
        component Industries_list
        component Solutions_list
        component Customization_list
        component CompanyInformation_list
        component NewsandEvents_list
        component Support_list

        file "router/clint_news_list.js" as news

        Industries_list ..&gt; news
        Solutions_list ..&gt; news
        Customization_list ..&gt; news
        CompanyInformation_list .up.&gt; news
        NewsandEvents_list .up.&gt; news
        Support_list .up.&gt; news
    }
}
@enduml
....
</t>
<t tx="swot.20250509073027.8">@language asciidoc
.Express 展示端组件图
[plantuml, target=img/diagram-component-2025-05-09-103024, format=png]
....
@startuml

package app.js {

    package "router_2" {
        component Industries_detail
        component Solutions_detail
        component Customization_detail
        component CompanyInformation_detail
        component NewsandEvents_detail
        component Support_detail

        file "router/clint_news_detail.js" as news_detail

        Industries_detail ..&gt; news_detail
        Solutions_detail ..&gt; news_detail
        Customization_detail ..&gt; news_detail
        CompanyInformation_detail .up.&gt; news_detail
        NewsandEvents_detail .up.&gt; news_detail
        Support_detail .up.&gt; news_detail
    }
}
@enduml
....
</t>
<t tx="swot.20250509073027.9">@language asciidoc
.Express 展示端组件图
[plantuml, target=img/diagram-component-2025-05-09-103049, format=png]
....
@startuml
left to right direction

package app.js {

    package "router_3" {
        component product_list
        component product_detail
        component CoreBusiness_list
        component search_list
        component email_form
        component cookies_form
        component 404

        file "router/clint_case_list.js" as case
        file "router/clint_case_detail.js" as case_detail
        file "router/clint_search_list.js" as search
        file "route/clint_404" as fof
        file "route/clint_email_form.js" as email
        file "route/clint_cookies_form.js" as cookies

        product_list ..&gt; case
        product_detail ..&gt; case_detail
        CoreBusiness_list ..&gt; case

        search_list ..&gt; search
        404 ..&gt; fof
        email_form ..&gt; email
        cookies_form ..&gt; cookies
    }
}
@enduml
....
</t>
<t tx="swot.20250509104746.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032352d30322d32327103752e">部署图（Deployment Diagram） 使用 node 表示服务器或运行环境，database 表示数据库，artifact 表示可执行文件等。

.link:img/diagram-deployment-2025-05-09-110113.png[deployment]
[plantuml, target=img/diagram-deployment-2025-05-09-110113, format=png]
....
@startuml

node "Nginx 服务器" {
    component "Nginx"
}

node "Web 服务器" {
    component "Node.js"
    component "Express.js"
}

node "数据库服务器" {
    database "MySQL"
}

node "前端客户端" {
    component "Vue.js"
}

"Vue.js" ..&gt; "Nginx" : 访问网站
"Nginx" ..&gt; "Node.js" : 反向代理
"Node.js" ..&gt; "MySQL" : 读写数据

@enduml
....

====
- `node "Web 服务器"`：表示一个物理服务器。
    * 在UML部署图中，Node 通常表示硬件或硬件平台，或者是一个可以执行软件的物理设备。
- `component "Node.js"`：表示在该服务器上运行的 Node.js 应用。
- `database "MySQL"`：表示数据库服务器上的 MySQL 实例。
- 组件之间用 `..&gt;` 连接，表示访问或交互关系。
====
</t>
<t tx="swot.20250509104746.2">.link:img/diagram-deployment-2025-05-09-110102.png[Official website deployment]
[plantuml, target=img/diagram-deployment-2025-05-09-110102, format=png]
....
@startuml
node "Ubuntu Linux" {

    folder Webhook {
        artifact "6 Language Front"
        artifact "Admin"
    }

    package "Node.js 运行环境" {
        package "Express Front" as express{
            component "Express.js"
            component "Templates"
            "Templates" -&gt; "Express.js": 强绑定
        }
        package "Nuxt Admin" as nuxt {
            component "Vue.js"
            component "Nitro.js"
        }
    }
    component "Nginx"
    database  "MySQL"

    "Nginx" ..&gt; "express": 反向代理
    "Nginx" ..&gt; "nuxt" : 反向代理

    "Nitro.js" --&gt; "MySQL"
    "Express.js" --&gt; "MySQL"

    "Vue.js" .&gt; "Nitro.js": restful
    "Vue.js" ..&gt; "Express.js": 访问部分api

}

cloud gitee
component "浏览器" as browser

Webhook --&gt; gitee
nuxt -&gt; Webhook
express -&gt; Webhook

browser --&gt; Nginx
@enduml
....
</t>
<t tx="swot.20250509111441.1">.link:img/diagram-wbs-2025-05-09-111742.svg[wbs]
[plantuml, target=img/diagram-wbs-2025-05-09-111742, format=svg]
....
@startwbs
scale 1.2
* Business Process Modelling WBS
** Launch the project
*** Complete Stakeholder Research
*** Initial Implementation Plan
** Design phase
*** Model of AsIs Processes Completed
**** Model of AsIs Processes Completed1
**** Model of AsIs Processes Completed2
*** Measure AsIs performance metrics
*** Identify Quick Wins
** Complete innovate phase
@endwbs
....
</t>
<t tx="swot.20250509113701.1">https://mermaid.js.org/

安装与 @mermaid-js/mermaid-cli 兼容的 puppeteer

    pnpm add puppeteer@^23 -g
    验证安装：
    node -e "console.log(require('puppeteer').executablePath())"
    输出 Chromium 的路径，说明安装成功
    /Users/swot/.cache/puppeteer/chrome/mac-131.0.6778.204/chrome-mac-x64/Google Chrome for Testing.app/Contents/MacOS/Google Chrome for Testing


安装 mermaid-cli:

    npm install -g @mermaid-js/mermaid-cli

查看是否安装成功:

    which mmdc  # 在 Linux/macOS 上
    where mmdc  # 在 Windows 上


.link:img/mermaid-2025-05-09-113732.png[Example1]
[mermaid, target=img/mermaid-2025-05-09-113732, format=png]
....
graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
....


.link:img/mermaid_2025-05-09-113741.png[Example2]
[mermaid, target=img/mermaid_2025-05-09-113741, format=png]
....
sequenceDiagram
    participant Client
    participant Middleware
    participant API Handler

    Client-&gt;&gt;Middleware: 发起请求
    Middleware-&gt;&gt;Middleware: 执行前置逻辑
    Middleware-&gt;&gt;API Handler: 自动路由匹配
    API Handler-&gt;&gt;Middleware: 返回原始数据
    Middleware-&gt;&gt;Middleware: 包装为标准格式
    Middleware-&gt;&gt;Client: 发送最终响应
....
</t>
<t tx="swot.20250509155424.1">https://docs.asciidoctor.org/diagram-extension/latest/diagram_types/barcode/

Install:

    gem install barby
    gem install rqrcode
    gem install chunky_png


Barcdodes can be written codabar:A31117013206375A[target=img/codabar-2025-05-09-162333, format=png, height=15] inline or as blocks.
link:img/codabar-2025-05-09-162333.png[Show codabar]


.link:img/qrcode-2025-05-09-162345.png[Show qrcode]
[qrcode, target=img/qrcode-2025-05-09-162345, format="png", xdim=4, foreground=#199, role="text-left"]
....
Hello World!
....


.link:img/code128-2025-05-09-162354.png[Show code128]
[code128, target=img/code128-2025-05-09-162354, format="png", xdim=2, height=30, foreground=#199]
....
A31117013206375A
....

</t>
<t tx="swot.20250509164220.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032352d30312d33307103752e">Install

    npm install -g vega-cli vega-embed vega-lite vega-themes vega

Edit ~/.zshrc

    export PATH="$PATH:$(npm config get prefix)/bin"
    export NODE_PATH=$(npm root -g)
</t>
<t tx="swot.20250509164220.2">.link:img/vegalite_2025-05-09-165945.png[vegalite_example1]
[vegalite, target=img/vegalite_2025-05-09-165945, format=png]
....
{
  "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
  "description": "A simple bar chart",
  "data": {
    "values": [
      {"category": "A", "value": 28},
      {"category": "B", "value": 55},
      {"category": "C", "value": 43}
    ]
  },
  "mark": "bar",
  "encoding": {
    "x": {"field": "category", "type": "nominal"},
    "y": {"field": "value", "type": "quantitative"}
  }
}
....

</t>
<t tx="swot.20250509164220.3">.link:img/vegalite-2025-05-09-170329.png[vegalite_example2]
[vegalite, target=img/vegalite-2025-05-09-170329, format=png]
....
{
  "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
  "config": {"view": {"stroke": ""}},
  "width": 800,
  "height": 200,
  "data": {
    "values": [
      {"country": "Great Britain", "animal": "cattle", "col": 3},
      {"country": "Great Britain", "animal": "cattle", "col": 2},
      {"country": "Great Britain", "animal": "cattle", "col": 1},
      {"country": "Great Britain", "animal": "pigs", "col": 2},
      {"country": "Great Britain", "animal": "pigs", "col": 1},
      {"country": "Great Britain", "animal": "sheep", "col": 10},
      {"country": "Great Britain", "animal": "sheep", "col": 9},
      {"country": "Great Britain", "animal": "sheep", "col": 8},
      {"country": "Great Britain", "animal": "sheep", "col": 7},
      {"country": "Great Britain", "animal": "sheep", "col": 6},
      {"country": "Great Britain", "animal": "sheep", "col": 5},
      {"country": "Great Britain", "animal": "sheep", "col": 4},
      {"country": "Great Britain", "animal": "sheep", "col": 3},
      {"country": "Great Britain", "animal": "sheep", "col": 2},
      {"country": "Great Britain", "animal": "sheep", "col": 1},
      {"country": "United States", "animal": "cattle", "col": 9},
      {"country": "United States", "animal": "cattle", "col": 8},
      {"country": "United States", "animal": "cattle", "col": 7},
      {"country": "United States", "animal": "cattle", "col": 6},
      {"country": "United States", "animal": "cattle", "col": 5},
      {"country": "United States", "animal": "cattle", "col": 4},
      {"country": "United States", "animal": "cattle", "col": 3},
      {"country": "United States", "animal": "cattle", "col": 2},
      {"country": "United States", "animal": "cattle", "col": 1},
      {"country": "United States", "animal": "pigs", "col": 6},
      {"country": "United States", "animal": "pigs", "col": 5},
      {"country": "United States", "animal": "pigs", "col": 4},
      {"country": "United States", "animal": "pigs", "col": 3},
      {"country": "United States", "animal": "pigs", "col": 2},
      {"country": "United States", "animal": "pigs", "col": 1},
      {"country": "United States", "animal": "sheep", "col": 7},
      {"country": "United States", "animal": "sheep", "col": 6},
      {"country": "United States", "animal": "sheep", "col": 5},
      {"country": "United States", "animal": "sheep", "col": 4},
      {"country": "United States", "animal": "sheep", "col": 3},
      {"country": "United States", "animal": "sheep", "col": 2},
      {"country": "United States", "animal": "sheep", "col": 1}
    ]
  },
  "mark": {"type": "point", "filled": true},
  "encoding": {
    "x": {"field": "col", "type": "ordinal", "axis": null},
    "y": {"field": "animal", "type": "ordinal", "axis": null},
    "row": {"field": "country", "header": {"title": ""}},
    "shape": {
      "field": "animal",
      "type": "nominal",
      "scale": {
        "domain": ["person", "cattle", "pigs", "sheep"],
        "range": [
          "M1.7 -1.7h-0.8c0.3 -0.2 0.6 -0.5 0.6 -0.9c0 -0.6 -0.4 -1 -1 -1c-0.6 0 -1 0.4 -1 1c0 0.4 0.2 0.7 0.6 0.9h-0.8c-0.4 0 -0.7 0.3 -0.7 0.6v1.9c0 0.3 0.3 0.6 0.6 0.6h0.2c0 0 0 0.1 0 0.1v1.9c0 0.3 0.2 0.6 0.3 0.6h1.3c0.2 0 0.3 -0.3 0.3 -0.6v-1.8c0 0 0 -0.1 0 -0.1h0.2c0.3 0 0.6 -0.3 0.6 -0.6v-2c0.2 -0.3 -0.1 -0.6 -0.4 -0.6z",
          "M4 -2c0 0 0.9 -0.7 1.1 -0.8c0.1 -0.1 -0.1 0.5 -0.3 0.7c-0.2 0.2 1.1 1.1 1.1 1.2c0 0.2 -0.2 0.8 -0.4 0.7c-0.1 0 -0.8 -0.3 -1.3 -0.2c-0.5 0.1 -1.3 1.6 -1.5 2c-0.3 0.4 -0.6 0.4 -0.6 0.4c0 0.1 0.3 1.7 0.4 1.8c0.1 0.1 -0.4 0.1 -0.5 0c0 0 -0.6 -1.9 -0.6 -1.9c-0.1 0 -0.3 -0.1 -0.3 -0.1c0 0.1 -0.5 1.4 -0.4 1.6c0.1 0.2 0.1 0.3 0.1 0.3c0 0 -0.4 0 -0.4 0c0 0 -0.2 -0.1 -0.1 -0.3c0 -0.2 0.3 -1.7 0.3 -1.7c0 0 -2.8 -0.9 -2.9 -0.8c-0.2 0.1 -0.4 0.6 -0.4 1c0 0.4 0.5 1.9 0.5 1.9l-0.5 0l-0.6 -2l0 -0.6c0 0 -1 0.8 -1 1c0 0.2 -0.2 1.3 -0.2 1.3c0 0 0.3 0.3 0.2 0.3c0 0 -0.5 0 -0.5 0c0 0 -0.2 -0.2 -0.1 -0.4c0 -0.1 0.2 -1.6 0.2 -1.6c0 0 0.5 -0.4 0.5 -0.5c0 -0.1 0 -2.7 -0.2 -2.7c-0.1 0 -0.4 2 -0.4 2c0 0 0 0.2 -0.2 0.5c-0.1 0.4 -0.2 1.1 -0.2 1.1c0 0 -0.2 -0.1 -0.2 -0.2c0 -0.1 -0.1 -0.7 0 -0.7c0.1 -0.1 0.3 -0.8 0.4 -1.4c0 -0.6 0.2 -1.3 0.4 -1.5c0.1 -0.2 0.6 -0.4 0.6 -0.4z",
          "M1.2 -2c0 0 0.7 0 1.2 0.5c0.5 0.5 0.4 0.6 0.5 0.6c0.1 0 0.7 0 0.8 0.1c0.1 0 0.2 0.2 0.2 0.2c0 0 -0.6 0.2 -0.6 0.3c0 0.1 0.4 0.9 0.6 0.9c0.1 0 0.6 0 0.6 0.1c0 0.1 0 0.7 -0.1 0.7c-0.1 0 -1.2 0.4 -1.5 0.5c-0.3 0.1 -1.1 0.5 -1.1 0.7c-0.1 0.2 0.4 1.2 0.4 1.2l-0.4 0c0 0 -0.4 -0.8 -0.4 -0.9c0 -0.1 -0.1 -0.3 -0.1 -0.3l-0.2 0l-0.5 1.3l-0.4 0c0 0 -0.1 -0.4 0 -0.6c0.1 -0.1 0.3 -0.6 0.3 -0.7c0 0 -0.8 0 -1.5 -0.1c-0.7 -0.1 -1.2 -0.3 -1.2 -0.2c0 0.1 -0.4 0.6 -0.5 0.6c0 0 0.3 0.9 0.3 0.9l-0.4 0c0 0 -0.4 -0.5 -0.4 -0.6c0 -0.1 -0.2 -0.6 -0.2 -0.5c0 0 -0.4 0.4 -0.6 0.4c-0.2 0.1 -0.4 0.1 -0.4 0.1c0 0 -0.1 0.6 -0.1 0.6l-0.5 0l0 -1c0 0 0.5 -0.4 0.5 -0.5c0 -0.1 -0.7 -1.2 -0.6 -1.4c0.1 -0.1 0.1 -1.1 0.1 -1.1c0 0 -0.2 0.1 -0.2 0.1c0 0 0 0.9 0 1c0 0.1 -0.2 0.3 -0.3 0.3c-0.1 0 0 -0.5 0 -0.9c0 -0.4 0 -0.4 0.2 -0.6c0.2 -0.2 0.6 -0.3 0.8 -0.8c0.3 -0.5 1 -0.6 1 -0.6z",
          "M-4.1 -0.5c0.2 0 0.2 0.2 0.5 0.2c0.3 0 0.3 -0.2 0.5 -0.2c0.2 0 0.2 0.2 0.4 0.2c0.2 0 0.2 -0.2 0.5 -0.2c0.2 0 0.2 0.2 0.4 0.2c0.2 0 0.2 -0.2 0.4 -0.2c0.1 0 0.2 0.2 0.4 0.1c0.2 0 0.2 -0.2 0.4 -0.3c0.1 0 0.1 -0.1 0.4 0c0.3 0 0.3 -0.4 0.6 -0.4c0.3 0 0.6 -0.3 0.7 -0.2c0.1 0.1 1.4 1 1.3 1.4c-0.1 0.4 -0.3 0.3 -0.4 0.3c-0.1 0 -0.5 -0.4 -0.7 -0.2c-0.3 0.2 -0.1 0.4 -0.2 0.6c-0.1 0.1 -0.2 0.2 -0.3 0.4c0 0.2 0.1 0.3 0 0.5c-0.1 0.2 -0.3 0.2 -0.3 0.5c0 0.3 -0.2 0.3 -0.3 0.6c-0.1 0.2 0 0.3 -0.1 0.5c-0.1 0.2 -0.1 0.2 -0.2 0.3c-0.1 0.1 0.3 1.1 0.3 1.1l-0.3 0c0 0 -0.3 -0.9 -0.3 -1c0 -0.1 -0.1 -0.2 -0.3 -0.2c-0.2 0 -0.3 0.1 -0.4 0.4c0 0.3 -0.2 0.8 -0.2 0.8l-0.3 0l0.3 -1c0 0 0.1 -0.6 -0.2 -0.5c-0.3 0.1 -0.2 -0.1 -0.4 -0.1c-0.2 -0.1 -0.3 0.1 -0.4 0c-0.2 -0.1 -0.3 0.1 -0.5 0c-0.2 -0.1 -0.1 0 -0.3 0.3c-0.2 0.3 -0.4 0.3 -0.4 0.3l0.2 1.1l-0.3 0l-0.2 -1.1c0 0 -0.4 -0.6 -0.5 -0.4c-0.1 0.3 -0.1 0.4 -0.3 0.4c-0.1 -0.1 -0.2 1.1 -0.2 1.1l-0.3 0l0.2 -1.1c0 0 -0.3 -0.1 -0.3 -0.5c0 -0.3 0.1 -0.5 0.1 -0.7c0.1 -0.2 -0.1 -1 -0.2 -1.1c-0.1 -0.2 -0.2 -0.8 -0.2 -0.8c0 0 -0.1 -0.5 0.4 -0.8z"
        ]
      },
      "legend": null
    },
    "color": {
      "field": "animal",
      "type": "nominal",
      "legend": null,
      "scale": {
        "domain": ["person", "cattle", "pigs", "sheep"],
        "range": [
          "rgb(162,160,152)",
          "rgb(194,81,64)",
          "rgb(93,93,93)",
          "rgb(91,131,149)"
        ]
      }
    },
    "opacity": {"value": 1},
    "size": {"value": 200}
  }
}
....
</t>
<t tx="swot.20250509164220.4">如果数据太大，不方便嵌入，可以用本地 Web 服务器：

    # 数据文件放在 data 目录下，所以需要在 data 的上层目录运行下面命令
    python -m http.server 1919


.link:img/vegalite_2025-05-09-170423.png[vegalite_example3]
[vegalite, target=img/vegalite_2025-05-09-170423, format=png]
....
{
  "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
  "repeat": ["Horsepower", "Miles_per_Gallon", "Acceleration", "Displacement"],
  "columns": 2,
  "spec": {
    "data": {"url": "http://localhost:1919/data/cars.json"},
    "mark": "bar",
    "encoding": {
      "x": {"field": {"repeat": "repeat"}, "bin": true},
      "y": {"aggregate": "count"},
      "color": {"field": "Origin"}
    }
  }
}
....
</t>
<t tx="swot.20250509164220.5">.link:img/vega-2025-05-09-170457.png[vega example1]
[vega, target=img/vega-2025-05-09-170457, format=png]
....
{
  "$schema": "https://vega.github.io/schema/vega/v5.json",
  "description": "A basic grouped bar chart example.",
  "width": 300,
  "height": 240,
  "padding": 5,

  "data": [
    {
      "name": "table",
      "values": [
        {"category":"A", "position":0, "value":0.1},
        {"category":"A", "position":1, "value":0.6},
        {"category":"A", "position":2, "value":0.9},
        {"category":"A", "position":3, "value":0.4},
        {"category":"B", "position":0, "value":0.7},
        {"category":"B", "position":1, "value":0.2},
        {"category":"B", "position":2, "value":1.1},
        {"category":"B", "position":3, "value":0.8},
        {"category":"C", "position":0, "value":0.6},
        {"category":"C", "position":1, "value":0.1},
        {"category":"C", "position":2, "value":0.2},
        {"category":"C", "position":3, "value":0.7}
      ]
    }
  ],

  "scales": [
    {
      "name": "yscale",
      "type": "band",
      "domain": {"data": "table", "field": "category"},
      "range": "height",
      "padding": 0.2
    },
    {
      "name": "xscale",
      "type": "linear",
      "domain": {"data": "table", "field": "value"},
      "range": "width",
      "round": true,
      "zero": true,
      "nice": true
    },
    {
      "name": "color",
      "type": "ordinal",
      "domain": {"data": "table", "field": "position"},
      "range": {"scheme": "category20"}
    }
  ],

  "axes": [
    {"orient": "left", "scale": "yscale", "tickSize": 0, "labelPadding": 4, "zindex": 1},
    {"orient": "bottom", "scale": "xscale"}
  ],

  "marks": [
    {
      "type": "group",

      "from": {
        "facet": {
          "data": "table",
          "name": "facet",
          "groupby": "category"
        }
      },

      "encode": {
        "enter": {
          "y": {"scale": "yscale", "field": "category"}
        }
      },

      "signals": [
        {"name": "height", "update": "bandwidth('yscale')"}
      ],

      "scales": [
        {
          "name": "pos",
          "type": "band",
          "range": "height",
          "domain": {"data": "facet", "field": "position"}
        }
      ],

      "marks": [
        {
          "name": "bars",
          "from": {"data": "facet"},
          "type": "rect",
          "encode": {
            "enter": {
              "y": {"scale": "pos", "field": "position"},
              "height": {"scale": "pos", "band": 1},
              "x": {"scale": "xscale", "field": "value"},
              "x2": {"scale": "xscale", "value": 0},
              "fill": {"scale": "color", "field": "position"}
            }
          }
        },
        {
          "type": "text",
          "from": {"data": "bars"},
          "encode": {
            "enter": {
              "x": {"field": "x2", "offset": -5},
              "y": {"field": "y", "offset": {"field": "height", "mult": 0.5}},
              "fill": [
                {"test": "contrast('white', datum.fill) &gt; contrast('black', datum.fill)", "value": "white"},
                {"value": "black"}
              ],
              "align": {"value": "right"},
              "baseline": {"value": "middle"},
              "text": {"field": "datum.value"}
            }
          }
        }
      ]
    }
  ]
}
....
</t>
<t tx="swot.20250509171442.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032352d30322d30327103752e">https://github.com/asciidoctor/asciidoctor-kroki

    $ gem install asciidoctor-kroki
    $ asciidoctor -r asciidoctor-kroki doc.adoc


[WARNING]
====
1. https://kroki.io 可能需要网络好，不然会报

    [21597:34067:0202/000442.644492:ERROR:ssl_client_socket_impl.cc(982)] handshake failed; returned -1, SSL error code 1, net_error -101

2. https://kroki.io 不能接受太大的 json 数据，会报错:

    414 Request-URI Too Large
    nginx/1.18.0 (Ubuntu) -&gt; 应该是 nginx 的限制，所以可以尝试将数据文件放在公网可以访问的网上来避免该问题（未测试）。

3. 网上 kroki 的图片，保存日期不是永久，可能在某个时刻就不能访问了。

4. 所以还是在本地使用 docker 部署 kroki 服务比较好。
   * 本地部署我还没有研究，文档在这儿 https://docs.kroki.io/kroki/setup/install/
   * 本地部署 kroki 后，不用安装那么多包了，还是很爽的。
====


.nvim doc.adoc
[vegalite, target=img/vegalite_kroki1, format=png]
....
{
  "data": {
    "values": [
      {"category": "A", "value": 28},
      {"category": "B", "value": 55},
      {"category": "C", "value": 43}
    ]
  },
  "mark": "bar",
  "encoding": {
    "x": {"field": "category", "type": "nominal"},
    "y": {"field": "value", "type": "quantitative"}
  }
}
....
</t>
<t tx="swot.20250509173942.1"></t>
<t tx="swot.20250509173947.1">:stem: latexmath
对于 n 个元素的关键字序列 stem:[\{ k_1, k_2, \ldots k_n \}]，当且仅当满足下面关系时称其为小根堆(小顶堆)。

[stem]
++++
[k_i \le k_{2i} \ \text{且} \ k_i \le k_{2i+1} \ \{ i = 1, 2, \ldots, \left\lfloor \frac{n}{2} \right\rfloor \}]
++++

TIP: 就到 n/2，因为再往后取就没有数来对比了。
 
以下序列中，（ ）不是小根堆(小顶堆)。

    A 16,25,40,55,30,50,45
    B 16,40,25,50,45,30,55
    C 16,25,39,41,45,43,50
    D 16,40,25,53,39,55,45

***

这是根据完全二叉树在数组中的存储方式来判断的。小根堆是一种完全二叉树结构的堆，在顺序存储时具有以下规律：

.link:img/mermaid-2025-05-09-174131.svg[D 16,40,25,53,39,55,45]
[mermaid, target=img/mermaid-2025-05-09-174131, format=svg]
....
flowchart TD
    16((16)) --- 25((25))
    25((25)) --- 55((55))
    25((25)) --- 45((45))

    16((16)) --- 40((40))
    40((40)) --- 53((53))
    40((40)) ---|违反小根堆性质| 39((39))
....

*答案为 D*
</t>
<t tx="swot.20250509175116.1">已知一棵二叉树的先序遍历结果为 ABCDEF，中序遍历结果为 CBAEDF，则后序遍历结果为（ ）。

    A CBEFDA
    B FEDCBA
    C CBEDFA
    D 不确定

***

我们根据 **先序遍历** 和 **中序遍历** 来还原这棵二叉树，再求出它的 **后序遍历**。

.遍历就是访问树中所有节点的一种方式
****
1. **先序遍历（Preorder）**: 访问顺序：**根 → 左子树 → 右子树**

2. **中序遍历（Inorder）**: 访问顺序：**左子树 → 根 → 右子树**

3. **后序遍历（Postorder）**: 访问顺序：**左子树 → 右子树 → 根**
****

给定：

- 先序遍历（Preorder）：`A B C D E F`
- 中序遍历（Inorder）： `C B A E D F`

[discrete]
=== 步骤一：构建二叉树

先序遍历的第一个节点是根节点：

- **根节点：A**

查找 A 在中序遍历中的位置：

- 中序遍历：`C B | A | E D F`

所以 A 的左子树是 `C B`，右子树是 `E D F`。

[discrete]
==== 处理左子树：

先序遍历中 A 的左子树部分是：`B C`

- 根是 B（先序中紧跟 A 之后）
- 中序左子树为 `C B`，B 是根，C 在左边 ⇒ C 是 B 的左子

左子树构建为：

```
   B
  /
C
```

[discrete]
==== 处理右子树：

先序遍历中 A 的右子树部分是：`D E F`（剩下的）

- 根是 D（下一个未使用的先序元素）
- 中序右子树是 `E D F`

D 在中序中的位置中间，所以：

- 左子树：E
- 右子树：F

右子树构建为：

```
   D
  / \
 E   F
```

[discrete]
==== 整体树结构为：

```
       A
     /   \
    B     D
   /     / \
  C     E   F
```

[discrete]
=== 步骤二：求后序遍历（Postorder）

后序遍历顺序是：**左 → 右 → 根**

按照树结构遍历：

- 左子树（B 的子树）：C → B
  
- 右子树（D 的子树）：E → F → D
  
- 根：A

合起来是：`C B E F D A`

[discrete]
==== 答案：**A. CBEFDA**

***
</t>
<t tx="swot.20250509175355.1">若一棵哈夫曼(Huffman)树共有 9 个顶点，则其叶子结点的个数为（ ）。

    A 4
    B 5
    C 6
    D 7

答案为：B

先推个公式出来：

正确的构建流程（4 个叶子结点：A、B、C、D）：

初始结点：A、B、C、D（都是叶子）

第一步：合并权值最小的两个（比如 A 和 B）⇒ 生成中间结点 P

第二步：合并权值最小的两个（比如 C 和 D）⇒ 生成中间结点 Q

第三步：合并 P 和 Q ⇒ 得到根结点 R

树的结构应该是这样的：

        R
       / \
      P   Q
     / \ / \
    A  B C  D

总结点数验证：

- 叶子结点：A、B、C、D ⇒ 4 个

- 中间结点：P、Q、R ⇒ 3 个

- 总结点数：4 + 3 = 7 = 2×4 - 1

所以有公式: ##总结点数 = 叶子结点数 + 内部结点数 = n+(n−1) = 2n−1##

9 个顶点代入公式： 9 = 2n - 1 -&gt; n = 5
</t>
<t tx="swot.20250509180254.1">:stem: latexmath
无向图中一个顶点的度是指图中与该顶点相邻接的顶点数。若无向图 G 中的顶点数为 n，边数为 e，则所有顶点的度数之和为（ ）

* A n*e
* B n+e
* C 2n
* D 2e

答案：D

****

定义：在无向图中，一个顶点的度数（Degree）是指与该顶点相连的边的数量。度数是描述顶点在图中连接程度的一个重要指标。

这个题考查的是图论中无向图的一个基本性质：

在一个无向图中，所有顶点的度数之和等于边数的两倍。

原因解释：
每条边连接两个顶点，因此会被两个顶点各“贡献一次”度数。所以总的度数是边数的两倍。

设：

* 顶点数为 n
* 边数为 e
* 公式中的 stem:[v_i] 指顶点

则： stem:[\sum_{i=1}^{n} \deg(v_i) = 2e]
****
</t>
<t tx="swot.20250509183134.1"></t>
<t tx="swot.20250509183157.1"></t>
<t tx="swot.20250509183417.1">奇校验：原始数据增加一个校验位，使 1 的个数为奇数。

    原始数据    校验位
    10010100    0   -&gt; 1 的个数为奇数，所以校验位为 0

偶校验：原始数据增加一个校验位，使 1 的个数为偶数。

    原始数据    校验位
    10010100    1   -&gt; 1 的个数为奇数，所以校验位为 1


* 奇偶校验只有在出错二进制位个数是 #奇数# 的情况下才有效。
* 奇偶校验只能检错，不能纠错。


码字：编码后的信息单元，由若干个二进制位组成。

距离：将两个码字逐位进行对比，具有不相同的位的个数称为两个码字间的距离。

  ** 1011101 和 1001001 之间的距离是 2。

    1011101
    1001001
      x x   -&gt; 2 位不同

  ** 奇偶校验的码距为 2
     *** 以奇校验为例：如下面完整码字的任意两个奇数个 1 的码字之间，至少要改两个比特才能从一个合法码字变成另一个合法码字。所以码距是 2。
+
[caption=]
.举例说明奇校验码距为 2
[cols="1,1,1",options="header"]
|===
| 数据位 | 校验位（奇校验） | 完整码字 
| 000   | 1             | 0001 
| 001   | 0             | 0010 
| 010   | 0             | 0100 
| 011   | 1             | 0111 
| 100   | 0             | 1000 
| 101   | 1             | 1011 
| 110   | 1             | 1101 
| 111   | 0             | 1110 
|===

码距：一种编码方案可能有若干个合法码字，各合法码字间的 #最小距离# 称为“码距”。

计算（偶校验为例）：各信息位进行异或（模2加）运算，得到的结果即为「偶校验位」。

  * 如 1001101 异或结果为 0，所以偶校验位为 0。
  * 则最后发送的数据为 10011010（假设将校验位放在最后面）

验证（偶校验为例）：收到方验证数据

  * 将收到的数据 10011010 按位异或结果为 0，说明数据正确。

https://www.bilibili.com/video/BV1qp421D7B3  0:00 -&gt; 02:44
</t>
<t tx="swot.20250509184225.1">给定待发送的数据为: 101001

要求的校验码多项式为: stem:[G(x) = x^3 + x^2 + 1]

***

1. 根据多项式确定 CRC 校验码位数
  ** 因为多项式最高次幂为 3，所以校验码位数为 3。

2. 数据左移校验码位数
  ** 数据补 3 个 0 为: 101001000

3. 确定多项式的值
  ** 根据多项式确定
  stem:[G(x) = x^3 + x^2 + 1] -&gt;
  stem:[1 \cdot x^3 + 1 \cdot x^2 + 0 \cdot x^1 + 1 \cdot x^0]
  -&gt; 1101

4. 计算 CRC 值（除法异或运算）
+
  1010 01000 ÷ 1101
  1101        (生成多项式)
  ----
  01110 1000  (第一步 XOR 结果)
   1101
   ----
   001110 00  (第二步 XOR 结果)
     1101
     -----
     001100   (第三步 XOR 结果)
       1101
       ----
       0001   (CRC 余数为 1，则 3 位校验位为 001)

5. 生成发送数据 = 传输数据 + CRC校验码
  ** 101001+001 -&gt; 101001001

---
https://www.bilibili.com/video/BV1qp421D7B3

  * 从低到高举例 12:27 -&gt; end
</t>
<t tx="swot.20250509191942.1">* 可检错和纠错，海明码的标准码距是 3

* 可发现 2 位错，纠正 1 位错

* 用到了奇偶校验中的偶校验。

* ##计算 k 位数公式：stem:[2^k \geq n + k + 1]##
  ** n 为信息码长度
  ** k 为校验码长度（需要通过上面公式，自己代出来即可）
  ** ##校验码位置：stem:[2^{i-1}] ( i 从 1 -&gt; k，如1、2、4、8 )##

* ##异或校验整个海明码，都为 0 正确。##

---

视频教学

* https://www.youtube.com/watch?v=5it44QcOtQQ 从高到低举例
* https://www.bilibili.com/video/BV1qp421D7B3 从低到高举例 02:44 -&gt; 12:27
</t>
<t tx="swot.20250509191942.2">例如: 信息码 101101100，采用海明码校验，问最终海明码是多少?

1. 确定校验位数量 k，原信息码位数为 n=9，代入公式:
  * stem:[2^k \geq n+k+1]，得 stem:[2^k \geq 9+k+1]
  * 若 k=4，则 stem:[2^4 \geq 9+4+1]，即 16&gt;14，满足公式。
  * 确定校验位数量为 4 位

2. 确定校验码位置: 代入公式 stem:[2^{i-1}] ( i 从 1-&gt; k=4，得 1、2、4、8 )，即下面 k1、k2、k4、k8 的 4 个位置。
+
[plantuml, target=img/diagram-haimingcode1, format=png]
....
@startebnf
&lt;style&gt;
element {
  ebnf {
    Backgroundcolor pink
    note {
      Backgroundcolor pink
    }
  }
}
&lt;/style&gt;

校验位位置=k1(*1*),k2(*2*),"1"(*3*),k4(*4*),"0"(*5*),"1"(*6*),"1"(*7*),
k8(*8*),"0"(*9*),"1"(*10*),"1"(*11*),"0"(*12*),"0"(*13*);

@endebnf
....

3. 确定校验位与数据位对应关系
  * 即 kx 分别对应哪些数据位
+
[caption=]
[cols="6*"]
|===
2.2+^.^|校验位对应数据位表 (为1则对应)                          4+^|4个校验位
                         |k8 (9,10,11,12,13) |k4 (5,6,7,12,13) |k2 (3,6,7,10,11) |k1 (3,5,7,9,11,13)
.9+^.^|9个数据位对应校验位关系
        | 3 -&gt; 0011 -&gt; k1, k2     |0                  |0               |1                 |1
        | 5 -&gt; 0101 -&gt; k1, k4     |0                  |1               |0                 |1
        | 6 -&gt; 0110 -&gt; k2, k4     |0                  |1               |1                 |0
        | 7 -&gt; 0111 -&gt; k1, k2, k4 |0                  |1               |1                 |1
        | 9 -&gt; 1001 -&gt; k1, k8     |1                  |0               |0                 |1
        |10 -&gt; 1010 -&gt; k2, k8     |1                  |0               |1                 |0
        |11 -&gt; 1011 -&gt; k1, k2, k8 |1                  |0               |1                 |1
        |12 -&gt; 1100 -&gt; k4, k8     |1                  |1               |0                 |0
        |13 -&gt; 1101 -&gt; k1, k4, k8 |1                  |1               |0                 |1
|===

4. 计算校验位的值
  * 异或结果为 kx 的值
+
[caption=]
[cols="8*"]
|===
| k1 对应位   |3 | 5 | 7 | 9  | 11 | 13    | 异或结果为 k1
| 信息码对应值 |1 | 0 | 1 | 0  | 1  | 0  ^.^| 1
| k2 对应位   |3 | 6 | 7 | 10 | 11 |       | 异或结果为 k2
| 信息码对应值 |1 | 1 | 1 | 1  | 1  |    ^.^| 1
| k4 对应位   |5 | 6 | 7 | 12 | 13 |       | 异或结果为 k3
| 信息码对应值 |0 | 1 | 1 | 0  | 0  |    ^.^| 0
| k8 对应位   |9 | 10| 11| 12 | 13 |       | 异或结果为 k4
| 信息码对应值 |0 | 1 | 1 | 0  | 0  |    ^.^| 0
|===

5. 插入校验位 k1 k2 k4 k8
+
[plantuml, target=img/diagram-haimingcode2, format=png]
....
@startebnf
&lt;style&gt;
element {
  ebnf {
    Backgroundcolor pink
    note {
      Backgroundcolor pink
    }
  }
}
&lt;/style&gt;

插入校验位 = k1(*1*), k2(*2*),"1"(*3*),k4(*4*), "0"(*5*),"1"(*6*),"1"(*7*),k8(*8*), "0"(*9*),"1"(*10*),"1"(*11*),"0"(*12*),"0"(*13*)
           |1(*1*),  1(*2*),"1"(*3*), 0(*4*), "0"(*5*),"1"(*6*),"1"(*7*), 0(*8*), "0"(*9*),"1"(*10*),"1"(*11*),"0"(*12*),"0"(*13*);
(* 海明码为: 1110011001100 *)
@endebnf
....

6. 接收方检错和纠错判断
  * 接收方接收正确数据时: 1110011001100，按《4. 计算校验位的值》中的表进行异或（含 kx 值），都为 0 为正确。
  * 接收方接收错误数据时: 1110111001100，按《4. 计算校验位的值》中的表进行异或（含 kx 值），若有 1 为错误。
    ** 此例为数值位 5 由 0 变成了 1
    ** 如何知道是数据位 5 发生了变化？ -&gt; #将异或结果由 k8 k4 k2 k1 排序为 0 1 0 1，即是十进制的位置 5。#

+
[caption=]
[cols="8*", stripes=odd]
|===
| k1 | 3      | 5       | 7 | 9  | 11 | 13 | 异或结果
| 1  | 1      | 0 -&gt; 1  | 1 | 0  | 1  | 0  | 1 错
| k2 | 3      | 6       | 7 | 10 | 11 |    | 异或结果
| 1  | 1      | 1       | 1 | 1  | 1  |    | 0
| k4 | 5      | 6       | 7 | 12 | 13 |    | 异或结果
| 0  | 0 -&gt; 1 | 1       | 1 | 0  | 0  |    | 1 错
| k8 | 9      | 10      | 11| 12 | 13 |    | 异或结果
| 0  | 0      | 1       | 1 | 0  | 0  |    | 0
|===
</t>
<t tx="swot.20250509232901.1"></t>
<t tx="swot.20250509232946.1">设机器字长为 32 位，一个容量为 16MB 的存储器，CPU 按照半字寻址，其可寻址的单元数是（ ）。

    A 2^24
    B 2^23 正确
    C 2^22
    D 2^21

***

1. ‌明确关键概念‌

* 机器字长‌：32位，即 CPU 一次处理数据的位数为 32bit‌。
* 半字‌：字长的一半，32 位机器的半字为 16位（2字节）‌。
* 存储器容量‌：16MB = 16 × 2²⁰字节 = 2²⁴字节（因1MB = 2²⁰字节）‌。

2. ‌计算总位数‌

* 存储器容量需转换为位数以便后续计算：
* 16MB的位数‌ = 16 × 2²⁰字节 × 8位/字节 = 2²⁴ × 8位 = 2²⁷位‌。

3. ‌按半字寻址的单元数‌

* 每个半字大小‌：16位（2字节）‌。
* 总单元数‌ = 存储器总字节数 ÷ 每单元字节数 = 2²⁴字节 ÷ 2字节/单元 = 2²³单元‌。
* （或等价计算：总位数 ÷ 半字位数 = 2²⁷位 ÷ 16位/单元 = 2²³单元）

4. ‌验证与选项对比‌

* 选项B（2²³）‌与计算结果一致‌。

* 其他选项错误原因‌：

    A（2²⁴）：误用字节寻址（每单元1字节）‌。
    C（2²²）和D（2²¹）：无对应计算逻辑支持‌。

5. 通用公式：

* 可寻址单元数 = 存储器容量（字节） ÷ 每单元字节数‌

本题中：

* 每单元字节数 = 半字大小 = 2字节 → 2²⁴ ÷ 2 = 2²³‌。

通过以上步骤可清晰得出答案为‌B. 2²³‌。
</t>
<t tx="swot.20250509235804.1">某文件管理系统采用位示图(bitmap)记录磁盘的使用情况。
如果系统的字长为 32 位（指计算机一次可以处理的数据位数为32位），
磁盘物理块的大小为 4MB，物理块依次编号为：0、1、2、位示图字依次编号为：0、1、2，
那么 16385 号物理块的使用情况在位示图中的第（ ）个字中描述;
如果磁盘的容量为 1000GB，那么位示图需要（ ）个字来表示。

---

关于 16385 号物理块在位示图中的位置计算，正确的答案确实是‌**512**‌（从0开始编号），而不是511。以下是详细解释：

1. 16385 号物理块的位置计算

- 物理块编号从‌**0**‌开始，因此16385号物理块实际上是第‌**16386**‌个物理块（因为编号 0 是第 1 块）‌。
- 每个字长为 32 位，可表示 32 个物理块的状态。
- 计算：
  ** 字数 = 16386​ / 32 = 512.0625
  ** 取整数部分，得到‌**512**‌（从0开始编号的字序号）‌。

2. 1000GB 磁盘的位示图字数计算

- 磁盘容量 = 1000GB = 1000 * 1024MB = 1,024,000MB。
- 每个物理块大小 = 4MB，因此物理块总数 = 1,024,000 / 4 ​= 256,000 个。
- 每个字表示 32 个物理块，所需字数 = 32 * 256,000 = 8,000个字‌。

最终答案：

- 16385号物理块在位示图中的第‌ 512 个字中描述；
- 1000GB磁盘的位示图需要‌ 8,000 个字来表示‌。

---

*继续解释：*

&gt; 每个字长为 32 位（即一个字里有 32 个 bit），**每个 bit 表示一个物理块的状态**，而每个物理块大小为 **4MB**。

换句话说：

- 一个 bit → 表示一个 4MB 的物理块是否已被使用（0 表示空闲，1 表示占用）

- 一个 32 位的字（即 4 字节）→ 可以表示 **32 个 4MB 的物理块** 的使用情况；

- 所以：一个字可管理的总磁盘空间为：`32 × 4MB = 128MB`。

举个简单：

假设磁盘只有 128MB，块大小是 4MB，那么：

- 总共有 `128 ÷ 4 = 32` 个块；
- 只需要一个 32 位的字（4 字节）就能用位示图来表示这 32 个块的使用情况。

总结：“每个字长为 32 位，可表示 32 个物理块的状态”指的是：

- **每个位对应一个 4MB 的物理块**。
</t>
<t tx="swot.20250510083353.1">设用 2K×4 位的存储器芯片组成 16K×8 位的存储器（地址单元为 0000H~3FFFH，每个芯片的地址空间连续)，则地址单元 *0B1FH* 所在芯片的最小地址编号为（ ）。

*A* 0000H; *B* 0800H; *C* 2000H; *D* 2800H;

先分析问题：

***

1. 什么是「2K×4位的芯片」？

- 「2K」表示有 **2 × 1024 = 2048** 个地址单元
- 「4位」表示每个地址单元存的是 **4位数据**（半个字节）

2. 我们要做一个「16K × 8位」的存储器

- 「16K」表示有 **16 × 1024 = 16384** 个地址单元
- 每个地址要存 **8 位数据**（1 个字节）

---

*怎么用小芯片拼出大存储器？*

现在有很多个「2K × 4位」的小芯片。要拼成「16K × 8位」的存储器：

第一步：数据宽度

- 每个芯片只有 4 位，但我们需要 8 位 → 所以 **要用两个芯片拼起来**
- 一个管高 4 位，一个管低 4 位，所以每个地址要用 **2 个芯片**。

第二步：地址数量

- 每个芯片能放 2K 个地址，但我们需要 16K 个地址，所以需要
 16K / 2K = **8 组地址区间**

每组地址，需要 2 个芯片（见上一步），所以总共是：**8 组 × 2 个芯片 = 16 个芯片**。

---

看看题目问什么？

&gt; 地址单元 0B1FH（十六进制）是在哪个芯片中？这个芯片的起始地址是多少？

把 0B1F₁₆ 换成十进制 `0B1F₁₆ = 2847₁₀`，然后我们看一下每组芯片的地址范围是多大：

- 每组是 2K 地址 → 2048 个地址

所以地址分组是这样的：

[caption=]
[cols="^1,1",options="header"]
|===
| 区块编号 | 地址范围（十六进制）
| 0   | 0000H ~ 07FFH -&gt; (0000 ~ 2047)
| 1   | 0800H ~ 0FFFH -&gt; (2048 ~ 4095)
| 2   | 1000H ~ 17FFH -&gt; (4096 ~ 6143)
| ……  | ……
| 7   | 3800H ~ 3FFFH -&gt; (14335 ~ 16383)
|===

那 0B1F 属于哪组？

看看 0B1F 在不在 0800H ~ 0FFFH 里？ +
是的！属于 **第 1 组**（编号为 1）

---
所以这个芯片的最小地址是：**0800H**，最后答案是：**B. 0800H**。
</t>
<t tx="swot.20250510111143.1">某指令流水线由 4 段组成，各段所需要的时间如下图所示。连续输入 8 条指令时的吞吐率(单位时间内流水线所完成的任务数或输出的结果数)为()

[graphviz, target="img/graphviz-2025-05-10-120508", format=svg]
....
digraph pipeline {
    rankdir=LR;
    node [shape=box];
    start [label="", width=0, height=0, shape=none];
    end   [label="", width=0, height=0, shape=none];

    start -&gt; dt1 -&gt; dt2 -&gt; dt3 -&gt; dt4 -&gt; end;
    start [label=""];
    dt1 [label="Δt"];
    dt2 [label="2Δt"];
    dt3 [label="3Δt"];
    dt4 [label="Δt"];
}
....

A. 8/56Δt
B. 8/32Δt
C. 8/28Δt
D. 8/24Δt

****
根据题目描述，某指令流水线由4段组成，各段所需时间分别为Δt、2Δt、3Δt、Δt。连续输入8条指令时的吞吐率计算如下：

. 流水线周期‌：由最长段决定，即3Δt。
. 总执行时间‌：
  * 第一条指令完成时间 = 各段时间和 = Δt + 2Δt + 3Δt + Δt = 7Δt。
  * 后续7条指令每间隔一个周期（3Δt）完成，因此**总时间 = 7Δt + 7×3Δt = 28Δt**。
. 吞吐率‌：完成任务数（8条）除以总时间（28Δt），即 ‌8/28Δt‌。

因此，正确答案为 ‌C‌。
****
</t>
<t tx="swot.20250510115002.1">https://graphviz.org/download/

Install:

    brew install graphviz


.state machine 状态机
[graphviz, target="img/graphviz-2025-05-10-115048", format=svg]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape = doublecircle]; 2;
    node [shape = circle];

    0 -&gt; 1 [label = "ε"];
    1 -&gt; 2;
}
....

***

.instruction pipeline 指令流水线
[graphviz, target="img/graphviz-2025-05-10-120508", format=svg]
....
digraph pipeline {
    rankdir=LR;
    node [shape=box];
    start [label="", width=0, height=0, shape=none];
    end   [label="", width=0, height=0, shape=none];

    start -&gt; dt1 -&gt; dt2 -&gt; dt3 -&gt; dt4 -&gt; end;
    start [label=""];
    dt1 [label="Δt"];
    dt2 [label="2Δt"];
    dt3 [label="3Δt"];
    dt4 [label="Δt"];
}
....
</t>
<t tx="swot.20250510124842.1">// 编译原理，上下有好几集 https://www.bilibili.com/video/BV1TQ4y1D7Vk

下图所示为一个不确定有限自动机(NFA)的状态转换图，与该 NFA 等价的 DFA 是 ()

.解析：NFA 正规集 0 (0|11*) 0 -&gt; *答案为 C*
[graphviz, target="img/graphviz-2025-05-10-125143-NFA", format=svg]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape = doublecircle]; S5;
    node [shape = circle];
    start [label="", width=0, height=0, shape=none];

    start -&gt; S0;
    S0 -&gt; S1 [label = "0"];
    S1 -&gt; S4 [label = "0"];
    S1 -&gt; S2 [label = "ε"];
    S2 -&gt; S3 [label = "1"];
    S3 -&gt; S2 [label = "ε"];
    S3 -&gt; S4 [label = "ε"];
    S4 -&gt; S5 [label = "0"];
}
....

IMPORTANT: DFA 不允许有 ε 空输入。

.选项 A -&gt; 正规集为 01*0;
[graphviz, target="img/graphviz-2025-05-10-125311-A", format=svg]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape=doublecircle, label=""]; End
    node [shape = circle];
    start [label="", width=0, height=0, shape=none];

    start -&gt; S0;
    S0 -&gt; S1  [label = "0"];
    S1 -&gt; S1  [label = "1"];
    S1 -&gt; End [label = "0"];
}
....

.选项 B -&gt; 正规集为 001*0
[graphviz, target="img/graphviz-2025-05-10-125444-B", format=svg]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape=doublecircle, label=""]; End
    node [shape = circle];
    start [label="", width=0, height=0, shape=none];

    start -&gt; S0;
    S0 -&gt; S1  [label = "0"];
    S1 -&gt; S2  [label = "0"];
    S2 -&gt; S2  [label = "1"];
    S2 -&gt; End [label = "0"];
}
....

.选项 C -&gt; 正规集为 0(0|11*)0
[graphviz, target="img/graphviz-2025-05-10-125457-C", format=svg]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape=doublecircle, label=""]; End
    node [shape = circle];
    start [label="", width=0, height=0, shape=none];

    start -&gt; S0;
    S0 -&gt; S1  [label = "0"];
    S1 -&gt; S2  [label = "0"];
    S1 -&gt; S2  [label = "1"];
    S2 -&gt; S2  [label = "1"];
    S2 -&gt; End [label = "0"];
}
....

.选项 D -》 正规集为 01*00
[graphviz, target="img/graphviz-2025-05-10-125519-D", format=svg]
....
digraph finite_state_machine {
    rankdir=LR;
    node [shape=doublecircle, label=""]; End
    node [shape = circle];
    start [label="", width=0, height=0, shape=none];

    start -&gt; S0;
    S0 -&gt; S1  [label = "0"];
    S1 -&gt; S2  [label = "0"];
    S1 -&gt; S1  [label = "1"];
    S2 -&gt; End [label = "0"];
}
....
</t>
<t tx="swot.20250510130542.1"></t>
<t tx="swot.20250510130542.2">已知函数 f()、g()）的定义如下所示，调用函数 f 时传递给形参 x 的值是 5。 +

* 若 g(a) 采用**引用调用（callbyreference）**方式传递参数，则函数 f 的返回值为（请作答此空）；

* 若 g(a) 采用**值调用（callbyvalue）**的方式传递参数，则函数 f 的返回值（ ）。

* 其中，表达式 “x&gt;&gt;1” 的含义是将 x 的值右移 1 位，相当于 x 除以 2。

.f(int x)
[source,c]
----
int a = x &gt;&gt; 1;
g(a);
return a + x;
----

.g(int x)
[source,c]
----
x = x * (x + 1);
return;
----

选项:

* A 35
* B 32
* C 11
* D 7

答案: 第一空为 C; 第二空为 D

****
- 传值调用：形参取的是实参的值，形参的改变不会导致调用点所传的实参的值发生改变。
- 引用（传址）调用：形参取的是实参的地址，即相当于实参存储单元的地址引用，因此其值的改变同时就改变了实参的值。

1. 本题中，a=x&gt;&gt;1，x 值为 5，右移操作相当于除以 2，如果结果出现小数部分，则自动向下取整，所以 a=2；
2. 采用传值调用时，由于 g(a) 对数据 x 的运算不会影响原来 x 的值，所以 a + x = 2 + 5 = 7；
3. 采用引用调用时，由于 g(a) 对数据 x 的运算会影响原来 x 的值，当执行 g(a) 后 x 的值为 6，所以 a + x = 6 + 5 = 11 。
****
</t>
<t tx="swot.20250510131711.1"></t>
<t tx="swot.20250510131821.1">设有关系模式 R（课程，教师，学生，成绩，时间，教室），其中函数依赖集 F 如下：

    F＝{
         课程 -&gt;-&gt; 教师，
        (学生，课程) -&gt; 成绩，
        (时间，教室) -&gt; 课程，
        (时间，教师) -&gt; 教室，
        (时间，学生) -&gt; 教室
    }

问题：

* 关系模式 R 的一个主键是 （1）
* R 规范化程度最高达到 （2）
* 若将关系模式 R 分解为三个关系模式

    R1（课程，教师）
    R2（学生，课程，成绩）
    R3（学生，时间，教室，课程 ），

其中 R2 的规范化程度最高达到 （3） 。

***

[discrete]
==== 该题目简化版为

我们有一个表格 `R`，包含6个字段：
‌**课程、教师、学生、成绩、时间、教室**‌，已知这些字段之间有如下关联规则（函数依赖）：

1. 一门课程可能对应多个教师（课程→→教师）
2. 学生+课程可以确定成绩（学生,课程→成绩）
3. 时间+教室可以确定课程（时间,教室→课程）
4. 时间+教师可以确定教室（时间,教师→教室）
5. 时间+学生可以确定教室（时间,学生→教室）

问题：

1. ‌**主键是什么？**‌
2. ‌**这个表格设计最高满足第几范式（1NF/2NF/3NF/BCNF）？**‌
3. ‌**如果把表格拆成三个小表，其中 R2(学生,课程,成绩) 最高满足第几范式？**‌

---

[discrete]
==== 第一步：找主键（问题1）

‌**主键**‌ 是能唯一确定一行数据的最小字段组合。**怎么找？**‌
尝试用最少的字段组合，看看能否推导出所有其他字段。

‌**候选组合：`(时间,学生)`**‌

- 已知 `时间+学生→教室`（规则5）
- 已知 `时间+教室→课程`（规则3）→ 所以 `时间+学生→课程`
- 已知 `学生+课程→成绩`（规则2）→ 所以 `时间+学生→成绩`
- 课程 -&gt;-&gt; 教师（规则1，但教师是多值依赖，不影响主键）

✅ ‌**结论**‌：`(时间,学生)` 能推出所有字段，是主键。

---

[discrete]
==== 第二步：判断范式（问题2）

‌**范式升级路线**‌：1NF → 2NF → 3NF → BCNF → 4NF
我们逐步检查：

1. ‌**1NF**‌：表格没有重复列（比如没有“电话1,电话2”这种），每个字段都是不可再分的原子数据项，满足 ✅

2. ‌**2NF**‌：要求所有非主属性（成绩、教室、课程、教师）必须‌**完全依赖**‌主键（不能只依赖主键的一部分）。

  - 主键是 `(时间,学生)`，它由两个字段组成。
  - 检查是否有字段只依赖`时间`或只依赖`学生`？
    - `成绩`依赖`(学生,课程)`，而`课程`又依赖`(时间,学生)` → 间接完全依赖主键 ✅
    - `教室`直接依赖`(时间,学生)` ✅
    - `教师`依赖`课程`（多值依赖），但`课程`依赖主键 ✅
  - 满足2NF ✅
3. ‌**3NF**‌：要求非主属性‌**不能传递依赖**‌主键（即不能有 A→B→C 这种链式依赖）。

  - 发现传递依赖：
    `(时间,学生)→教室`，且`(时间,教室)→课程` → 即 `(时间,学生)→教室→课程` ❌
  - 还有多值依赖 `课程→→教师` ❌
  - ‌**不满足3NF**‌，最高到2NF。

---

[discrete]
==== 第三步：分解后的R2范式（问题3）

分解后的小表 `R2(学生,课程,成绩)`：

- ‌**函数依赖**‌：`(学生,课程)→成绩`
- ‌**主键**‌：`(学生,课程)`

检查范式：

1. ‌**1NF**‌：满足 ✅
2. ‌**2NF**‌：非主属性`成绩`完全依赖主键（没有部分依赖） ✅
3. ‌**3NF**‌：没有传递依赖（只有`(学生,课程)→成绩`一条直接依赖） ✅
4. ‌**BCNF**‌：所有依赖的左部都是候选键（这里依赖的左部`(学生,课程)`本身就是主键） ✅

✅ ‌**R2最高满足BCNF**‌。

---

[discrete]
==== 最终答案

1. 主键：‌**(时间,学生)**‌
2. 原表R最高满足：‌**2NF**‌
3. 分解后的R2最高满足：‌**BCNF**‌

---

[discrete]
==== 举个实际例子

假设有一个选课表：

[caption=]
[cols="6*",options="header"]
|===
| 时间  | 学生  | 教室  | 课程  | 教师  | 成绩
| 周一9:00 | 张三  | 101 | 数学  | 王老师 | 90
| 周一9:00 | 李四  | 101 | 数学  | 王老师 | 85
|===

- ‌**主键**‌：`(时间,学生)`（比如“周一9:00+张三”能唯一确定一行）
- ‌**问题**‌：
  * 如果王老师换了，所有相关行都要修改（数据冗余）→ 不满足3NF
  * 拆成小表后（如R2只存学生-课程-成绩），冗余消失 → 满足BCNF

---

[discrete]
==== 你需要记住的套路

1. ‌**找主键**‌：从最小字段组合出发，尝试推导所有其他字段。
2. ‌**判断范式**‌：
  - 2NF：非主属性必须完全依赖主键
  - 3NF：不能有传递依赖
  - BCNF：所有依赖的左部必须是候选键
3. ‌**多值依赖**‌（→→）需 4NF 去解决，但题目中因传递依赖先卡在2NF。

***

该视频 1NF/2NF/3NF 讲得清楚 https://www.youtube.com/watch?v=rHiyuR2bElE

image::img/Snipaste_2025-05-10_17-21-37.png[1NF-2NF-3NF,520]
</t>
<t tx="swot.20250510173155.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032352d30352d31307103752e">给定关系 R(A，B，C，D) 和关系 S(A，D，E，F)

* 若对这两个关系进行自然连接运算 R▷◁S 后的属性列有（ ）个;
* 关系代数表达式 σR.B&gt;S.F(R▷◁S) 与（ ）等价。

    A  σ2&gt;8(RxS)
    B  π1，2，3，4，7，8(σ1=5^2&gt;8^4=6(R×S)
    C  σ"2"&gt;"8"(RxS)
    D  π1，2，3，4，7，8(σ1=5^"2"&gt;"8"^4=6(RxS))

***

*理解题目中的符号和概念‌*

1. ‌关系（表）的结构‌
    * R(A, B, C, D)‌：这是一个名为 R 的表，有 4 列（属性），分别是 A, B, C, D。
    * S(A, D, E, F)‌：这是一个名为 S 的表，有 4 列（属性），分别是 A, D, E, F。

2. ‌自然连接（Natural Join, R▷◁S）‌
    * 作用‌：将两个表按照‌相同的列名‌自动连接起来，并‌合并相同名称的列‌。
    * 规则‌：
        ** 如果两个表有相同名称的列（这里是 A 和 D），则连接时只保留一份。
        ** 最终结果的列是所有‌不重复的列‌的组合。

    * 举例‌：
        ** R 的列：A, B, C, D
        ** S 的列：A, D, E, F
        ** ##自然连接后，A 和 D 只保留一份，所以结果是：A, B, C, D, E, F（共 6 列）。##

3. ‌选择运算（σ）‌
    * 作用‌：从表中筛选出满足条件的行（类似于 SQL 的 WHERE）。
    * 例如：σR.B &gt; S.F(R▷◁S) 表示从 R▷◁S 的结果中筛选出 R.B &gt; S.F 的行。

TIP: 希腊字母 σ（sigma） 的中文读音是 “西格玛”（拼音：xī gé mǎ）。
</t>
<t tx="swot.20250510173155.2">问题1‌：自然连接 R▷◁S 后有多少列？

* 我们已经知道：
    ** R 的列：A, B, C, D
    ** S 的列：A, D, E, F

* 自然连接会合并相同名称的列（A 和 D），所以结果是：
    ** A, B, C, D, E, F（共 6 列）。
</t>
<t tx="swot.20250510173155.3">问题2‌：σR.B &gt; S.F(R▷◁S) 等价于哪个选项？

* 我们需要找到一个等价的关系代数表达式。
* 题目给出的选项是：

    A: σ2&gt;8(R×S)
    B: π1,2,3,4,7,8(σ1=5∧2&gt;8∧4=6(R×S))
    C: σ"2"&gt;"8"(R×S)
    D: π1,2,3,4,7,8(σ1=5∧"2"&gt;"8"∧4=6(R×S))

*关键点‌：*

1. R×S 是‌笛卡尔积‌（Cartesian Product），即 R 和 S 的所有可能组合，会有 4 + 4 = 8 列：
    * 列顺序：R.A, R.B, R.C, R.D, S.A, S.D, S.E, S.F（即第1-8列）。

2. 自然连接 R▷◁S 实际上是：
    * 先做 R×S，
    * 然后筛选 R.A = S.A 且 R.D = S.D 的行（因为自然连接要求相同列的值相等），
    * 最后去掉重复的 A 和 D（即保留 R.A, R.B, R.C, R.D, S.E, S.F）。

3. σR.B &gt; S.F(R▷◁S) 的意思是：
    * 在自然连接的结果中，筛选 R.B &gt; S.F 的行。

*如何用 R×S 表示？‌* 我们需要：

    . 先做 R×S（8列）。
    . 筛选 R.A = S.A（即第1列 = 第5列）和 R.D = S.D（即第4列 = 第6列）。
    . 再筛选 R.B &gt; S.F（即第2列 &gt; 第8列）。
    . 最后投影需要的列（A, B, C, D, E, F，即第 1,2,3,4,7,8 列）。

对应选项‌：

π1,2,3,4,7,8(σ1=5∧2&gt;8∧4=6(R×S))（选项B）：

    1=5：R.A = S.A
    4=6：R.D = S.D
    2&gt;8：R.B &gt; S.F
    π1,2,3,4,7,8：保留 A, B, C, D, E, F。

为什么其他选项不对？‌

    A: 缺少 R.A = S.A 和 R.D = S.D 的条件。
    C: 引号错误（"2"&gt;"8" 是字符串比较，不是列号）。
    D: 引号错误（同C）。

第三步：总结答案‌

1. 自然连接 R▷◁S 后有 ‌6列‌（A, B, C, D, E, F）。
2. σR.B &gt; S.F(R▷◁S) 等价于 ‌选项B‌：
  * π1,2,3,4,7,8(σ1=5∧2&gt;8∧4=6(R×S))。
</t>
<t tx="swot.20250510173155.4">[caption=]
.R 表：
[cols="4*", width=50%]
|===
|A	 |B 	|C 	 |D
|1	 |5	 |10	 |20
|2	 |8	 |15	 |30
|===

[caption=]
.S 表：
[cols="4*", width=50%]
|===
|A |D  |E   |F
|1 |20 |100 |3
|2 |30 |200 |7
|===

自然连接 R▷◁S 的结果‌：

* 匹配 R.A = S.A 且 R.D = S.D：
** 第1行：(1,5,10,20) 和 (1,20,100,3) → (1,5,10,20,100,3)
** 第2行：(2,8,15,30) 和 (2,30,200,7) → (2,8,15,30,200,7)
* 结果：
+
[caption=]
[cols="6*", width=75%]
|===
|A |B	|C 	|D	 |E	  |F
|1 |5	|10	|20	|100	|3
|2 |8	|15	|30	|200	|7
|===

筛选 R.B &gt; S.F‌：

* 第1行：5 &gt; 3 → 保留
* 第2行：8 &gt; 7 → 保留
* 结果和上面一样。

用选项 B 的方式计算‌：

1. 先做 R×S（4 行 8 列）：
    * 第1行：(1,5,10,20,1,20,100,3)
    * 第2行：(1,5,10,20,2,30,200,7)
    * 第3行：(2,8,15,30,1,20,100,3)
    * 第4行：(2,8,15,30,2,30,200,7)

2. 筛选 1=5 且 4=6 且 2&gt;8：
    * 第1行：1=1 且 20=20 且 5&gt;3 → 保留
    * 第4行：2=2 且 30=30 且 8&gt;7 → 保留

3. 投影 1,2,3,4,7,8：
    * 第1行：(1,5,10,20,100,3)
    * 第4行：(2,8,15,30,200,7)

结果和自然连接一致。

最终答案‌

* 自然连接后的列数：‌6列‌
* 等价的关系代数表达式：‌选项B‌
</t>
<t tx="swot.20250510175502.1">数据的物理独立性和逻辑独立性分别是通过修改（ ）来完成的。

A 外模式与内模式之间的映像、模式与内模式之间的映像

B 外模式与内模式之间的映像、外模式与模式之间的映像

C 外模式与模式之间的映像、模式与内模式之间的映像

D 模式与内模式之间的映像、外模式与模式之间的映像

答案：D
</t>
<t tx="swot.20250510175912.1"></t>
<t tx="swot.20250510175912.2">符号	含义	示例：

* 实心菱形	组合（Composition）	房子包含房间

* 空心菱形	聚合（Aggregation）	班级聚合学生

* 空心三角形箭头	泛化（继承）	猫继承自动物

* 普通箭头/连线	关联	员工参与项目

</t>
<t tx="swot.20250510180235.1"></t>
<t tx="swot.20250510180303.1">考生需要掌握 OSI七层模型 的每一层的功能和作用

[caption=]
.OSI 的七层模型
[cols="2,1,4,2,2,2"]
|===
|子网 |速记  2+^|过去标准7层 |将来标准5层 |实际应用4层

.3+.^| 资源子网  |用  |FTP、SMTP、POP3(IMAP)、HTTP(s)                  |7 应用层   .3+.^|5 应用层（报文）   .3+.^|4 应用层
                |试  |数据格式转换 / 数据加解密 / 数据解压缩              |6 表示层
                |会  |建立、维护、释放、管理、控制连接                    |5 会话层

.4+.^| 通信子网  |叔 |TCP/UDP（报文段） 端到端的数据传输服务                   |4 传输层       |4 传输层（报文段）       |3 传输层（TCP/UDP）
                |网 |在路由器上实现 ICMP、ARP、RARP、IP、IGMP           |3 网络层       |3 网络层（数据报）       |2 网络层
                |链 |交换机(可以连接多个以太网的网桥)、网桥（封装成帧、差错控制CRC、流量控制ppp协议）-&gt; 一组bit  |2 数据链路层    |2 数据链路层（帧）  .2+.^|1 网络接口层
                |物 |集线器(模拟信号)、中继器(数字信号)来传输比特流-&gt;单个bit |1 物理层        |1 物理层（比特）
|===


下面是个参考图，注意理解一下概念和三要素:

image::img/osi7layer-2025-05-10-180416.png[OSI,840]
</t>
<t tx="swot.20250510180303.2">好的，以下是一些关于OSI七层模型和TCP/IP四层模型的真题，适合软件设计师考试的难度：

[discrete]
==== 选择题
1. **关于OSI模型和TCP/IP模型的描述，以下正确的是（ ）**
   A. OSI模型的传输层与TCP/IP模型的传输层功能完全相同。
   B. TCP/IP模型的网络接口层包括了OSI模型的数据链路层和物理层的功能。
   C. OSI模型的应用层和TCP/IP模型的应用层功能完全相同。
   D. TCP/IP模型比OSI模型层次更多。
   **答案：B**

2. **在OSI模型中，负责将数据分段并提供可靠传输的是（ ）**
   A. 物理层
   B. 数据链路层
   C. 网络层
   D. 传输层
   **答案：D**

3. **以下协议中，属于TCP/IP模型网络层的是（ ）**
   A. HTTP
   B. TCP
   C. IP
   D. FTP
   **答案：C**

4. **在OSI模型中，负责建立、维护和终止会话的是（ ）**
   A. 表示层
   B. 会话层
   C. 传输层
   D. 应用层
   **答案：B**

5. **以下关于TCP和UDP的描述，正确的是（ ）**
   A. TCP是无连接的协议，UDP是面向连接的协议。
   B. UDP提供可靠传输，TCP提供不可靠传输。
   C. TCP适用于对实时性要求较高的场景，UDP适用于对可靠性要求较高的场景。
   D. TCP和UDP都工作在TCP/IP模型的传输层。
   **答案：D**

[discrete]
==== 填空题
1. **在OSI模型中，负责将数据帧传输到物理介质上的是________层。**
   **答案：物理层**

2. **TCP/IP模型的________层包括了OSI模型的数据链路层和物理层的功能。**
   **答案：网络接口层**

3. **在TCP/IP模型中，负责数据包路由和转发的是________层。**
   **答案：网络层**

4. **OSI模型的________层负责数据的格式化、加密和压缩。**
   **答案：表示层**

5. **TCP/IP模型的________层提供端到端的通信服务。**
   **答案：传输层**

[discrete]
==== 简答题
1. **简述OSI七层模型中传输层的主要功能，并说明TCP和UDP的区别。**
   **答案：**
   - **传输层功能**：负责端到端的数据传输服务，包括数据分段、错误检测与纠正、流量控制等。
   - **TCP与UDP的区别**：
     - TCP是面向连接的协议，提供可靠传输，适用于对数据完整性要求较高的场景。
     - UDP是无连接的协议，提供不可靠传输，适用于对实时性要求较高的场景。

2. **OSI模型和TCP/IP模型的主要区别是什么？**
   **答案：**
   - OSI模型是理论模型，层次划分更细（七层），主要用于教学和理论研究。
   - TCP/IP模型是实际应用模型，层次更精简（四层），是现代网络通信的基石。
   - OSI模型的会话层、表示层和应用层在TCP/IP模型中被合并为应用层；OSI模型的数据链路层和物理层在TCP/IP模型中被合并为网络接口层。

3. **简述TCP/IP模型中网络接口层的主要功能。**
   **答案：**
   - 网络接口层负责网络包在物理网络中的传输，包括MAC寻址、错误检测以及通过网卡传输网络帧等。它将IP数据报封装成适合物理网络传输的帧格式，并负责将帧发送到物理介质上。
</t>
<t tx="swot.20250510182531.1"></t>
<t tx="swot.20250510182608.1">.总体:
image::img/ip-data-2025-05-10-193237.png[总体,840]

.细节:
image::img/ip-data-2025-05-10-193246.png[细节,840]


https://www.bilibili.com/video/BV1UM41167sP

https://www.bilibili.com/video/BV1Ce411N7Ph

</t>
<t tx="swot.20250510182608.2">数据报总长度4000B

.例题
image::img/ip-data-2025-05-10-193257.png[例题,840]

https://www.bilibili.com/video/BV1Ce411N7Ph
</t>
<t tx="swot.20250510182608.3">[discrete]
=== **IP 数据报分片的描述**

**题目**：假设一个 IP 数据报总长度为 4000 字节，要经过一段 MTU 为 1500 字节的链路，该 IP 数据报必须经过分片才能通过该链路。以下关于分片的描述中，正确的是（ ）

- A. 该原始 IP 数据报是 IPv6 数据报
- B. 分片后的数据报将在通过该链路后的路由器进行重组
- C. 数据报需分为三片，这三片的总长度为 4000 字节
- D. 分片中的最后一片，标志位 Flag 为 0，Offset 字段为 370

**答案**：D

---

**解析**：

- A. 选项:
+
====
* IPv6 数据报在设计上尽量避免分片。根据 IPv6 的协议规定，源端和目的端之间的链路必须能够支持至少1280字节的MTU（最大传输单元）。如果一个 IPv6 数据报的长度超过了链路的 MTU，那么在 IPv6 中，通常是由源端来处理分片问题，而不是像 IPv4 那样由中间路由器进行分片。而且，题目中提到的 4000 字节的IP数据报需要经过 MTU 为 1500 字节的链路进行分片，这种场景更符合 IPv4 的分片机制。

* IPv6 更倾向于使用路径MTU发现机制，即在数据报发送之前，通过探测路径上的最小MTU来避免分片。如果发现路径上的MTU小于数据报长度，IPv6会返回一个“分片需要但不允许分片”（Fragmentation Needed but Don't Fragment was Set）的ICMPv6错误消息，而不是像IPv4那样直接进行分片。
====

- B. 选项也是错误的。
+
====
原因分析，在 IP 协议中，无论是 IPv4 还是 IPv6，分片和重组的机制都有明确的规定：

1. **IPv4分片和重组机制**：
   - 在 IPv4 中，分片是由中间路由器完成的。当一个 IPv4 数据报的长度超过链路的 MTU 时，中间路由器会将其分割成多个较小的分片。
   - 重组则是在**最终目的主机**上完成的，而不是在中间路由器上。中间路由器只负责转发分片的数据报，不会对分片进行重组。

2. **IPv6 分片和重组机制**：
   - IPv6 尽量避免中间路由器进行分片。如果需要分片，通常是在**源端**进行分片。
   - 重组同样是在**最终目的主机**上完成的。

因此，无论是 IPv4 还是 IPv6，分片后的数据报都是在**最终目的主机**上进行重组的，而不是在中间路由器上。
====

- C. 分包后多了 2 个 20B，所以肯定大于 4000B

- D. 正确分析
+
====
- 数据报总长度为 4000 字节，IP首部通常为 20 字节，因此数据部分为 3980 字节。
- MTU为 1500 字节，减去 IP 首部后，每个分片的数据部分最大为 1480 字节。
- 分片情况如下：
  ** 第一片：20字节首部 + 1480字节数据 + 偏移 0
  ** 第二片：20字节首部 + 1480字节数据 + 偏移 185 （1480/8=185）
  ** 第三片：20字节首部 + 1020字节数据 + 偏移 370
- 最后一片的标志位 MF 为 0，表示这是最后一片。
- 偏移量为 370，表示最后一片在原始数据报中的位置。
====
</t>
<t tx="swot.20250510182608.4">[discrete]
===  **IP数据报分片计算**

**题目**：假设一个IP数据报总长度为 3000 字节，要经过一段 MTU 为 1500 字节的链路，该 IP 数据报必须经过分片才能通过该链路。该原始 IP 数据报需被分成（ ）个片，若 IP 首部没有可选字段，则最后一个片首部中的 Offset 字段为（ ）。

- A. 2
- B. 3
- C. 4
- D. 5

**答案**：B

**Offset字段选项**：

- A. 370
- B. 740
- C. 1480
- D. 2960

**答案**：A

**解析**：

- 数据报总长度为 3000 字节，IP 首部为 20 字节，数据部分为 2980 字节。
- 每个分片的最大数据部分为 1480 字节（1500 - 20）。1480/8 能除浄

- 分片情况如下：
  * 第一片：20字节首部 + 1480字节数据
  * 第二片：20字节首部 + 1480字节数据
  * 第三片：20字节首部 + 20字节数据
- 最后一片的偏移量为 370

</t>
<t tx="swot.20250510182608.5">[discrete]
=== IP 数据报分片字段的作用

**题目**：IP 数据报的分段和重装配要用到报文头部的（ ）个字段。其中，分片偏移字段（段偏置值）表示数的单位是（ ）字节；标记字段M标志（MF位）为 0 表示（ ）。

- A. 1
- B. 2
- C. 3
- D. 4

**答案**：D

- A. 4
- B. 8
- C. 1
- D. 13

**答案**：B

- A. 不能分片
- B. 允许分片
- C. 之后还有分片
- D. 最后一个分片

**答案**：D

**解析**：

- 分片需要使用 总长度、标识符、标志字段（MF位）、分片偏移字段共 4 个字段。具体解释参下面详解。
- 分片偏移字段的单位是 8 字节。
- MF 位为 0 表示这是最后一个分片。

---

IP 数据报的分段与重装配涉及以下 ‌4 个关键字段‌：

1. 总长度（Total Length）‌，16 位字段，表示数据报首部与数据部分的总长度（单位为字节），用于分片后重组数据报‌。

2. 标识符（Identification）‌，16 位字段，唯一标识同一数据报的所有分片，确保重装时归属正确‌。

3. 标记字段（Flags）‌，3 位字段，包含：

* MF（More Fragments）位‌：值为 0 时表示当前分片是最后一个分片，为 1 时表示后续还有分片‌。
* DF（Don’t Fragment）位‌：控制是否允许分片（值为 1 表示禁止分片）‌。

4. 分片偏移(Fragment Offset)，13 位字段，指示分片在原数据报中的相对位置，单位是 ‌8 字节‌（例如偏移值 1 对应实际位置 8 字节）‌。

总结‌: 题目中“报文头部的字段数”明确为 ‌4 个‌（标识符、总长度、分片偏移、标记字段）。
</t>
<t tx="swot.20250510193659.1">
image::img/ip-type-2025-05-10-193726.png[ip地址分类,720]

A类:

* 0.0.0.0 不能用（特殊IP）
* 0.255.255.255 不能用（特殊IP）
* 128-2 就剩下 126 个了

B类:

* 注意网络号是从 128.1 开始的
</t>
<t tx="swot.20250510201445.1">[cols="1,1,1,1,4"]
|===
| NetID 网络号 | HostID 主机号 | 作为源地址发送 | 作为目的地址接收 | 用途

| 全 0        | 全 0          | Y  | N  a| 1. 在本网络内，表示本机
                                            * 如尚未分配IP的设备，比如DHCP请求时 +
                                            * webserver 启动时配置为 0.0.0.0 表示本机
                                          2. 在路由表中表示默认路由，意思是“所有未匹配的流量都应该走这个路由”
| 全 0        | 特定值         | N  | Y  | 本网某个特定主机。如 0.0.0.5 表示“当前网络中的主机 5”  (#现代网络不用了#)
| 全 1        | 全 1          | N  | Y  | 本网广播地址 255.255.255.255
| 特定值       | 全 0          | N  | N  | 网络地址，表示一个网络  
| 特定值       | 全 1          | N  | Y  | 对特定网络所有主机广播地址  
| 127         | 任何非全 0/1   | Y  | Y  | 本地回环测试，回环地址  
|===
</t>
<t tx="swot.20250510201742.1">目标 IP 地址与子网掩码进行按位与(&amp;)操作，得到子网地址

image::img/ip-subnet-2025-05-10-201820.png[ip-subnet-mask, 1080]

</t>
<t tx="swot.20250510202838.1">
image::img/ip-v6-2025-05-10-202903.png[ipv6,1024]

</t>
<t tx="swot.20250510203357.1">RIP（Routing Information Protocol，路由信息协议）是一种内部网关协议（IGP），用于在小型或中等规模的自治系统（AS）内部的路由器之间交换路由信息。RIP 是最早被广泛使用的动态路由协议之一。

实际上这是应用层协议，走 UDP

RIP 报文最大为 20B * 25 + 4 = 504B

image::img/rip-2025-05-10-203457.png[rip1,1024]

image::img/rip-2025-05-10-203513.png[rip2,1024]


// https://www.bilibili.com/video/BV1184y1k76S
</t>
<t tx="swot.20250510203357.2">image::img/rip-2025-05-10-203533.png[rip-example,1024]
</t>
<t tx="swot.20250510204058.1">实际上这是应用层协议，走 TCP

https://www.bilibili.com/video/BV1xe411N7GP

image::img/RIP_OSPF_BGP-2025-05-10-204201.png[bgp,1024]

</t>
<t tx="swot.20250510204918.1">（ ）是右图的合法拓扑序列。

[graphviz, target="img/graphviz-2025-05-10-205110", format=svg]
....
digraph AOV {
    rankdir=LR;
    node [shape = circle];

    2 -&gt; 1;
    3 -&gt; 1;
    3 -&gt; 2;
    4 -&gt; 2;
    4 -&gt; 3;
    5 -&gt; 2;
    5 -&gt; 4;
    6 -&gt; 3;
    6 -&gt; 4;
}
....

    A 654321
    B 123456
    C 563421
    D 564213

答案：A

***

本题考查数据结构的基础知识。

拓扑排序是将AOV网中所有顶点排成一个线性序列的过程，并且该序列满足：若在 AOV 网中从顶点 vi 到 vj 有一条路径，则在该线性序列中，顶点 vi 必然在顶点 vj 之前。

对AOV网进行拓扑排序的方法如下：

(1)在AOV网中选择一个 #入度为零（没有前驱）的顶点# 且输出它；

(2)从网中删除该顶点及与该顶点有关的所有边；

(3)重复上述两步，直至网中不存在入度为零的顶点为止。

本题中只有序列“6 5 4 3 2 1”可由上述过程导出。

对有向图进行拓扑排序的结果会有两种情况：一种是所有顶点已输出，此时整个拓扑排序完成，说明网中不存在回路；另一种是尚有未输出的顶点，剩余的顶点均有前驱顶点，表明网中存在回路。
</t>
<t tx="swot.20250510214900.1">#下面的题是 IEEE 754标准（符号位 + 阶码 + 尾数） 以前的考试内容，应该是不会再考了，了解即可。#

某种机器的浮点数表示格式如下(允许非规格化表示)。若阶码以补码表示，尾数以原码表示，则 1000100000000001 表示的浮点数是（ ）。

    1位      4位      1位      10位
     ↑        ↑       ↑        ↑
    阶符     阶码     数符      尾数

单选：

    A 2^-16 × 2^-10
    B 2^-15 × 2^-10
    C 2^-16 ×（1-2^-10）
    D 2^-15 ×（1-2^-10）

***

题干尾数是原码为：0000000001，数符是 0，这表示该尾数是正数为 2^-10 。

阶码是 0001 是补码，转换成原码是 1111，是十进制的 15，这里注意阶符是 1（是单独的，没有与阶码混在一起），这表示阶码是负数，因此该浮点数是 2^-15 ×2^-10 。

NOTE: 这个题用到了负数的补码。
</t>
<t tx="swot.20250511103711.1">某软件项目的活动图如下图所示，其中顶点表示项目里程碑，连接顶点的边表示活动，边上的数字表示该活动所需的天数，则完成该项目的最少时间为（ ）天。活动BD最多可以晚（ ）天开始而不会影响整个项目的进度。

[graphviz, target="img/graphviz_critical-path-2025-05-11-104921", format=svg]
....
digraph critical_path {
    rankdir=LR;
    node [shape = circle];

    A -&gt; B [label = "2" color = "red"];
    B -&gt; C [label = "3" color = "red"];
    C -&gt; E [label = "5" color = "red"];
    E -&gt; H [label = "2"];
    H -&gt; L [label = "3"];

    E -&gt; F [label = "3" color = "red"];
    F -&gt; J [label = "2"];
    J -&gt; L [label = "1"];

    B -&gt; F [label = "4"];

    F -&gt; I [label = "5" color = "red"];
    I -&gt; K [label = "4" color = "red"];
    K -&gt; L [label = "2" color = "red"];

    B -&gt; D [label = "5"];
    D -&gt; G [label = "3"];
    G -&gt; I [label = "6"];
}
....


    A 9
    B 15
    C 22
    D 24

---
解析: 

* 根据上图计算出关键路径为 A-B-C-E-F-I-K-L，其长度为 24，关键路径上的活动均为关键活动。

* 活动BD不在关键路径上，包含该活动的最长路径为 A-B-D-G-I-K-L，其长度为 22，因此松弛时间为 2。
</t>
<t tx="swot.20250511104537.1"></t>
<t tx="swot.20250511104555.1"></t>
<t tx="swot.20250511104602.1"></t>
<t tx="swot.20250511112239.1">在磁盘上存储数据的排列方式会影响 IO 服务的总时间。假设每个磁道被划分成 10 个物理块，每个物理块存放1个逻辑记录。逻辑记录R1,R2....R10存放在同一个磁道上，记录的排列顺序如下表所示。

[caption=]
[cols="2,10*^",options="header"]
|===
|物理块数 | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10
|逻辑记录 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10
|===

假定磁盘的旋转速度为 10ms/周，磁头当前处在 R1 的开始处。

* 若系统顺序处理这些记录，使用单缓冲区，每个记录处理时间为 2ms,则处理这 10个 记录的最长时间为（D）;

    A 30ms
    B 60ms
    C 94ms
    D 102ms

* 若对存储数据的排列顺序进行优化，处理10个记录的最少时间为（ ）。

---

1. 磁头当前处于 R1 处，读取出 R1 的时间为 10ms/10=1ms，然后的使用单缓冲区处理，花费 2ms。R1 处理完毕后磁头此时已处于 R4 处，若是顺序读和处理 R2 则需要再等待 8ms，R2 的读取与处理时间与 R1 相同，当 R2 处理完毕再读取 R3 仍然需要再等待 8ms......依次类推，10 个记录读完处理完毕的时间一共是 102ms。

    * 计算：**总时间 = 3ms（R1）+ 9(R2到R10还剩9个没处理) × 11ms(每个3+8)= 102ms**

2. 若对存储数据的排列顺序进行优化，即在原先存放 R4 处，存放 R2，则十个记录的处理时间会缩短至 30ms。

**关键总结**

1. **读取时间**：是物理块从磁头下方通过的时间（10ms/周 ÷ 10块 = 1ms/块）。

2. **处理时间**：是程序处理数据的时间（题目给定2ms），期间磁盘仍在旋转。

3. **优化核心**：通过重排数据，让“处理时间”对应的磁盘旋转刚好定位到下一个记录，避免等待。

这样设计后，磁盘的物理特性（旋转延迟）被完全利用，实现了最短时间（30ms）。
</t>
<t tx="swot.20250511123650.1">@language asciidoc
对以下的程序伪代码（用缩进表示程序块）进行路径覆盖测试，至少需要（4）个测试用例。
采用McCabe度量法计算其环路复杂度为（4）。

[source,python]
----
输入 x, y, z
语句 1
if x &gt; 0:
    语句 2
    if y &gt; 0:
        语句 3
    else:
        语句 4
else:
    语句 5
    if z &gt; 0:
        语句 6
    else:
        语句 7
输出语句
----

---
本题考查软件测试的相关知识，要求考生能够熟练掌握典型的白盒测试方法。路径覆盖就是设计若干个测试用例，运行被测程序，使得程序中每条路径至少运行一次。

.画出上述伪代码的流程图如下：
[plantuml, target=img/diagram-test-2025-05-11-125828, format=svg]
....
@startuml
start
:输入 x, y;
:语句1;
if (x &gt; 0) then (yes)
    :语句2;
    if (y &gt; 0) then (yes)
        :语句3;
    else (no)
        :语句4;
    endif
else (no)
    :语句5;
    if (z &gt; 0) then (yes)
        :语句6;
    else (no)
        :语句7;
    endif
endif
:输出;
stop
@enduml
....

从图中很容易看出有四条路径：

* x &gt; 0 且 y &gt; 0（执行语句 1→2→3）
* x &gt; 0 且 y ≤ 0（执行语句 1→2→4）
* x ≤ 0 且 z &gt; 0（执行语句 1→5→6）
* x ≤ 0 且 z ≤ 0（执行语句 1→5→7）

因此设计 4 个测试用例分别运行上述四个路径即可满足路径覆盖。

---
**数判定节点（推荐！）**

公式：V(G)=判定节点数+1

步骤：

1. 在代码中数出所有的 if、else if、while、for、case 等分支语句。
2. 每个分支语句算 1个判定节点。
   * 判定节点数 = 3（x&gt;0、y&gt;0、z&gt;0）
3. 最后 +1 就是环路复杂度
   * V(G) = 3 + 1 = 4
</t>
<t tx="swot.20250511163631.1">可以构造出下图所示二叉排序树（二叉检索树、二叉查找树）的关键码序列是（ B ）。

.link:img/mermaid-2025-05-11-164301.svg[二叉排序树]
[mermaid, target=img/mermaid-2025-05-11-164301, format=svg]
....
flowchart TD
    23((23)) --- 17((17))
    23((23)) --- 40((40))
    17((17)) --- 10((10)) ---|right| 13((13))
    17((17)) --- 19((19))
    40((40)) --- 31((31)) ---|left| 27((27))
    40((40)) --- 91((91)) ---|left| 65((65))
....

    A 10 13 17 19 23 27 31 40 65 91
    B 23 40 91 17 19 10 31 65 27 13
    C 23 19 40 27 17 13 10 91 65 31
    D 27 31 40 65 91 13 10 17 23 19

---

要构造题目所示的二叉排序树，关键码序列需满足以下条件：

1. **根节点必须最先插入**：根节点是23，因此任何以其他数字开头的序列（如选项A、D）均可排除。
2. **父节点必须在子节点之前插入**：每个子节点的位置由其父节点的值决定，因此父节点必须已存在于树中。
3. **插入路径需符合树的层级关系**：##插入时需从根节点开始，逐层比较，最终定位到正确位置。##

**选项B的插入过程分析**：

[caption=]
[cols="1,5",options="header"]
|===
| 插入顺序 | 插入逻辑
| 23  | 作为根节点插入。
| 40  | 与23比较，40&gt;23，成为23的右子节点。
| 91  | 先与23比较，进入右子树，再与40比较，91&gt;40，成为40的右子节点。
| 17  | 先与23比较，17&lt;23，成为23的左子节点。
| 19  | 先与23比较，进入左子树，与17比较，19&gt;17，成为17的右子节点。
| 10  | 先与23比较，进入左子树，与17比较，10&lt;17，成为17的左子节点。
| 31  | 先与23比较，进入右子树，与40比较，31&lt;40，成为40的左子节点。
| 65  | 先与23比较，进入右子树，与40比较，进入右子树，与91比较，65&lt;91，成为91的左子节点。
| 27  | 先与23比较，进入右子树，与40比较，进入左子树，与31比较，27&lt;31，成为31的左子节点。
| 13  | 先与23比较，进入左子树，与17比较，进入左子树，与10比较，13&gt;10，成为10的右子节点。
|===

**为何有时与根节点比较，有时与父节点比较？**

- **插入始终从根开始**：每次插入新节点时，必须从根节点23开始逐层比较。例如，插入13时，虽然其父节点是10，但插入路径需经过23→17→10，最终确定13的位置。
- **路径依赖父节点顺序**：父节点的插入顺序决定了子节点的比较路径。例如，插入27时，路径为23→40→31，因为31已插入，才能进一步比较27的位置。

**错误选项分析**：

- 选项C：插入顺序为23,19,40,27,17,13,10,91,65,31。
  ** 插入19时，23的左子节点应为17，但19被错误地插入到左子树，导致后续17无法正确插入到23的左子树，结构混乱。
- 选项D：以27开头，根节点必须是23，因此排除。

**结论**：选项 B 的插入顺序严格遵循二叉排序树的构造规则，每个节点的父节点均在其之前插入，且路径正确，最终形成题目所示的树结构。因此，正确答案为：

**答案：B**
</t>
<t tx="swot.20250511180244.1">:stem: latexmath
设有一个 `64K×32` 位的存储器（每个存储单元为 `32` 位），其存储单元的地址宽度为（ B ）。

    A 15
    B 16
    C 30
    D 32

详细解释

1. **存储单元数量计算**：

   - "64K" 中的 "K" 表示 *1024*（即 stem:[2^{10}]），所以：
     stem:[64K = 64 \times 1024]

   - 而 stem:[64 = 2^6]，stem:[1024 = 2^{10}]，因此：
     stem:[64 \times 1024 = 2^6 \times 2^{10} = 2^{16}]

   - 最终得到存储单元总数：
     stem:[64K = 65{,}536 = 2^{16}]

2. **地址宽度计算**：
   - 要寻址 stem:[2^{16}] 个存储单元，需要的地址位数为：
     stem:[\log_2(2^{16}) = 16 \text{ 位}]
   - 因此，**地址宽度为 16 位**。

结论：通过指数运算可直接推导出，该存储器的 **地址宽度是 16 位**，正确答案为 **B**。

</t>
<t tx="swot.20250511182258.1">某货车运输公司有一个中央仓库和n个运输目的地，每天要从中央仓库将货物运输到所有的运输目的地，到达每个运输目的地一次且仅一次，最后回到中央仓库。在两个地点i和j之间运输货物存在费用cij。为求解旅行费用总和最小的运输路径，设计如下算法：首先选择离中央仓库最近的运输目的地1，然后选择离运输目的地1最近的运输目的地2,……，每次在未访问过的运输目的地中选择离当前运输目的地最近的运输目的地，最后回到中央仓库。

则该算法采用了（ ）算法设计策略，其时间复杂度为（ ）。

---
* 分治（Divide and Conquer）：将问题分解为若干子问题，递归解决子问题后合并结果。这里没有明显的分解和合并过程。

* 动态规划（Dynamic Programming）：将问题分解为重叠子问题，保存子问题的解以避免重复计算。这里没有保存子问题的解或利用重叠子问题的特性。

* #贪心（Greedy）：在每一步选择当前看起来最优的局部解，希望最终得到全局最优解。这里的“每次选择最近的未访问目的地”正是贪心策略的体现。#

* 回溯（Backtracking）：通过尝试所有可能的解，并在发现当前路径不可能得到最优解时回溯。这里没有回溯的过程。

---
时间复杂度分析
贪心的最近邻算法的时间复杂度可以如下分析：

从中央仓库出发，选择最近的未访问目的地：需要比较n个目的地的距离，O(n)时间。

从第一个目的地选择下一个最近的未访问目的地：需要比较n-1个目的地的距离，O(n)时间。

...

从第n-1个目的地选择最后一个未访问目的地：O(1)时间。

最后返回中央仓库：O(1)时间。

总的时间复杂度是：O(n) + O(n-1) + ... + O(1) = O(n^2)。

***

总结时间复杂度	含义	例子

* O(1)	一次搞定	数组取元素 arr[0]
* O(log n)	每次砍掉一半数据	二分查找、平衡二叉树的查找
* O(n)	遍历所有数据	找最大值、线性查找
* O(n log n)	分治 + 每层处理 n 次	归并排序、快速排序
* O(n²)	双重循环	冒泡排序、最近邻贪心 TSP
</t>
<t tx="swot.20250511192258.1"></t>
<t tx="swot.20250511223847.1">若元素以a,b,c,d,e的顺序进入一个初始为空的栈中，每个元素进栈、出栈各1次，要求出栈的第一个元素为d，则合法的出栈序列共有 （4） 种。

    A 4
    B 5
    C 6
    D 24

---
本题考查数据结构基础知识。

栈的修改规则是后进先出。对于题目给出的元素序列，若要求 d 先出栈，则此时 a、b、c 尚在栈中，因此这四个元素构成的出栈序列只能是 dcba。

若 e 在 c 出栈之前进栈，因此可以得到出栈系列 decba。

若 e 在 b 出栈之前进栈，因此可以得到出栈序列 dceba。

若 e 在 a 出栈之前入栈，因此可以得到出栈序列 dcbea。

若 e 在 a 出栈之后入栈，因此可以得到出栈序列 dcbae。
</t>
<t tx="swot.20250511230628.1">现有两个用例 UC1 和 UC2，其中 UC2 是一个完整的用例，可被实例化，而 UC1 需要 UC2 中的事件流才可被实例化，且 UC1 指定了使用 UC2 的精确位置，则 UC1 和 UC2 间的关系是"（A）" 。

    A include
    B extend
    C generalize
    D call

---

分析：根据题干表述 U1 需要 U2 才能完整执行，两者属于包含关系。

* UC2 是完整用例，可独立实例化（即 UC2 能单独执行）。
* UC1 需要 UC2 的事件流才能实例化（即 UC1 依赖 UC2）。
* UC1 指定了使用 UC2 的精确位置（即 UC1 主动调用 UC2）。

UML 用例图的标准关系只有：

* include（包含）
* extend（扩展）
* generalization（泛化/继承）
* association（关联，通常用于参与者和用例之间）

没有 call 这个标准关系，所以选项 D 是干扰项。

</t>
<t tx="swot.20250511231707.1">（C）不属于按寻址方式划分的一类存储器。

    A 随机存储器
    B 顺序存储器
    C 相联存储器
    D 直接存储器

---

正确答案是：**C 相联存储器**

题目问的是“**不属于按寻址方式划分的一类存储器**”，而存储器的寻址方式通常分为以下几类：

1. **随机存储器（A）**：通过地址直接访问任意存储单元，如RAM。
2. **顺序存储器（B）**：必须按顺序访问存储单元，如磁带。
3. **直接存储器（D）**：介于随机和顺序之间，通过部分地址直接定位到某个区域，如磁盘。

**相联存储器（C）**是通过**内容**而非地址访问的存储器（如CAM，Content-Addressable Memory），因此它不属于按寻址方式划分的类别，而是按访问方式划分的。

关键点：

- 寻址方式关注的是**如何定位存储单元**（地址、顺序、直接等）。
- 相联存储器是通过**内容匹配**访问，与寻址方式无关。

其他选项（A、B、D）均属于按寻址方式划分的存储器类型。
</t>
<t tx="swot.20250511232507.1">确定系统边界和关系规范化分别在数据库设计的（A）阶段进行。

    A 需求分析和逻辑设计
    B 需求分析和概念设计
    C 需求分析和物理设计
    D 逻辑设计和概念设计

---

在数据库设计中，确定系统边界和关系规范化分别对应不同的阶段：

1. **确定系统边界**：这是在**需求分析**阶段进行的，目的是明确系统的范围和功能需求，确定哪些数据需要被纳入数据库系统。

2. **关系规范化**：这是在**逻辑设计**阶段进行的，目的是通过范式（如1NF、2NF、3NF等）优化关系模式，减少数据冗余和异常。

因此，正确答案是：**A. 需求分析和逻辑设计**

</t>
<t tx="swot.20250511233342.1"></t>
<t tx="swot.20250512073906.1">某企业的生产流水线上有2名工人 P1 和 P2，1名检验员 P3。

1. P1 将初步加工的半成品放入半成品箱 B1；
2. P2 从半成品箱 B1 取出继续加工，加工好的产品放入成品箱 B2；
3. P3 从成品箱  B2 取出产品校验。

假设 B1 可存放 n 件半成品，B2 可存放 m 件产品，并设置 6 个信号量 S1、S2、S3、S4、S5 和 S6，且 S3 和 S6 的初值都为 0。

采用 PV 操作实现 P1、P2 和 P3 的同步模型如下图所示，S2、S4 的初值分别为（ ）。

[graphviz, target="img/graphviz-2025-05-12-075618", format=svg]
....
digraph ProcessFlow {
    rankdir=TB;
    node [shape=box, style=rounded, fontname="Microsoft YaHei"];

    subgraph cluster_P1 {
        label="P1";
        style=dashed;

        P1_start [label="初步加工"];
        P1_PS1_PS2 [label="P(S1) / P(S2)"];
        P1_B1 [label="半成品 → B1"];
        P1_V1 [label="V(S1) / V(S3)"];

        P1_start -&gt; P1_PS1_PS2 -&gt; P1_B1 -&gt; P1_V1 -&gt; P1_start;
    }

    subgraph cluster_P2 {
        label="P2";
        style=dashed;

        P2_PS1_PS3 [label="P(S1) / P(S3)"];
        P2_getB1 [label="从 B1 取半成品"];
        P2_VS1_VS2 [label="V(S1) / V(S2)"];
        P2_continue [label="继续加工"];
        P2_PS4_PS5 [label="P(S4) / P(S5)"];
        P2_toB2 [label="产品 → B2"];
        P2_V5 [label="V(S5) / V(S6)"];

        P2_PS1_PS3 -&gt; P2_getB1 -&gt; P2_VS1_VS2 -&gt; P2_continue 
                   -&gt; P2_PS4_PS5 -&gt; P2_toB2 -&gt; P2_V5 -&gt; P2_PS1_PS3;
    }

    subgraph cluster_P3 {
        label="P3";
        style=dashed;

        P3_PS5_PS6 [label="P(S5) / P(S6)"];
        P3_getB2 [label="从 B2 取产品"];
        P3_V5 [label="V(S4) / V(S5)"];
        P3_check [label="检验产品"];

        P3_PS5_PS6 -&gt; P3_getB2 -&gt; P3_V5 -&gt; P3_check -&gt; P3_PS5_PS6;
    }
}
....

    A n、0
    B m、0
    C m、n
    D n、m

---

分析：

在本题中涉及到的信号量较多，所以先要分析应用场景中哪些地方可能涉及到互斥和同步，这样才能把问题分析清楚。从题目的描述可以了解到整个流程由3名不同的工人协作完成，先进行P1的处理，然后是P2，最后P3，这样要达到协作关系，要使用同步信号量。同时由于P1处理结果会存到B1中，P2再从B1取内容，在此B1不能同时既进入存操作，也进行取操作，这就涉及到互斥。结合配图可以看出：S1信号量是互斥信号量，它确保B1的使用是互斥使用；S5信号量针对B2起到同样的作用。


当半成品放入 B1 时，S2 就会减一，且放入后不会得到释放，由此推断 S2 为 B1 箱子容量的信号量，同理可得出 S4 为箱子 B2 的容量的信号量。
</t>
<t tx="swot.20250512102233.1">- **用途**：用于分析**死锁**。

- **核心概念**：

  * 节点包括**进程（P）**和**资源（R）**。

  * 边表示**资源请求**或**资源分配**。

- **目标**：判断系统是否可能出现**死锁**。

- **关键点**：循环等待是死锁的重要条件之一，图中若存在**有向环**，可能表示死锁（特别是在每种资源只有一个实例时）。


.与PV 操作（也称信号量机制）区别
****
- **用途**：用于实现进程的**互斥与同步**。

- **核心概念**：

  * P 操作（也叫 wait 或 down）：请求资源或进入临界区。
  * V 操作（也叫 signal 或 up）：释放资源或退出临界区。
  * 常用于解决**临界区问题**、**生产者-消费者问题**、**读者-写者问题**等。

- **目标**：确保进程之间不会出现**竞态条件（race condition）**，并实现正确的协作。
****
</t>
<t tx="swot.20250512102652.1">进程资源图如图(a)和(b)所示，其中：图(a)中（B）; 图(b)中（C）。

.图 a
[graphviz, target="img/graphviz-2025-05-12-103138", format=svg]
....
digraph ResourceAllocation_a {
    rankdir=TB;
    node [shape=circle];

    P1 [label="P1"];
    P2 [label="P2"];

    R1 [shape=box, label="R1(有2个资源)"];
    R2 [shape=box, label="R2(有3个资源)"];

    R1 -&gt; P1 [label = "1个资源已分配"];    // 资源分配
    R2 -&gt; P1 [label = "1个资源已分配"];    // 资源分配
    P1 -&gt; R2 [label = "请求1个资源\n请求不到了" color="red"];  // 资源请求

    R1 -&gt; P2 [label = "1个资源已分配"];    // 资源分配
    R2 -&gt; P2 [label = "2个资源已分配"];    // 资源分配
    P2 -&gt; R1 [label = "请求1个资源\n请求不到了" color="red"];  // 资源请求
}
....

[TIP]
====
* P → R：表示 “进程请求资源”
* R → P：表示 “资源分配给进程”
====

    A P1是非阻塞节点，P2是阻塞节点，所以该图不可以化简，是死锁的
    B P1、P2都是阻塞节点，所以该图不可以化简，是死锁的
    C P1、P2都是非阻塞节点，所以该图可以化简，是非死锁的
    D P1是阻塞节点，P2是非阻塞节点，所以该图不可以化简、是死锁的

---
分析图 a：

* 因为 R1 资源只有 2 个，P2 申请该资源得不到满足，故进程 P2 是阻塞节点；
* 同样 R2 资源只有 3 个，P1 申请该资源得不到满足，故进程 P1 也是阻塞节点。
* 可见进程资源图（a）是死锁的，该图不可以化简。正确答案：B

---

.图 b
[graphviz, target="img/graphviz-2025-05-12-112329", format=svg]
....
digraph ResourceAllocation_b {
    rankdir=TB;
    node [shape=circle];

    P1 [label="P1"];
    P2 [label="P2"];
    P3 [label="P3"];

    R1 [shape=box, label="R1(有2个资源)"];
    R2 [shape=box, label="R2(有3个资源)"];

    P1 -&gt; R2 [label = "请求1个资源"];      // 资源请求
    R1 -&gt; P1 [label = "1个资源已分配"];    // 资源分配

    P2 -&gt; R1 [label = "请求1个资源"];      // 资源请求
    R2 -&gt; P2 [label = "1个资源已分配" color="red"];    // 资源分配

    P3 -&gt; R2 [label = "请求1个资源"];
    R2 -&gt; P3 [label = "1个资源已分配"];
    R1 -&gt; P3 [label = "1个资源已分配"];
}
....

    A P1、P2、P3都是非阻塞节点，该图可以化简，是非死锁的
    B P1、P2、P3都是阻塞节点，该图不可以化简，是死锁的
    C P2是阻塞节点，P1、P3是非阻塞节点，该图可以化简，是非死锁的
    D P1、P2是非阻塞节点，P3是阻塞节点，该图不可以化简，是死锁的。

---

分析图 b：

因为 R2 资源有3个，已分配2个，P3申请1个R2资源可以得到满足（P1也可以），故进程P3可以运行完毕释放其占有的资源。
这样可以使得P1、P3都变为非阻塞节点，得到所需资源运行完毕，因此，进程资源图（b）是可化简的。

正确答案：C

[TIP]
====
关键点：

* 阻塞节点是指一个进程申请的资源当前不可用，所以它必须等待。
* 非阻塞节点是指一个进程可以立即获得它申请的所有资源，能够运行完成并释放资源。
* 如果一个图可以逐步化简（即所有进程都能按某种顺序完成），那么就没有死锁。
====
</t>
<t tx="swot.20250512170249.1">假设一棵二叉树的结点个数为 50，则它的最小高度是（ ）。

    A 4
    B 5
    C 6
    D 7

---

按照满足条件时，当 50 个结点构成一棵完全二叉树时高度最小，stem:[h = \lfloor \log_2(n) \rfloor 向下取整为5再 + 1 = 6]
</t>
<t tx="swot.20250512205329.1">（A）设计模式将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

    A 命令（Command）
    B 责任链（Chain of Responsibility）
    C 观察者（Observer）
    D 策略（Strategy）

---

本题考查设计模式的基本概念。每种设计模式都有特定的意图，描述一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心，使该方案能够重用而不必做重复劳动。

* 命令(Command)将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

* 责任链(Chain of Responsibility)使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

* 观察者(Observer)模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

* 策略(Strategy)定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化。
</t>
<t tx="swot.20250512211150.1"></t>
<t tx="swot.20250512220136.1">@language asciidoc
某计算机系统页面大小为 4K，进程的页面变换表如下所示。若进程的逻辑地址为 3C28H。该地址经过变换后，其物理地址应为（D）。

    页号      物理块号
    0           1
    1           3
    2           4
    3           6

    A 2048H
    B 4096H
    C 4C28H
    D 6C28H

---

首先，我们需要明确几个关键概念：

* 页面大小（Page Size）：这里是 4K，即 4096 字节（因为 1K = 1024 字节）。
* 逻辑地址（Logical Address）：由 CPU 生成的地址，分为页号和页内偏移量。
* 页表（Page Table）：将逻辑页号映射到物理块号。
* 物理地址（Physical Address）：由物理块号和页内偏移量组合而成。

我们来一步步分析这道题。

---

已知信息：

* **页面大小为 4K**，即 **每页大小 = 4KB = 2¹² = 4096 字节**。
* 所以逻辑地址的格式为：

  逻辑地址 = 页号 + 页内偏移量
          = 高 4 位（页号） + 低 12 位（页内偏移）

* 页表如下：

    页号      物理块号
    0           1
    1           3
    2           4
    3           6

* 给定逻辑地址为：`3C28H`

---

第一步：将逻辑地址转换为二进制

```
转为二进制：
3C28H = 0011 1100 0010 1000（二进制）

前 4 位：0011 → 页号 = 3
后 12 位：1100 0010 1000 → 页内偏移 = 0xC28
```

---

第二步：查表得知页号为 3，对应物理块号是 6

每个物理块的大小也是 4K（4096 字节），所以：

```
物理地址 = 物理块号 × 页大小 + 页内偏移
        = 6 × 4096 + 0xC28
```

1. 利用位运算的特性：

* 4096 = 2¹²，所以 6 × 4096 = 6 &lt;&lt; 12（左移 12 位）。
* 也就是：把 6 变成一个以 12 个零结尾的二进制数。

    6 × 4096 = 6 &lt;&lt; 12 = 0x6000

2. 把偏移量直接加进去：

* 偏移量是 0xC28，直接加到 0x6000：

    0x6000 + 0x0C28 = 0x6C28

✅ 答案：**D. 6C28H**
</t>
<t tx="swot.20250512220451.1">某系统采用请求页式存储管理方案，假设某进程有 6 个页面，系统给该进程分配了 4 个存储块，其页面变换表如下表所示，表中的状态位等于 1/0 分别表示页面在内存/不在内存。

[caption=]
[cols="5*",options="header"]
|===
| 页号 | 页帧号 | 状态位 | 访问位 | 修改位
| 0  | 5   | 1   | 1   | 1
| 1  | —   | 0   | 0   | 0
| 2  | —   | 0   | 0   | 0
| 3  | 2   | 1   | 1   | 0
| 4  | 8   | 1   | 1   | 1
| 5  | 12  | 1   | 0   | 0
|===

当该进程访问的页面 2 不在内存时，应该淘汰表中页号为（D）的页面。

    A 0
    B 3
    C 4
    D 5

---

这个题考察的是操作系统中的请求分页系统页面置换算法和地址变换。我们逐步来分析：

题意解析：

1. 系统采用请求页式存储管理：说明不是所有页都在内存里，需要访问时再调入。
2. 进程有6个页面（页号0~5），系统给它分配了4个页框（也就是最多4页能在内存中）。
3. 给出了页表，每行分别是：
* 页号（Page Number）
* 页帧号（Frame Number）
* 状态位（1表示在内存，0表示不在内存）
* 访问位（是否访问过）
* 修改位（是否修改过

找出页面2不在内存，要换入内存，需要淘汰哪个页？

页面 2 不在内存（状态位为0），所以要换入。内存页框已满（页号0、3、4、5状态位都为1），需要淘汰一个页。

选择淘汰页的算法（常用是 NRU 或 Clock）

从表中可看到访问位与修改位，用NRU算法（Not Recently Used）。

[caption=]
.NRU 通常按如下优先级淘汰（越上优先级越高，优先被淘汰）：
[cols="4*",options="header"]
|===
| 类别 | 访问位 | 修改位 | 优先级
| 0  | 0   | 0   | 最高（立即淘汰）
| 1  | 0   | 1   | 次高
| 2  | 1   | 0   | 次低
| 3  | 1   | 1   | 最低
|===

对比内存中页面：

* 页号0：访问=1，修改=1 → 类别3
* 页号3：访问=1，修改=0 → 类别2
* 页号4：访问=1，修改=1 → 类别3
* 页号5：访问=0，修改=0 → 类别0 ✅

页号 5 满足类别 0（未访问未修改）→ 最佳淘汰对象
</t>
<t tx="swot.20250512220520.1">接上题，假定页面大小为 4K，逻辑地址为十六进制 3C18H，该地址经过变换后的页帧号为（A）。

    A 2
    B 5
    C 8
    D 12

---

逻辑地址 3C18H → 页号、页内偏移，找出页帧号

* 采用页式管理，每页大小为 4K = 2¹² 字节（即页偏移是12位）
* 所以逻辑地址的前几位是页号，低 12 位是页内偏移

将 3C18H 转成二进制：

3C18H = 0011 1100 0001 1000（16位）

* 页号（高4位）：0011 = 3
* 页内偏移（低12位）：1100 0001 1000

→ 所以是页号 3

查页表中页号 3 的页帧号是 2 ✅

</t>
<t tx="swot.20250512232041.1">已知字符集 { a, b, c, d, e, f }，若各字符出现的次数（理解成出现的概率）分别为 6, 3, 8, 2, 10, 4，则对应字符集中各字符的哈夫曼编码可能为（A）。

    A 00，1011, 01, 1010, 11, 100
    B 11, 100, 110, 000 , 0010, 01
    C 10, 1011, 11, 0011, 00, 010
    D 0011, 10, 11, 0010, 01, 000

---

1. **初始节点**：按权值升序排列为 d(2), b(3), f(4), a(6), c(8), e(10)。

2. **合并最小节点**：
   - 合并 d(2) 和 b(3) 成 5，队列变为 [f(4), 5, a(6), c(8), e(10)]。
   - 合并 f(4) 和 5 成 9，队列变为 [a(6), 9, c(8), e(10)]。
   - 合并 a(6) 和 c(8) 成 14，队列变为 [9, e(10), 14]。
   - 合并 9 和 e(10) 成 19，队列变为 [14, 19]。
   - 合并 14 和 19 成根节点 33。
+
.画出的树，可用边来推算出编码
[graphviz, target="img/graphviz-2025-05-23-231928", format=svg]
....
digraph G {
    rankdir=LR

    dbfe [label="19"]
    ac [label="14"]

    f [label="f:4"]

    d [label="d:2"]
    b [label="b:3"]
    db [label="5"]
    dbf [label="9"]
    e [label="e:10"]

    a [label="a:6"]
    c [label="c:8"]

    root [label="33"]

    d -&gt; db [label="0"]
    b -&gt; db [label="1"]

    f -&gt; dbf [label="0"]
    db -&gt; dbf [label="1"]

    a -&gt; ac [label="0"]
    c -&gt; ac [label="1"]

    dbf -&gt; dbfe [label="0"]
    e -&gt; dbfe [label="1"]

    ac -&gt; root [label="0"]
    dbfe -&gt; root [label="1"]
}
....

3. **编码规则**：每个节点的左分支为 0，右分支为 1。
   - **a** 的路径为：根→左→左，  编码 **00**。
   - **c** 的路径为：根→左→右，  编码 **01**。
   - **e** 的路径为：根→右→右，  编码 **11**。
   - **f** 的路径为：根→右→左→左，编码 **100**。
   - **d** 的路径为：根→右→左→右→左，编码 **1010**。
   - **b** 的路径为：根→右→左→右→右，编码 **1011**。

**选项 A 的编码与上述结果完全一致**，且满足哈夫曼编码的最短加权路径性质（高频字符编码更短）。 +
其他选项（如 B、C、D）中，存在高频字符编码过长或前缀冲突的问题，因此排除。

**答案：A**

哈夫曼编码原则回顾：

* 频率越高，编码越短；频率越低，编码越长。
* 没有一个编码是另一个编码的前缀（前缀码）。
* 哈夫曼树是通过合并频率最小的两个节点，逐步构建出来的。

分析选项 A：

* 频率最高的是 e(10) 和 c(8)，它们的编码分别是 11 和 01（都是2位）✅
* a(6) 是 00（也是2位）✅
* f(4) 是 100（3位）✅
* b(3) 是 1011（4位），d(2) 是 1010（4位）✅
* 没有任何编码是另一个编码的前缀 ✅

这完全符合哈夫曼编码的基本原则。

其他选项简要分析：

* B：e 的编码是 0010（4位），但它频率最高，应是最短的 → 不合理 ❌
* C：b(3) 是 1011，d(2) 是 0011，但 a(6) 是 10，b 的编码比 a 还长，合理 ✅，但由于题目只选一项，A 更标准，A 是由树推算出来的。
* D：a(6) 的编码是 0011（4位），比 b(3) 的 10 还长 → 不合理 ❌
</t>
<t tx="swot.20250513074008.1">:stem: latexmath
@language asciidoc
A类网络是很大的网络，每个A类网络中可以有（stem:[2^{24}]）个网络地址。
实际使用中必须把A类网络划分为子网，如果指定的子网掩码为255.255.192.0，则该网络被划分为（1024）个子网。

解答:

一、A类网络能有多少个网络地址？

1. IP地址分类背景
* A 类地址范围是：`0.0.0.0` 到 `126.255.255.255`
* 默认子网掩码是：`255.0.0.0`，即网络部分是 **前8位**，剩下的 **24位用于主机地址**。
* 所以每个A类网络的格式是：`网络号.主机号.主机号.主机号`

2. 一个A类网络中的地址数：
* 有24位可用于主机号 → 共有 stem:[2^{24}] 个地址
* 其中通常有两个地址是保留的（网络地址和广播地址），但这道题问的是“**可以有多少个网络地址**”，实际指的是**地址空间的数量**。

二、如果子网掩码为255.255.192.0，该A类网络被划分为多少个子网？

1. 255.255.192.0 转换为二进制：
* 即：`11111111.11111111.11000000.00000000`
* 这是 **前18位是网络位**（8 位原始 + 新增 10 位子网位）

2. 子网位数：
* A类默认是 8 位网络号
* 现在掩码变成了 18 位网络位 → 多出了 **10位用于划分子网**

3. 子网数计算：
* 有10位子网位 → 子网数 = stem:[2^{10} = 1024]

总结：

* A类网络地址数: 24位主机位 → stem:[2^{24}] 个主机地址
* 子网掩码变化: 从8位网络位扩展到18位 → 有10位可用作子网划分
* 可划分子网数: stem:[2^{10} = 1024] 个子网
</t>
<t tx="swot.20250513093844.1">:stem: latexmath
若一棵二叉树的高度（即层数）为h，则该二叉树（A）。

* A 最多有 stem:[2^h - 1] 个结点
* B 最少有 stem:[2^h - 1] 个结点
* C stem:[2^h] 个结点
* D 有 stem:[2^h -1] 个结点

[discrete]
==== 解析

**A. 最多有 stem:[2^h - 1] 个结点** ✅

这是正确的。

- 满二叉树（Full Binary Tree）：每一层的结点数都是最大，第 i 层有 stem:[2^{i-1}] 个结点。
- 总结点数为：等比数列求和公式
  ** stem:[1 + 2 + 4 + ... + 2^{h-1} = 2^h-1]

所以当二叉树是满的（即每一层都满）时，结点最多有 stem:[2^h - 1] 个。

**B. 最少有 2^h^ - 1 个结点** ❌
错误。最少的情况是每层只有一个结点（即链式结构），那么最少有 h 个结点，而不是 2^h^ - 1。

**C. 有 2^h^ 个结点** ❌
错误。这是满二叉树下一层的节点数，仅在深度为 h+1 时才可能达到。

**D. 有 2^h^ - 1 个结点** ❌
错误。这是最多的情况，而非所有情况。

正确答案 *A*

.最简单作法
[IMPORTANT]
====
1. 画个满二叉树图
+
[mermaid, target=img/mermaid-2025-05-23-215839, format=svg]
....
flowchart TD

    A --- B
    A --- C
    B --- D
    B --- E
    C --- F
    C --- G
....

2. 代入选项公式即能得到正确答案
   * 上面满二叉树最多为  7 个节点，有 3 层，所以选项 A 正确。
====
</t>
<t tx="swot.20250513100958.1">分配给某校园网的地址块是202.105.192.0/19，该校园网包含（D）个C类网络。

    A 8
    B 16
    C 30
    D 32

---

分配给校园网的地址块是202.105.192.0/19。C类网络的默认子网掩码是/24。
两者的前缀差为24-19=5位，因此该地址块可划分的C类网络数量为\(2^5 = 32\)。

**验证过程：**

1. **CIDR前缀差计算**：/19与/24相差5位，每个C类网络需要5位扩展，故子网数量为\(2^5=32\)。
2. **地址范围分析**：第三个字节的前3位固定（对应192的二进制`11000000`），后5位允许变化（范围192到223），共32个值，对应32个/24网络。

**答案：D 32**</t>
<t tx="swot.20250513121934.1">在—棵度为 3 的树中，若有 2 个度为 3 的结点，有 1 个度为 2 的结点，则有（C）个度为 0 的结点。

    A 4
    B 5
    C 6
    D 7

---

解释：##度为 3 的树（也称为**三叉树**）是指**树中每个结点的最大子结点数为3**，即每个结点最多可以有 3 个子结点。##

**度为3的树的特点：**

1. **结点的度**：每个结点的子结点数可以是0（叶子结点）、1、2 或 3。
2. **树的度**：整棵树的度是所有结点##度的最大值##，因此如果树中至少有一个结点有 3 个子结点，则该树的度为 3。
3. **结构**：不同于**二叉树（每个结点最多2个子结点）**，三叉树可以有更灵活的分支结构。

.**示例：**

        A
      / | \
     B  C  D
    / \    |
   E   F   G

- **A** 的度为3（子结点 B、C、D）。
- **B** 的度为2（子结点 E、F）。
- **D** 的度为1（子结点 G）。
- **C、E、F、G** 的度为 0（叶子结点）。

总结：**度为 3 的树是一种每个结点最多有 3 个子结点的树结构**，适用于需要更高分支因子的场景。

基本概念清楚了，要想计算，还是挺麻烦的。下面画一个图可以快速求出本题。

         A
       /   \
      B     C
     /|\   /|\
    D E F G H I

这个树的度为 3，且有两个度为 3 的节点（B和C），A节点的度为 2，度为 0 的节点有 6 个。所以答案是 C
</t>
<t tx="swot.20250513124156.1">若某计算机字长为32位，内存容量为2GB，按字编址，则可寻址范围为（C）。

    A 1024M
    B 1GB
    C 512M
    D 2GB

[discrete]
==== 理解基本概念

首先，我们需要明确几个关键概念：

1. *字长（Word Size）*：指计算机一次能处理的二进制位数。这里字长为32位，即4字节（因为1字节=8位，32位=4字节）。

2. *内存容量*：指计算机内存的总大小。这里是2GB（GigaBytes）。需要明确的是，通常“B”代表字节（Byte），所以2GB = 2 × 1024 × 1024 × 1024 字节。

3. *编址方式*：
   - *按字节编址*：每个地址对应一个字节。
   - *按字编址*：每个地址对应一个字（这里一个字是32位，即4字节）。

题目中明确指出是“按字编址”，因此每个地址对应的是一个字（4字节）。

[discrete]
==== 计算可寻址范围

可寻址范围指的是可以寻址的地址数量。我们需要计算在按字编址的情况下，有多少个唯一的地址可以访问。

1. *内存总容量*：2GB = 2 × 2^30 字节 = 2^31 字节。

2. *按字编址*：每个字 = 4字节 = 2^2 字节。

   因此，可寻址的字数量 = 总字节数 / 每个字的字节数 = 2^31 / 2^2 = 2^(31-2) = 2^29。

3. 2^29 是多少？
   - 2^10 = 1K
   - 2^20 = 1M
   - 2^30 = 1G
   - 所以 2^29 = 2^(30-1) = 1G / 2 = 512M。

因此，可寻址范围是512M个地址。

[discrete]
==== 验证单位

题目问的是“可寻址范围”，通常指的是地址的数量。地址的数量是无单位的（即多少个地址），但选项中给出的单位是“M”、“GB”等。这里需要明确：

- 如果“可寻址范围”指的是地址的数量，那么512M表示512 × 2^20个地址。
- 每个地址对应一个字（4字节），因此总内存 = 地址数量 × 字大小 = 512M × 4字节 = 2048MB = 2GB，这与题目给出的内存容量一致。

因此，选项C的“512M”是正确的。

[discrete]
==== 排除其他选项

让我们看看其他选项为什么不对：

- *A. 1024M*：
  - 1024M = 1G 地址。
  - 按字编址，总内存 = 1G × 4字节 = 4GB，与题目2GB不符。

- *B. 1GB*：
  - 类似于A，1GB地址 = 1G地址。
  - 总内存 = 1G × 4字节 = 4GB，不符。

- *D. 2GB*：
  - 2GB地址。
  - 总内存 = 2G × 4字节 = 8GB，不符。

只有C（512M）满足：

512M地址 × 4字节/地址 = 2GB 内存。

[discrete]
==== 可能的混淆点

有时候，人们可能会混淆“按字编址”和“按字节编址”：

- 如果是*按字节编址*：
  - 可寻址范围 = 2GB / 1字节 = 2G 地址。
  - 但题目是按字编址，所以需要除以字的大小（4字节）。

因此，不能直接认为内存容量是2GB，可寻址范围就是2G。

[discrete]
==== 单位的选择

为什么选项用“M”而不是“MB”？

- 这里的“M”指的是“百万”或“2^20”个地址，不是“MB”（兆字节）。
- 因为地址数量是无单位的，所以用“M”表示“百万”个地址是合理的。
- 如果写成“MB”可能会误解为内存大小。

[discrete]
==== 总结

- 内存总容量：2GB = 2^31 字节。
- 按字编址，字长：32位 = 4字节。
- 可寻址的字数量 = 2^31 / 4 = 2^29 = 512M。
- 因此，正确答案是 *C 512M*。

[discrete]
==== 最终答案

*C 512M*
</t>
<t tx="swot.20250513144448.1">设某循环队列 Q 的定义中有 front 和 rear 两个域变量，其中，front 指示队头元素的位置，rear 指示队尾元素之后的位置，如下图所示。若该队列的容量为 M，则其长度为（D）。

image::img/queue_length.png[]

    A (Q.rear-Q.front+1)
    B (Q.rear-Q.front+M)
    C (Q.rear-Q.front+1)%M
    D (Q.rear-Q.front+M)%M

本题考查数据结构基础知识。

根据题目中所给的示意图，Q.front 为队头元素的指针，Q.rear 表示队尾元素之后的一个空位置，故队列长度为Q.rear-Q.front

由于队列中存储位置编号是在 0～M－1 之间循环的，Q.rear-Q.front 的结果有可能是负数，故在 Q.rear-Q.front基础上加上 M 可恢复为正数，而此正数有可能超出 0～M－1 的范围，故用整除，M 取余运算恢复一下，因此长度计算的式子为 (Q.rear-Q.front+M)%M。

</t>
<t tx="swot.20250513155441.1">采用McCabe度量法计算下图的环路复杂度为（C）。

    A 2
    B 3
    C 4
    D 5

[plantuml, target=img/diagram-2025-05-13-155805, format=svg]
....
@startuml
start

repeat

  if (i &gt; 0) then (Y)
    :语句1;
  else (N)
  endif

  :i = 0;

  if (n == 0) then (Y)
    :语句2;
  else (N)
    :语句3;
  endif

repeat while (loop)

@enduml
....

**数判定节点（推荐！）**

公式：V(G) = 判定节点数 + 1

步骤：

1. 在代码中数出所有的 if、else if、while、for、case 等分支语句。

2. 每个分支语句算 1个判定节点。
   * 判定节点数 = 3（while、i&gt;0、n==0）

3. 最后 +1 就是环路复杂度
   * V(G) = 3 + 1 = 4

IMPORTANT: 该题有个 while 循环，容易被忽略！
</t>
<t tx="swot.20250513184634.1">考虑下述背包问题的实例。
有 5 件物品，背包容量为 100，每件物品的价值和重量如下表所示，并已经按照物品的单位重量价值从大到小排好序，##根据物品单位重量价值大优先的策略装入背包中##，则采用了（B）设计策略。

考虑 0|1 背包问题（每件物品或者全部放入或者全部不装入背包）和部分背包问题（物品可以部分装入背包），求解该实例，得到的最大价值分别为（C）。

[cols="^,^,^,^", options="header"]
|===
|物品编号 |价值 |重量 |单位重量价值
|1 |50  |5  |10
|2 |200 |25 |8
|3 |180 |30 |6
|4 |225 |45 |5
|5 |200 |50 |4
|===

第一问选项:

    A 分治
    B 贪心
    C 动态规划
    D 回溯

第二问选项:

    A 605和630
    B 605和605
    C 430和630
    D 630和430

---

第二问答案：C. 430 和 630

0|1 背包（贪心选物）：只能整件选，按顺序选入 1、2、3 号物品，重量共 60，价值为 430

部分背包（贪心法）：可以部分选物，总价值为 630

注意：0|1 背包这里并非求最优解（605），而是要求在##贪心策略##下的结果。
</t>
<t tx="swot.20250513200749.1">对 n 个基本有序的整数进行排序，若采用插入排序算法，则时间和空间复杂度分别为（D）

    A O(n2)和O(n)
    B O(n)和O(n)
    C O(n2)和O(1)
    D O(n)和O(1)

---

算法简介：插入排序是一种简单直观的排序算法，其基本思想是从第二个元素开始，将每个元素插入到它前面已经排好序的子数组中，使整个数组逐步变成有序。

若数据基本有序，对插入排序算法而言，则可以在近似线性时间内完成排序，即O(n);

插入排序算法在排序时仅需要一个额外的存储空间，即空间复杂度均为常数时间复杂度 O(1)。
</t>
<t tx="swot.20250513220926.1">@doc
[source,python,]
----
@c
@language python
def insertion_sort(arr):
    print("初始数组:", arr)
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        print(f"\n第 {i} 步：准备插入元素 {key}（来自位置 {i}）")

        # 将大于 key 的元素向后移
        while j &gt;= 0 and arr[j] &gt; key:
            print(f"\t移动: 元素 {arr[j]} 从位置 {j} 移动到位置 {j + 1}")
            arr[j + 1] = arr[j]
            j -= 1

        arr[j + 1] = key
        print(f"\t插入: 元素 {key} 到位置 {j + 1}")
        print("\t当前数组状态:", arr)

    print("\n最终排序结果:", arr)
    return arr

# 测试代码
arr = [5, 2, 4, 6, 1, 3]
insertion_sort(arr.copy())

@doc
----

代码很巧妙，需要理解它的时间复杂度和空间复杂度。

.输出结果
....
初始数组: [5, 2, 4, 6, 1, 3]

第 1 步：准备插入元素 2（来自位置 1）
	移动: 元素 5 从位置 0 移动到位置 1
	插入: 元素 2 到位置 0
	当前数组状态: [2, 5, 4, 6, 1, 3]

第 2 步：准备插入元素 4（来自位置 2）
	移动: 元素 5 从位置 1 移动到位置 2
	插入: 元素 4 到位置 1
	当前数组状态: [2, 4, 5, 6, 1, 3]

第 3 步：准备插入元素 6（来自位置 3）
	插入: 元素 6 到位置 3
	当前数组状态: [2, 4, 5, 6, 1, 3]

第 4 步：准备插入元素 1（来自位置 4）
	移动: 元素 6 从位置 3 移动到位置 4
	移动: 元素 5 从位置 2 移动到位置 3
	移动: 元素 4 从位置 1 移动到位置 2
	移动: 元素 2 从位置 0 移动到位置 1
	插入: 元素 1 到位置 0
	当前数组状态: [1, 2, 4, 5, 6, 3]

第 5 步：准备插入元素 3（来自位置 5）
	移动: 元素 6 从位置 4 移动到位置 5
	移动: 元素 5 从位置 3 移动到位置 4
	移动: 元素 4 从位置 2 移动到位置 3
	插入: 元素 3 到位置 2
	当前数组状态: [1, 2, 3, 4, 5, 6]

最终排序结果: [1, 2, 3, 4, 5, 6]
....
</t>
<t tx="swot.20250514103808.1">[plantuml, target=img/diagram-2025-05-14-103821, format=svg]
....
@startuml
start

:初始数组 arr = [5, 2, 4, 6, 1, 3];
:i = 1;

while (i &lt; len(arr)) is (true)
  :key = arr[i];
  :j = i - 1;
  :Print "准备插入元素 key（来自位置 i）";

  while (j &gt;= 0 and arr[j] &gt; key) is (true)
    :Print "移动: 元素 arr[j] 从位置 j 移动到位置 j+1";
    :arr[j+1] = arr[j];
    :j = j - 1;
  endwhile

  :arr[j+1] = key;
  :Print "插入: 元素 key 到位置 j+1";
  :Print 当前数组状态;
  :i = i + 1;
endwhile

:Print "最终排序结果";
stop
@enduml
....
</t>
<t tx="swot.20250514110224.1">对 n 个基本有序的整数进行排序，若采用快速排序算法，则时间和空间复杂度分别为（A）。

    A O(n^2)和O(n)
    B O(nlogn)和O(n)
    C O(n^2)和O(1)
    D O(nlogn)和O(1)

---

快速排序的核心是 “分治法”（Divide and Conquer）：

1. 选一个“基准”元素（pivot）。
2. 把数组分成两个部分：
    * 左边部分：所有小于 pivot 的元素。
    * 右边部分：所有大于等于 pivot 的元素。
3. 分别对左右两部分递归地进行排序。
4. 把排序好的左边 + pivot + 排序好的右边合并起来。

就是这样一步一步拆分成小问题，最后拼回一个有序的结果。

[discrete]
==== 示例演示

对数组 `[5, 2, 4, 6, 1, 3]` 执行 quicksort，过程如下：

. 第一次：pivot = 5
  * 左边：[2, 4, 1, 3]
  * 右边：[6]

. 对左边 `[2, 4, 1, 3]` 执行 quicksort：
  * pivot = 2
  * 左边：[1]
  * 右边：[4, 3]

. 对 `[4, 3]` 执行 quicksort：
  * pivot = 4
  * 左边：[3]
  * 右边：[]

. 合并过程：
[source]
----
[1] + [2] + [3, 4] = [1, 2, 3, 4]
----

. 最终结果：
[source]
----
[1, 2, 3, 4] + [5] + [6] = [1, 2, 3, 4, 5, 6]
----

[discrete]
==== 为什么叫“快速排序”？

快速排序之所以叫“快速”，是因为它的平均性能非常优秀：

* 平均时间复杂度：`O(n log n)`
* 最坏情况：`O(n^2)`（当 pivot 选得很差时）

它在大多数实际应用中比冒泡、选择、插入等排序算法快很多，因此得名“快速排序”。

[discrete]
==== 总结

快速排序之所以能够排序成功，是因为它在每一步都将数据划分为两部分：
* 小的元素在左边
* 大的元素在右边

通过递归地排序这两部分，最终拼出一个完整有序的结果。
</t>
<t tx="swot.20250514111022.1">@doc
下面是用 Python 实现的 快速排序（Quicksort） 源代码，采用的是经典的递归方式：

[source,python,]
----
@c
@language python
def quicksort(arr):
    if len(arr) &lt;= 1:
        return arr
    pivot = arr[0]  # 选取第一个元素作为基准
    left =  [x for x in arr[1:] if x &lt; pivot]     # 小于 pivot 的元素
    right = [x for x in arr[1:] if x &gt;= pivot]    # 大于等于 pivot 的元素
    return quicksort(left) + [pivot] + quicksort(right)

nums = [5, 2, 4, 6, 1, 3]
sorted_nums = quicksort(nums)
print(sorted_nums)
@doc
----

[discrete]
=== </t>
<t tx="swot.20250514113757.1">[plantuml, target=img/diagram-2025-05-14-113805, format=svg]
....
@startuml
start

:调用 quicksort(arr);

if (arr 长度 &lt;= 1?) then (是)
  :返回 arr;
  stop
else (否)
  :pivot = arr[0];
  :left = [x for x in arr[1:] if x &lt; pivot];
  :right = [x for x in arr[1:] if x &gt;= pivot];

  :对 left 递归执行 quicksort;
  :对 right 递归执行 quicksort;

  :返回 quicksort(left) + [pivot] + quicksort(right);
  stop
endif
@enduml
....

</t>
<t tx="swot.20250514114641.1">某文件系统采用链式存储管理方案，磁盘块的大小为 1024 字节。
文件 Myfile.doc 由 5 个逻辑记录组成，每个逻辑记录的大小与磁盘块的大小相等，并依次存放在 121、75、86、65 和 114 号磁盘块上。
若需要存取文件的第 5120 字节处的信息，应该访问（D）号磁盘块。

    A 75
    B 85
    C 65
    D 114

---

这个题比较简单，从前往后数，1024B * 4 = 4096B，小于 5120B，所以只能是在最后一个磁盘块上了。
所以答案是 D 114
</t>
<t tx="swot.20250514115620.1">某磁盘磁头从一个磁道移至另一个磁道需要 10ms。文件在磁盘上非连续存放，逻辑上相邻数据块的平均移动距离为 10 个磁道，每块的旋转延迟时间及传输时间分别为 100ms 和 2ms，则读取一个 100 块的文件需要（D）ms 时间。

    A 10200
    B 11000
    C 11200
    D 20200

---

本题考查操作系统中设备管理的基本知识。
访问一个数据块的时间应为寻道时间加旋转延迟时间及传输时间。
根据题意，每块的旋转延迟时间及传输时间共需 102ms，磁头从一个磁道移至另一个磁道需要 10ms，但逻辑上相邻数据块的平均距离为10个磁道，即读完一个数据块到下一个数据块寻道时间需要 100ms。
通过上述分析，本题访问一个数据块的时间应为 202ms，而读取一个 100块的文件共需要 20200ms。

如果以后再遇到类似题，可以用这个公式快速估算：

    总读取时间 = 块数 *（寻道时间 + 旋转延迟 + 传输时间）
             = 100 * (10*10+100+2)
             = 20200ms

前提是：数据块非连续存储，所以每次都要重复这三步。
</t>
<t tx="swot.20250514121040.1">:stem: latexmath
假定求浮点数平方根（FPSQR）的操作在某台机器上的一个基准测试程序中占总执行时间的20%，FP运算指令所用时间占总执行时间的50%。

采用两种优化FPSQR的方法，第一种方法是增加专门的FPSQR硬件，可以将FPSQR的操作速度提高为原来的10倍；

第二种方法是提高所有FP（浮点）运算指令的执行速度到原来的1.6倍，从而提高求浮点数平方根操作的速度。

可以通过计算这两种方法对基准测试程序的加速比来比较这两种方法的优劣。以下叙述正确的是（B）。

    A 第一种方法的加速比是1.23，效果较好
    B 第二种方法的加速比是1.23，效果较好
    C 第一种方法的加速比是1.22，效果较好
    D 第二种方法的加速比是1.22，效果较好

---

Amdahl 定律应用分析题

[discrete]
==== 题目描述

假定求浮点数平方根（FPSQR）的操作在某台机器上的一个基准测试程序中占总执行时间的 20%，
而所有 FP（浮点）运算指令所用时间占总执行时间的 50%。

有两种优化 FPSQR 的方法：

1. 第一种方法是增加专门的 FPSQR 硬件，可将 FPSQR 操作速度提高为原来的 10 倍；
2. 第二种方法是提高所有 FP 运算指令的执行速度到原来的 1.6 倍，从而也提高 FPSQR 操作速度。

[discrete]
==== 选项

A. 第一种方法的加速比是 1.23，效果较好 +
B. 第二种方法的加速比是 1.23，效果较好 +
C. 第一种方法的加速比是 1.22，效果较好 +
D. 第二种方法的加速比是 1.22，效果较好

[discrete]
==== 考察知识点

本题考察 *Amdahl 定律* 的应用，用于分析**部分程序优化**对**整体性能**的影响

Amdahl 定律公式： stem:[\text{Speedup} = \frac{1}{(1 - f) + \frac{f}{s}}]

其中：

- stem:[f]：可优化部分占总执行时间的比例
- stem:[s]：该部分的加速倍数（speedup factor）

[discrete]
==== 方法一：优化 FPSQR（占 20%，加速 10 倍）

- 可优化部分：stem:[f = 0.2]
- 非优化部分：stem:[1 - f = 0.8]
- 加速比计算：
+
[source,asciidoc]
----
stem:[
\text{Speedup}_1 = \frac{1}{0.8 + \frac{0.2}{10}} = \frac{1}{0.8 + 0.02} = \frac{1}{0.82} \approx 1.22
]
----

[discrete]
==== 方法二：优化所有 FP 指令（占 50%，加速 1.6 倍）

- 可优化部分：stem:[f = 0.5]
- 非优化部分：stem:[1 - f = 0.5]
- 加速比计算：
+
[source,asciidoc]
----
stem:[
\text{Speedup}_2 = \frac{1}{0.5 + \frac{0.5}{1.6}} = \frac{1}{0.5 + 0.3125} = \frac{1}{0.8125} \approx 1.23
]
----

[discrete]
==== 结论

- 方法一的加速比约为 stem:[1.22]
- 方法二的加速比约为 stem:[1.23]
- 所以 **方法二略优**

[discrete]
==== 正确答案

*B. 第二种方法的加速比是 1.23，效果较好*
</t>
<t tx="swot.20250514132317.1">某工程的进度计划网络图如下，其中包含了 10 个节点，节点之间的箭线表示作业及其进度方向，箭线旁标注了作业所需的时间（单位：周）。设起始节点 A 的时间为0，则节点 E 的最早时间和最迟时间分别为（D）周。

    A 9,19
    B 9,18
    C 15,17
    D 15,16

.如图所示
[graphviz, target="img/graphviz_critical-path-2025-05-14-132756", format=svg]
....
digraph critical_path {
    rankdir=LR;
    node [shape = circle];
    A[style = filled, fillcolor = "lightblue", fontcolor = "black"];
    C[style = filled, fillcolor = "lightblue", fontcolor = "black"];
    D[style = filled, fillcolor = "lightblue", fontcolor = "black"];
    E[style = filled, fillcolor = "lightblue", fontcolor = "black"];
    G[style = filled, fillcolor = "lightblue", fontcolor = "black"];
    I[style = filled, fillcolor = "lightblue", fontcolor = "black"];
    J[style = filled, fillcolor = "lightblue", fontcolor = "black"];
    

    A -&gt; B [label = "7"];
    A -&gt; C [label = "5" color = "red"];
    A -&gt; D [label = "6"];

    B -&gt; E [label = "2"];
    B -&gt; D [label = "0"];
    B -&gt; F [label = "3"];

    C -&gt; D [label = "5" color = "red"];
    C -&gt; E [label = "4"];
    C -&gt; F [label = "7"];
    C -&gt; H [label = "8"];

    D -&gt; E [label = "5" color = "lightblue"];
    D -&gt; F [label = "5" color = "red"];

    E -&gt; G [label = "5" color = "lightblue"];
    E -&gt; I [label = "4"];
    E -&gt; H [label = "3"];

    F -&gt; G [label = "6" color = "red"];
    F -&gt; I [label = "5"];
    F -&gt; H [label = "3"];

    G -&gt; I [label = "2" color = "red"];
    G -&gt; J [label = "6"];

    I -&gt; J [label = "5" color = "red"];

    H -&gt; I [label = "1"];
    H -&gt; J [label = "7"];
}
....

分析：关键路线是 ACDFGIJ，共 28 周。

* 节点 E 的最早时间：找前面最长的路径为 *ACDE=15* (因为 E 要等最长的路径完成才能开始)

* 节点 E 的最迟时间：E 后面最长的路径为 *EGIJ=12*，所以 E 要在第 12 周之前开始。
  ** 总共是 28 周，所以 E 最晚要在第 *28 - 12 = 16* 周开始。

所以答案是：D
</t>
<t tx="swot.20250514154815.1">[discrete]
===== 数据库中的候选键（Candidate Key）

在数据库中，*候选键（Candidate Key）* 是指在一个关系（表）中，能够唯一标识元组（记录）的属性或属性组合。

[discrete]
===== 候选键的两个重要特性

. *唯一性（Uniqueness）*  
  能唯一标识一条记录，表中任意两个元组在该属性（组）上的值不相同。

. *最小性（Minimality）*  
  候选键不能再简化，即不能再去掉其中的任何一个属性，否则就不能保证唯一性。

[discrete]
===== 示例

假设有一个学生表 `Student`：

[cols="1,1,1,1", options="header"]
|===
| 学号（student_id） | 身份证号（id_card） | 姓名（name） | 电话号码（phone）
| 1001              | 123456789012345678 | 张三         | 13800000001
| 1002              | 234567890123456789 | 李四         | 13800000002
|===

分析：

- `student_id` 能唯一标识一个学生 → 是候选键。
- `id_card` 也是唯一的 → 是候选键。
- `name` 和 `phone` 单独都不唯一 → 不是候选键。
- 如果 `name + phone` 组合能唯一标识学生，也可作为候选键（但通常不推荐）。

[discrete]
===== 候选键与主键的关系

- *主键（Primary Key）* 是从候选键中选出来的一个，作为主要标识使用。
- 一个表可以有多个候选键，但 *只能有一个主键*。

[discrete]
===== 小结

[cols="1,3", options="header"]
|===
| 概念 | 说明
| 候选键 | 能唯一标识记录，且不能再简化
| 主键   | 候选键中被选为主标识的那个
| 唯一性 | 所有记录的该键值都不相同
| 最小性 | 不能包含多余的属性
|===
</t>
<t tx="swot.20250514185836.1">什么是无损连接分解？

**一个关系 R 被分解成若干子关系（如 R1、R2），如果通过自然连接（JOIN）能**：

* 完全还原出原关系 R，
* 且没有出现冗余或丢失信息，

就称为这个分解是 **无损连接（Lossless Join）**。

---

如何判断分解是否为无损连接？

对两个子关系 `R1` 和 `R2`，只要满足以下 **任意一条**，就是无损连接：

&gt; **`R1 ∩ R2 → R1 - R2 ∈ F⁺`**
&gt; **或**
&gt; **`R1 ∩ R2 → R2 - R1 ∈ F⁺`**

说明：

* `R1 ∩ R2`: 两个子关系的**交集属性**
* `R1 - R2`: `R1` 中独有的属性
* `F⁺`: 函数依赖集合 `F` 的**闭包**

---

判断步骤（口诀）：

1. **求交集** `R1 ∩ R2`
2. **求差集** `R1 - R2` 和 `R2 - R1`
3. 判断交集属性能否推出任意一个差集（在 `F⁺` 中）

   * 如果能推出 ⇒ ✅ 无损连接
   * 否则 ⇒ ❌ 有损连接

---

小结一句话：

&gt; **只要两个表的交集属性能推出任意一边的差集，就一定是无损连接。**


*举例说明：*

假设：

* 原关系：R(A, B, C)
* 函数依赖：F = { A → B }
* 分解为：
    ** R1(A, B)
    ** R2(A, C)

分析：

* R1 ∩ R2 = A
* R1 - R2 = B
* R2 - R1 = C

我们去判断：

* A → B ∈ F⁺ ✅ 是的！所以满足第一条 ⇒ 无损连接！

即使：

* A → C ❌ 不成立也无所谓！
</t>
<t tx="swot.20250514192758.1">对于如下所示的有向图，其邻接矩阵是一个（A）的矩阵。

[graphviz, target="img/graphviz-2025-05-14-193037", format=svg]
....
digraph nodes_number {
    rankdir=LR;
    node [shape = circle];
    1 -&gt; 2;
    1 -&gt; 3;
    2 -&gt; 4;
    2 -&gt; 5;
    3 -&gt; 4;

}
....

    A 5*5
    B 5*7
    C 7*5
    D 7*7

分析：*邻接矩阵的定义：*

对于一个有向图，邻接矩阵是一个 n × n 的矩阵，其中 n 是图中顶点的个数。*所以答案是 A。*

行和列都表示图中的顶点：

* 行号表示“从哪个顶点出发”（起点）
* 列号表示“到哪个顶点去”（终点）
* 行列交点的值表示是否存在这样的边。如果存在从顶点 i 到顶点 j 的边，则 A[i][j] = 1，否则为 0。

.邻接矩阵（顶点 1 到 5）
[cols="6*^", options="header"]
|===
|     | 1 | 2 | 3 | 4 | 5

| 1   | 0 | 1 | 1 | 0 | 0
| 2   | 0 | 0 | 0 | 1 | 1
| 3   | 0 | 0 | 0 | 1 | 0
| 4   | 0 | 0 | 0 | 0 | 0
| 5   | 0 | 0 | 0 | 0 | 0
|===

.构造邻接表
[cols="1,1",options="header"]
|===
| 顶点 | 邻接点（即表结点）
| 1  | 2 和 3
| 2  | 4 和 5
| 3  | 4
| 4  | —（无）
| 5  | —（无）
|===
</t>
<t tx="swot.20250514205841.1">对一组数据 2,12,16,88,5,10 进行排序，如果前 3 趟排序结果如下：

. 第一趟排序结果：2,12,16,5,10,88
. 第二趟排序结果：2,12,5,10,16,88
. 第三趟排序结果：2,5,10,12,16,88

则采用的排序算法可能是（A）

    A 冒泡排序
    B 希尔排序
    C 归并排序
    D 基数排序

---

解析：

分析排序过程：

* 第一趟：88 被移动到了最后一位，表现为将最大元素“冒”到末尾。
* 第二趟：16 被移到倒数第二位，继续“冒”出次大元素。
* 第三趟：前半部分继续调整，最后形成整体有序序列。

该过程符合冒泡排序的特点：

- 每一趟比较相邻元素，交换顺序错误的对。
- 每一趟结束后，最大元素沉到正确位置。
- 多趟执行，最终完成排序。

排除其他选项：

- B. 希尔排序：采用分组排序，不是这种逐步交换相邻元素的过程。
- C. 归并排序：采用分治合并，不会有线性逐步“冒出”最大值的现象。
- D. 基数排序：非比较类排序，按位处理，过程差异较大。

答案：

A. 冒泡排序
</t>
<t tx="swot.20250514212913.1">:stem: latexmath
集合 stem:[\mathbb{Z}_{26}] 表示的是从 0 到 25 的整数集合：
stem:[\mathbb{Z}_{26} = \{0, 1, 2, \dots, 25\}]

加密函数定义如下：
stem:[E_k(i) = (k \cdot i) \bmod 26]

现在给定密钥 stem:[k = 7]，加密函数为：
stem:[E_7(i) = (7 \cdot i) \bmod 26]

NOTE: 把 i 乘以 7，然后对 26 取余，结果还是一个 0 到 25 之间的数。

问：这个加密函数属于以下哪种函数类型？ *答案为 D*

- A. 单射但非满射
- B. 满射但非单射
- C. 非单射且非满射
- D. 双射（既是单射也是满射）

术语解释

- **单射**：不同的输入不会被映射成相同的输出，即 stem:[E(i) = E(j) \Rightarrow i = j]。
- **满射**：输出值可以覆盖到所有 stem:[\mathbb{Z}_{26}] 中的值。
- **双射**：既是单射又是满射，一一对应且全覆盖。

正确答案：**D. 双射**

---

怎么判断是否是双射？

有个简单的数学规则：只要 7 和 26 没有公因数（除了1），这个函数就是双射。

我们检查一下：gcd(7,26)=1

说明：7 和 26 没有共同因数（比如 2、3、13 这些），所以它们是 *互质* 的。

结论：这个加密函数是 双射，也就是说它：

* 不会把两个不同的数字加密成同一个结果（单射）
* 所有可能的加密结果（0 到 25）都能被产生出来（满射）
</t>
<t tx="swot.20250515061953.1">设散列函数为 H（key）= key % 11，对于关键码序列（23，40，91，17，19，10，31，65，26），用线性探查法解决冲突构造的哈希表为（ ）。

---

直接计算吧，不列出选项了。

构造哈希表方法：线性探查法（开放地址法）
模 11 插入过程：

- 23 % 11 = 1 → 插入地址 1
- 40 % 11 = 7 → 插入地址 7
- 91 % 11 = 3 → 插入地址 3
- 17 % 11 = 6 → 插入地址 6
- 19 % 11 = 8 → 插入地址 8
- 10 % 11 = 10 → 插入地址 10
- 31 % 11 = 9 → 插入地址 9
- 65 % 11 = 10 → 地址 10 已占 → 往下循环探查地址为 0 → 插入地址 0
- 26 % 11 = 4 → 插入地址 4

最终哈希表：

[cols="12*^",options="header"]
|===
|哈希地址 |0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10
|关键码   |65|23|  |91|26|  |17|40|19|31|10
|===
</t>
<t tx="swot.20250515063523.1">:stem: latexmath
10000 张分辨率为 1024X768 的真彩（32位）图片刻录到DVD光盘上，假设每张光盘可以存放 4GB 的信息，则需要（B）张光盘。

    A 7
    B 8
    C 70
    D 71

---

图像数据大小与光盘数量计算（二进制单位），32位 指每个像素占用 32bit。

[discrete]
==== 图像数据量计算方法

每张图片的分辨率为 1024×768，色深为 32 位（即每像素 32 bit），共 10000 张图片。

总数据量（以 bit 为单位）如下：

[latexmath]
++++
图像数据量：10000 × 1024 × 768 × 32\text{ bit}
++++

[discrete]
==== 光盘容量换算方式

每张光盘容量为 4GB，其中：

[latexmath]
++++
1GB 为 2^{30} 字节（Byte），即 2^{30} × 8 bit
++++

所以每张光盘容量为：

[latexmath]
++++
4 × 2^{30} × 8 bit
++++

[discrete]
==== 所需光盘张数计算步骤

将图像总数据量除以单张光盘容量，得到：

[latexmath]
++++
\frac{10000 × 1024 × 768 × 32}{4 × 2^{30} × 8} ≈ 7.3
++++

最终结果向上取整为：8 张光盘
</t>
<t tx="swot.20250515075939.1">内存按字节编址，地址从 A0000H 到 CFFFFH 的内存，共存（D）字节，若用存储容量为 64k×8bit 的存储器芯片构成该内存空间，至少需要（ ）片。

    A 80KB
    B 96KB
    C 160KB
    D 192KB

    A 2
    B 3
    C 5
    D 8

---

从 A0000H 到 CFFFFH 有多少字节？你可以这样估算：

* 起始 A0000H ≈ 第 10 个 64KB（A=10）

* 结束 CFFFFH ≈ 第 13 个 64KB（C=12，因为地址从0开始数）

→ 总共跨了 3 × 64KB = 30000H = 192KB

你要的总容量是 192KB，每片芯片容量是 64KB：

所以，192KB ÷ 64KB = 3（片芯片），这就是需要芯片的最少数量。

</t>
<t tx="swot.20250515105142.1">若事务T1对数据A已加排它锁，那么其它事务对数据A（D） 。

    A 加共享锁成功，加排它锁失败 
    B 加排它锁成功，加共享锁失败 
    C 加共享锁、加排它锁都成功 
    D 加共享锁、加排它锁都失败

---

解析：本题考查的是数据库事务处理方面的基础知识。并发事务如果对数据读写时不加以控制，会破坏事务的隔离性和一致性。

控制手段就是加锁，在事务执行时限制其他事务对数据的读取。在并发控制中引入两种锁：

* 排他锁（Exclusive Locks，X锁）
* 共享锁（Share Locks，S锁）。

排它锁又称为写锁，用于对数据进行写操作时进行锁定。如果事务T对数据A加上X锁后，就只允许事务T对数据A进行读取和修改，其他事务对数据A不能再加任何锁，从而也不能读取和修改数据A，直到事务T释放A上的锁。

共享锁又称为读锁，用于对数据进行读取时进行锁定。如果事务T对数据A加上了S锁之后，事务T就只能对数据A进行读
取操作，但不可以修改。其他事务可以再对数据A加S锁来读取，只要数据A上有S锁，任何事务都只能对其加S锁读取而不能加X锁修改。因此，正确答案是D
</t>
<t tx="swot.20250515105738.1">在某销售系统中，客户采用扫描二维码进行支付。若采用面向对象方法开发该销售系统，则客户类属于（B）类， 二维码类属于（A）类。

    A 接口
    B 实体
    C 控制
    D 状态

---

解析：

类可以分为三种：实体类、接口类（边界类）和控制类。

实体类的对象表示现实世界中真实的实体，如人、物等。

接口类（边界类）的对象为用户提供一种与系统合作交互的方式，分为人和系统两大类，其中人的接口可以是显示屏、窗口、Web窗体、对话框、菜单、列表框、其他显示控制、条形码、二维码或者用户与系统交互的其他方法。系统接口涉及到把数据发送到其他系统，或者从其他系统接收数据。

控制类的对象用来控制活动流，充当协调者。
</t>
<t tx="swot.20250515113552.1">将三对角矩阵 A[1…100][1...100] 按行优先存入一维数组 B[1...298] 中，A中元素 A[66][65] 在数组 B 中的位置k为（B）。

    A 198
    B 195
    C 197
    D 196

---

对于三对角矩阵，将 A[1..n][1..n] 压缩至 B[1..3n-2] 时，a(ij) 与 b(k) 的对应关系为 k=2i+j-2。
则 A 中的元素 A[66][65] 在数组 B 中的位置 k=2*66+65-2=195
</t>
<t tx="swot.20250515144631.1">给定关系模式R(A1，A2，A3，A4)上的函数依赖集F={A1A3-&gt;A2,A2-&gt;A3}。若将R分解为p ={(A1,A2),(A1,A3)}，则该分解是（D）的。

    A 无损联接且不保持函数依赖
    B 无损联接且保持函数依赖
    C 有损联接且保持函数依赖
    D 有损联接且不保持函数依赖

---

原始函数依赖分析，给定函数依赖集：

    F = { A1A3 -&gt; A2, A2 -&gt; A3 }

分析依赖是否在子关系中完整保留

* 依赖 A1A3 -&gt; A2：
** 涉及属性：A1, A3, A2
** 子关系为：
  - R1 = (A1, A2)
  - R2 = (A1, A3)
** 该依赖所涉及的所有属性并不完全存在于某一个子关系中。

* 依赖 A2 -&gt; A3：
** 涉及属性：A2, A3
** 子关系中：
  - R1 包含 A2，但不包含 A3
  - R2 包含 A3，但不包含 A2
** 同样，该依赖也不完全存在于任一子关系中。

结论：该分解 *不保持函数依赖*。

IMPORTANT: 如果 F 中两个依赖的任何一个不能从 F1 ∪ F2 推导出，那就不保持函数依赖。

NOTE: 无损联接使用前面的方法进行判断。
</t>
<t tx="swot.20250515150959.1">在某班级管理系统中，班级的班委有班长、副班长、学习委员和生活委员，且学生年龄在15\~25岁。若用等价类划分来进行相关测试，则（ ）不是好的测试用例。

    A (队长，15)
    B (班长，20)
    C (班长，15)
    D (队长，12)

---

等价类划分测试题解析

本题考查的是 *等价类划分测试方法*，该方法用于将输入条件分为有效和无效的等价类，以设计具有代表性的测试用例，从而提高测试效率。

题设信息分析

* 班委职位限定为：`班长`、`副班长`、`学习委员`、`生活委员`
** → 合法职位等价类为上述四个
** → 其他职位（如`队长`）属于无效等价类

* 学生年龄限定为：`15~25`岁（含边界）
** → 有效等价类：15 ≤ 年龄 ≤ 25
** → 无效等价类：年龄 &lt; 15 或 年龄 &gt; 25

.选项逐一分析
[cols="1,4", options="header"]
|===
|选项 |分析

|A. `(队长, 15)` 
|职位为无效等价类，年龄为有效边界值 → 组合合理，用于测试非法职位  
_→ 是一个有效的测试用例_

|B. `(班长, 20)`
|职位与年龄均为有效等价类，属于正常输入  
_→ 是一个有效的测试用例_

|C. `(班长, 15)`
|职位有效，年龄处于边界值（15）  
_→ 是一个边界值测试用例，合理有效_

|D. `(队长, 12)`
|职位和年龄均为无效等价类，无法判断失败原因  
_→ **不是一个好的测试用例**_
|===

*正确答案：* `D`  
因为选项 D 同时落在两个无效等价类中，不利于定位具体的错误来源，因此不是一个好的测试用例。
</t>
<t tx="swot.20250515153435.1">假设一台按字节编址的 16 位计算机系统 (此信息在本题中未用到)，采用虚拟页式存储管理方案，页面大小为 2KB（2048 字节），系统中没有使用快表。某用户程序执行以下指令：

`MOVE data1, data2`

- `MOVE` 是一个 4 字节指令。
- `data1` 和 `data2` 是两个 32 位操作数（各占 4 字节）。
- 地址分布如下：
  - `MOVE` 指令从地址 `2047` 开始
  - `data1` 从地址 `6143` 开始
  - `data2` 从地址 `10239` 开始

程序页表信息：

- 仅页号为 `0` 的页面在内存中（状态位为 1）
- 其他页均不在内存（状态位为 0）

*页面编号的计算方式*

由于页面大小为 2KB = 2048 字节 = 2^11，因此每个地址属于的页号可通过如下方式计算：

* 页号 = 地址 ÷ 2048（在机器中等价于位操作：页号 = 地址 &gt;&gt; 11）
* 页内偏移 = 地址 % 2048 (本题未用到)


.地址与页号的划分示例如下：
[cols="1,1,1"]
|===
| 地址范围       | 页号   |原始状态

| 0 ~ 2047       | 0    |1 (开始只有0页号在内存中)
| 2048 ~ 4095    | 1    |0
| 4096 ~ 6143    | 2    |0
| 6144 ~ 8191    | 3    |0
| 8192 ~ 10239   | 4    |0
| 10240 ~ 12287  | 5    |0
|===

*缺页中断分析*

取指令：地址 2047~2050

- 地址 2047：页号 0（在内存）✅
- 地址 2048、2049、2050：页号 1（不在内存）❌

→ 访问页号 1 时触发 1 次缺页中断

**取指令缺页中断次数：1**

取 data1 操作数：地址 6143~6146

- 地址 6143：页号 2（不在内存）❌
- 地址 6144~6146：页号 3（不在内存）❌

→ 跨两个页：页号 2 和 3，各触发 1 次缺页中断

**取 data1 缺页中断次数：2**

取 data2 操作数：地址 10239~10242

- 地址 10239：页号 4（不在内存）❌
- 地址 10240~10242：页号 5（不在内存）❌

→ 跨两个页：页号 4 和 5，各触发 1 次缺页中断

**取 data2 缺页中断次数：2**

---

*最终结果*

执行 `MOVE data1, data2` 指令将产生：

- 总缺页中断次数：**5**
- 其中：
  * 取指令产生：**1** 次缺页中断
  * 取 data1 操作数产生：**2** 次缺页中断
  * 取 data2 操作数产生：**2** 次缺页中断
</t>
<t tx="swot.20250515160236.1">一个高度为 h 的满二叉树的结点总数为 stem:[2^h-1]，从根结点开始，自上而下、同层次结点从左至右，对结点按照顺序依次编号，即根结点编号为 1，其左、右孩子结点编号分别为 2 和 3，再下一层从左到右的编号为 4，5，6，7，依此类推。
那么，在一棵满二叉树中，对于编号为 m 和 n 的两个结点，若 n = 2 m + 1,则 （ ）。

    A m是n的左孩子
    B m是n的右孩子
    C n是m的左孩子
    D n是m的右孩子

---

我们来分析题目中给出的二叉树节点编号规律：

在满二叉树中，按照从上到下、从左到右的顺序进行编号：

* 根节点编号为 1
* 对于任意编号为 m 的节点：
    ** 它的左孩子编号是 2m
    ** 它的右孩子编号是 2m + 1

根据编号规律，编号为 m 的结点的右孩子编号为：`2m + 1`

而题目中给出：`n = 2m + 1`

因此，**n 是 m 的右孩子**。

*正确答案：* *D. n 是 m 的右孩子*

.最简单作法
[IMPORTANT]
====
1. 画个满二叉树图
+
[mermaid, target=img/mermaid-2025-05-23-224518, format=svg]
....
flowchart TD

    1 --- 2
    1 --- 3
    2 --- 4
    2 --- 5
    3 --- 6
    3 --- 7
....

2. 取个节点比如 2 想成是 m，则 2 的左节点是 4（2m），那么 2 的右节点是 5 （2m+1=n）即能得到正确答案为 **D: n 是 m 的右孩子**
====
</t>
<t tx="swot.20250515161644.1">IP 地址块 `155.32.80.192/26` 包含了（C）个主机地址，以下 IP 地址中，不属于这个网络的地址是（D）。

主机数量选项：

A. 15  
B. 32  
C. 62  
D. 64  

待判断的 IP 地址选项：

A. 155.32.80.202  
B. 155.32.80.195  
C. 155.32.80.253  
D. 155.32.80.191  

---

第一步：确定子网的范围

- IP 地址块：`155.32.80.192/26`
- 子网掩码：`/26` → `255.255.255.192` → 最后一个字节为 `11000000`
- 可用地址总数：2^(32 - 26) = 64
- 网络地址：`155.32.80.192`
- 广播地址：`155.32.80.255`
- 可分配主机地址范围：`155.32.80.193` ～ `155.32.80.254`
- 可用主机地址数：64 - 2 = `62`

因此，正确选项为：`C. 62`

---

第二步：判断给出的 IP 地址是否属于该子网

[cols="1,1,2", options="header"]
|===
| 选项 | IP 地址        | 是否属于 155.32.80.192/26？
| A    | 155.32.80.202  | 是，介于 193～254 之间
| B    | 155.32.80.195  | 是，介于 193～254 之间
| C    | 155.32.80.253  | 是，介于 193～254 之间
| D    | 155.32.80.191  | 否，它属于前一子网（155.32.80.128/26）
|===

因此，不属于该子网的 IP 是：`D. 155.32.80.191`

---

最终答案：

- 主机数量正确选项：`C. 62`
- 不属于该网络的地址：`D. 155.32.80.191`
</t>
<t tx="swot.20250515180535.1">在开发一个字处理软件时，首先快速发布了一个提供基本文件管理、编辑和文档生成功能的版本，接着发布提供更完善的编辑和文档生成功能的版本，最后发布提供拼写和语法检查功能的版本，这里采用了____过程模型。

    A 瀑布
    B 快速原型
    C 增量
    D 螺旋

---

本题考查软件过程模型的基础知识。

* 瀑布模型从一种非常高层的角度描述了软件开发过程中进行的活动，并且提出了要求开发人员经过的事件序列。

* 原型模型允许开发人员快速地构造整个系统或系统的一部分以理解或澄清问题。

* 增量开发是把软件产品作为一系列的增量构件来设计、编码、集成和测试，系统功能在增量中不断完善或者增加。

* 螺旋模型把开发活动和风险管理结合起来，以将风险减到最小并控制风险。
</t>
<t tx="swot.20250515194932.1">设n是描述问题规模的非负整数，下面程序片段的时间复杂度是（A）。

    x=2；
    while(x&lt;n/2)
        x=2*x；

    A O(log2n)
    B O(n)
    C O(nlog2n)
    D O(n^2)

---

该程序片段的时间复杂度可以通过分析循环次数来确定。

初始时，x=2，每次循环x被乘以2，直到x &gt;= n/2。

设循环执行 k 次后，x 的值为 stem:[2^{k+1}]。 
终止条件为 stem:[2^{k+1} \ge \frac{n}{2}]，
解得 stem:[k+1 \ge \log_2{\frac{n}{2}}]，即 stem:[k \ge \log_2{n} - 2]
忽略常数项后，时间复杂度为 stem:[O(\log_2{n})]。

答案：A O(log2n)
</t>
<t tx="swot.20250515211219.1">:stem: latexmath
利用栈对算术表达式 stem:[10 \times (40-30/5)+20] 求值时，存放操作数的栈(初始为空)的容量至少为（C ），才能满足暂存该表达式中的运算数或运算结果的要求。

    A 2    B 3    C 4    D 5

---

[discrete]
====  初始理解题目

题目给出了一个算术表达式：stem:[10 \times (40-30/5)+20]，并要求我们在利用栈（stack）来求值这个表达式时，存放操作数的栈（操作数栈）至少需要多大的容量。这里的“容量”指的是栈能够同时存放的操作数的最大数量。初始时栈是空的。

[discrete]
====  栈在表达式求值中的应用

在计算机科学中，栈常用于算术表达式的求值，尤其是使用“后缀表达式”（逆波兰表示法）或通过“中缀表达式”直接求值。通常，我们会使用两个栈：一个操作数栈（存放数字），一个运算符栈（存放运算符）。#但本题只关注操作数栈的容量#。

在中缀表达式的求值过程中，我们通常会按照运算符的优先级和括号的顺序来计算。具体步骤如下：

1. 初始化两个栈：操作数栈和运算符栈。
2. 从左到右扫描表达式：
   - 遇到数字，压入操作数栈。
   - 遇到运算符：
     * 如果运算符栈为空，或栈顶是左括号，或当前运算符优先级高于栈顶运算符，则压入运算符栈。
     * 否则，从运算符栈弹出运算符，从操作数栈弹出相应数量的操作数进行计算，将结果压回操作数栈，然后继续比较当前运算符与新的栈顶运算符。
   - 遇到左括号，压入运算符栈。
   - 遇到右括号，不断弹出运算符栈的运算符并计算，直到遇到左括号，弹出左括号。
3. 表达式扫描完后，弹出运算符栈中所有运算符并计算。
4. 最后操作数栈中剩下的就是结果。

NOTE: 我们要看这期间，运算符栈最多被占用了多少个。

[discrete]
====  应用到具体表达式

让我们一步一步地计算表达式 stem:[10 \times (40-30/5)+20]，并跟踪操作数栈的最大使用量。

1. 初始：

    操作数栈: []
    运算符栈: []
    最大操作数栈大小: 0

2. 遇到 `10`（数字）：

    压入操作数栈: [10]
    最大大小: max(0, 1) = 1

3. 遇到 x：

    运算符栈为空，压入 [x]
    操作数栈: [10]
    最大大小: 1

4. 遇到 `(`：

    压入运算符栈: [x, (]
    操作数栈: [10]
    最大大小: 1

5. 遇到 `40`：

    压入操作数栈: [10, 40]
    最大大小: max(1, 2) = 2

6. 遇到 `-`：

    栈顶是 `(`，压入 `-`: [x, (, -]
    操作数栈: [10, 40]
    最大大小: 2

7. 遇到 `30`：

    压入操作数栈: [10, 40, 30]
    最大大小: max(2, 3) = 3

8. 遇到 `/`：

    栈顶是 `-`，`/` 优先级高于 `-`，压入 `/`: [x, (, -, /]
    操作数栈: [10, 40, 30]
    最大大小: 3

9. 遇到 `5`：

    压入操作数栈: [10, 40, 30, 5]
    最大大小: max(3, 4) = 4

10. 遇到 `)`：开始弹出并计算，直到 `(`：

    弹出 `/`，弹出 `5` 和 `30`，计算 `30 / 5 = 6`，压入 `6`:
        操作数栈: [10, 40, 6]
        最大大小: 4（之前达到过）

    弹出 `-`，弹出 `6` 和 `40`，计算 `40 - 6 = 34`，压入 `34`:
        操作数栈: [10, 34]
        最大大小: 4

    弹出 `(`:
        运算符栈: [x]
        操作数栈: [10, 34]
        最大大小: 4

11. 遇到 `+`：

    栈顶是 `x`，`+` 优先级低于 `x`，所以弹出 `x`，弹出 `34` 和 `10`，计算 `10 * 34 = 340`，压入 `340`:
       操作数栈: [340]
       最大大小: 4

    现在运算符栈为空，压入 `+`: ['+']
    操作数栈: [340]
    最大大小: 4

12. 遇到 `20`：

    压入操作数栈: [340, 20]
    最大大小: max(4, 2) = 4

13. 表达式结束，弹出运算符栈中的 `+`：

    弹出 `+`，弹出 `20` 和 `340`，计算 `340 + 20 = 360`，压入 `360`:
       操作数栈: [360]
       最大大小: 4

[discrete]
====  最大操作数栈大小的观察

在整个过程中，操作数栈的大小变化如下：

- [] (0)
- [10] (1)
- [10, 40] (2)
- [10, 40, 30] (3)
- #[10, 40, 30, 5] (4) ← 最大值#
- [10, 40, 6] (3)
- [10, 34] (2)
- [340] (1)
- [340, 20] (2)
- [360] (1)

因此，操作数栈最大是 4。

[discrete]
====  验证其他路径

为了确保没有更大的需求，让我们看看是否有其他操作顺序会导致更大的栈大小。关键在于嵌套的计算：

在 `(40 - 30 / 5)` 部分：

- `30 / 5` 需要 `30` 和 `5` 都在栈中，此时栈是 `[10, 40, 30, 5]`（大小4）。
- 计算 `30 / 5` 后，栈变为 `[10, 40, 6]`（大小3）。
- 然后 `40 - 6` 需要 `40` 和 `6` 在栈中（大小2）。

没有其他部分需要同时存储更多的操作数。

[discrete]
====  排除其他选项

- A. 2：在 `30 / 5` 时需要 `30` 和 `5` 同时在栈中，此时栈中已经有 `10` 和 `40`，所以至少需要 4。
- B. 3：同样，`[10, 40, 30, 5]` 需要 4。
- D. 5：从未达到过 5。

因此，正确答案是 C. 4。

[discrete]
====  可能的误区

有时候可能会忽略括号内的计算对栈的影响。例如，可能会认为 `10` 和 `40` 是主要的，而忽略 `30` 和 `5` 的同时存在。因此，容易低估栈的最大需求。

另外，可能会混淆操作数栈和运算符栈的大小。本题只问操作数栈，所以不需要考虑运算符栈的大小。
</t>
<t tx="swot.20250515224205.1">正规集(ab|c)(1|2|3),可以识别的字符种类有（D）个

    A 1
    B 2
    C 3
    D 6

---

解析：该正则表达式由两个部分组成

1. `(ab|c)`：表示可以是字符串 `"ab"` 或字符 `"c"`。
2. `(1|2|3)`：表示可以是字符 `"1"`、`"2"` 或 `"3"`。

匹配的所有字符串：

- `ab1`
- `ab2`
- `ab3`
- `c1`
- `c2`
- `c3`

共计 6 个匹配字符串。

题目问的是可以识别的字符种类个数，不是字符串个数，而是字符种类。

故涉及的字符种类是从所有字符串中提取不重复的字符为：

- `a`
- `b`
- `c`
- `1`
- `2`
- `3`

共 6 种字符。
</t>
<t tx="swot.20250515225119.1">一个具有 n(n＞0) 个顶点的无向连通图至少有（ ）条边。

    A n+1
    B n
    C n/2
    D n-1

---

一个具有 stem:[n (n &gt; 0)]个顶点的**无向连通图**，至少有 stem:[n - 1] 条边。

这是因为：

* 无向连通图的最小边数是形成**一棵树**的情况。
* 一棵包含 n 个顶点的树恰好有 stem:[n - 1] 条边，且是**连通无环图**。
* 如果边数再少，就不能保持连通性。

所以答案是：**stem:[n - 1]** 条边。
</t>
<t tx="swot.20250516063422.1">:stem: latexmath
某计算机指令字长为 16 位，指令有双操作数、单操作数和无操作数 3 种格式，每个操作数字段均用 6 位二进制表示，该指令系统共 有 m 条（m&lt;16）双操作数指令，并存在无操作数指令。若采用扩展操作码技术，那么最多还可设计出（B）条单操作数指令。

    A 2^6
    B（2^4-m）×2^6-1
    C（2^4-m）×2^6
    D（2^4-m）×（2^6-1）

---

// 其实对于我来说，这个题的理解还是挺困难的，这是我在 ChatGPT 上的问答。都看完后可以理解了。
// https://chatgpt.com/c/682601ea-5644-8004-8f4a-612ef76e83f6

[discrete]
==== 指令编码与单操作数指令数计算总结

本题考查扩展操作码技术下，指令编码空间的划分与计算方法。

[discrete]
==== 基本条件

* 指令字长：16 位  
* 有三种指令格式：双操作数、单操作数、无操作数  
* 每个操作数字段为 6 位  

[discrete]
==== 双操作数指令格式

- 含两个操作数字段 → 6 位 × 2 = 12 位
- 剩余位数：16 - 12 = 4 位 → 用于操作码
- 4 位操作码最多可表示：stem:[2^4=16] 条不同的双操作数指令

[discrete]
==== 已知条件

- 实际双操作数指令数量为 stem:[m] 条，且 stem:[m &lt; 16]
- 剩余可用操作码数为：stem:[2^4 - m = 16 - m]

[discrete]
==== 扩展操作码原理

- 采用剩余的操作码作为“扩展操作码”入口
- 每一个扩展操作码可对应一种扩展格式指令，例如单操作数指令

[discrete]
==== 单操作数指令格式

- 一个操作数字段：6 位  
- 剩余位数：16 - 6 = 10 位  
- 常见划分方式： *题的选择项中已经给出了 stem:[2^6]*
  * 前 4 位：扩展操作码
  * 后 6 位：表示具体指令编号

- 每个扩展操作码可扩展出：stem:[2^6 = 64] 条单操作数指令

[discrete]
==== 单操作数指令总数计算

- 可用扩展操作码数：stem:[2^4 - m = 16 - m]
- 每个扩展码可扩展出 stem:[2^6 = 64] 条单操作数指令
- 所以最多可设计：stem:[(2^4 - m) \times 2^6 = (16 - m) \times 64]

[discrete]
==== 无操作数指令考虑

- 题目说明存在“无操作数指令”
- 最少需保留 1 条指令编码给无操作数类
- #最终最多可设计单操作数指令数为： stem:[(2^4 - m) \times 2^6 - 1]#

[discrete]
==== 答案选择

B 选项符合上述计算公式，因此答案为：**B**
</t>
<t tx="swot.20250516115732.1">在快速排序过程中，需要设立基准元素并划分序列来进行排序，若序列由元素 {12,25,3,45,52,67,85} 构成，则初始排列为（ A），排序效率最高（令序列的第一个元素为基准元素）。

    A 45，12，3，25，67，52，85
    B 85，67，52，45，3，25，12
    C 12，25，3，45，52，67，85
    D 45，12，25，3，85，67，52

---

在快速排序（Quick Sort）中，选择“基准元素”（pivot）并将序列划分为左右两个子序列的效率对整体排序性能有显著影响。

题目设定为

* 原始序列：{12, 25, 3, 45, 52, 67, 85}
* 使用第一个元素为基准元素
* 要求判断哪种初始排列下划分效率最高

快速排序的关键步骤（简化）：

1. 选定一个基准元素（pivot）。

2. 将序列划分为两个部分：
    ** 左边：比基准元素小的数；
    ** 右边：比基准元素大的数。

3. 对两部分递归地进行排序。

对选项A进行分析：A: 45，12，3，25，67，52，85

* 以第一个元素 45 为基准。
* 划分结果：
    * 小于 45 的部分：12，3，25 → 3 个元素
    * 大于 45 的部分：67，52，85 → 3 个元素

* 划分非常均匀，是理想的情况。
* 所以此时排序效率最高。

对其他选项进行分析：

* B: 85，67，52，45，3，25，12
    ** 以 85 为基准。
    ** 小于 85 的有 6 个，大于的为 0 → 极不均匀 → 最差情况。

* C: 12，25，3，45，52，67，85
    ** 以 12 为基准。
    ** 小于 12 的为 0 个，大于的为 6 → 也是极不均匀。

* D: 45，12，25，3，85，67，52
    ** 同样以 45 为基准。
    ** 小于 45 的：12，25，3 → 3 个
    ** 大于 45 的：85，67，52 → 3 个
    ** 和 A 一样，也很均匀。

但区别在于：选项A中的较小元素和较大元素分别在一侧，便于实现高效的原地划分操作，而 D 中较小和较大的元素是交错分布的，可能导致划分步骤变得复杂，效率略低。

最终结论：答案是 A，因为：

* 使用第一个元素为基准时，它能把数组划分为大小接近的两部分；
* 快速排序在这种情况下效率最高（时间复杂度接近 O(n log n)）。
</t>
<t tx="swot.20250516121545.1">:stem: latexmath
某个二叉查找树（即二叉排序树）中进行查找时，效率最差的情形是该二叉查找树是（C）。

    A 完全二叉树
    B 平衡二叉树
    C 单枝树
    D 满二叉树

---

查找效率最差的情形是当**二叉查找树退化为单枝树**时，这种结构就像一个**链表**，每次查找都只能顺着一个方向（全部左子树或全部右子树）一直找下去，时间复杂度为 **O(n)**，这是最差情况。

各选项解释如下：

- **A. 完全二叉树**：节点尽可能往左靠拢，结构紧凑，查找效率较高，接近 O(log n)。

- **B. 平衡二叉树**：左右子树高度差不超过1，保持良好的平衡性，查找效率高，为 O(log n)。

- **C. 单枝树**：所有节点都只有一个子节点（全左或全右），结构像链表，查找效率最差，为 O(n)。

- **D. 满二叉树**：每个非叶子节点都有两个子节点，并且所有叶子都在同一层，也是结构紧凑，查找效率高。


**正确答案：C 单枝树**


[discrete]
==== 满二叉树（Full Binary Tree）

*定义：*
每个非叶子节点都有两个子节点，所有叶子节点都处于同一层。

*特征：*

- 所有层都被填满
- 节点数为：stem:[2^h - 1] ，其中 h 为树的高度

- 树结构对称、规则

*示意图：*

        A
       / \
      B   C
     / \ / \
    D  E F  G


*查找效率：* 高，约为 stem:[O(\log n)]


[discrete]
==== 完全二叉树（Complete Binary Tree）

*定义*：除了最后一层，其余各层都填满，最后一层从左到右依次排列，不允许中间有空缺。

*特征：*

- 是结构上接近满二叉树的一种
- 节点尽可能靠左排列

*示意图：*

        A
       / \
      B   C
     / \  /
    D  E F


*查找效率：* 高，约为 stem:[O(\log n)]


[discrete]
==== 平衡二叉树（AVL Tree）

*定义*：任意一个节点，其左子树与右子树的高度差的绝对值不超过 1。

*特征：*

- 保持结构平衡，避免退化为链表
- 可通过旋转操作自动调整平衡

*示意图：*

       10
      /  \
     5    15
    / \     \
   2   7     20


*查找效率：* 高，约为 stem:[O(\log n)]


[discrete]
==== 单枝树（Skewed Tree）

*定义：*
所有节点只有一个子节点（要么全左、要么全右），退化成链表结构。

*特征：*

- 最差情况的二叉查找树
- 完全没有平衡性，结构最差

*示意图（右单枝）：*

    1
     \
      2
       \
        3
         \
          4

*查找效率*：最差，约为 stem:[O(n)]
</t>
<t tx="swot.20250516163128.1">假设磁盘块与缓冲区大小相同，每个盘块读入缓冲区的时间为 16us, 由缓冲区送至用户区的时间是 5us, 在用户区内系统对每块数据的处理时间为 1us。

若用户需要将大小为 10 个磁盘 块的 Doc1 文件逐块从磁盘读入缓冲区，并送至用户区进行处理，那么采用单缓冲区需要花费的时间为（D 211）us；

采用双缓冲区需要花费的时间为，（C 166）us。

```
A 160
B 161
C 166
D 211


A 160
B 161
C 166
D 211
```
---

由于缓冲区的访问是互斥的，所以对单一缓冲区，从磁盘写入和读出到用户区的操作必须串行执行，也就是要保证互斥操作。

而 CPU 对数据的分析与从用户区读数据也是需要互斥操作，但是 CPU 分析与从磁盘写入缓冲区的操作可以并行。

从本题看，由于分析所用的时间小于从磁盘写入缓冲区的时间，因此，CPU 会空闲。

单缓冲区的总时间=(磁盘写入缓冲区时间 + 缓冲区读出时间) × 10 + CPU 处理最后一块数据的时间 = (16+5)×10+1 = 211 μs。

---

当采用双缓冲区时，每块缓冲区的操作也必须满足互斥操作，但是，对两块缓冲区的操作却可以并行，所以，当第一个缓冲区写满以后，磁盘紧接着写另一个缓冲区，同时，前一个已经满了的缓冲区被读出到用户区，并立即进行CPU的数据分析。

读出操作和数据分析必须互斥进行，故，从时间上看，当数据被读出并分析后，恰好另一个缓冲区也写满了，可以立即进行读出数据到用户区并进行数据分析。

两块缓冲区交替进行读写，直到数据分析完毕，因此，

总时间=(磁盘写入缓冲区时间)×10 + 读出最后一块数据时间 + CPU分析最后一块数据时间 = (16)×10+5+1=166 us。
</t>
<t tx="swot.20250516232218.1">:stem: latexmath
霍夫曼编码将频繁出现的字符采用短编码，出现频率较低的字符采用长编码。（目的是可以减少存储空间，参下面的频繁出现百分比表）

具体的操作过程为:

1) 以每个字符的出现频率作为关键字构建最小优先级队列（就是按出现频率排个序）;

.频繁出现百分比表
[cols="2,6*",options="header"]
|===
|字符      |a  |b  |c |d  |e |f
|出现频率 % |18 |32 |4 |8 |12 |26
|===

把这个表排序为:

.最小优先级队列
[cols="2,6*",options="header"]
|===
|字符      |c |d  |e |a  |f  |b
|出现频率 % |4 |8 |12 |18 |26 |32
|===

2) 取出关键字最小的两个结点生成子树，根节点的关键字为孩子节点关键字之和，并将根节点插入到最小优先级队列中，直至得到一颗最优编码树。

NOTE: 霍夫曼编码方案是基于贪心策略的。

.画出的树，可用边来推算出编码
[graphviz, target="img/graphviz-2025-05-13-054235", format=svg]
....
digraph G {
    rankdir=LR
    c4  -&gt; 12 [label="0"]
    d8  -&gt; 12 [label="1"]
    12  -&gt; 24 [label="0"]
    e12 -&gt; 24 [label="1"]
    a18 -&gt; 42 [label="0"]
    24  -&gt; 42 [label="1"]
    f26 -&gt; 58 [label="0"]
    b32 -&gt; 58 [label="1"]
    42  -&gt; 100 [label="0"]
    58  -&gt; 100 [label="1"]
}
....

求解：用该方案对包含 *a~f* 六个字符的文件进行编码，文件包含 *100000* 个字符，则与固定长度编码相比，该编码方案节省了 (A) 存储空间。

    A 21%
    B 27%
    C 18%
    D 36%

---

**分析：**
这是对前面学习的哈夫曼编码的深层次应用。

如果对包含 100,000 个字符，且这些字符都属于 a 到 f。那么如果 *采用固定长度的编码*，针对于每个字符需要 3 位来编码（因为有 6 个不同的字符，至少需要 3 位才能表示 6 种不同的变化）。那么对 100000 个字符编码，其编码长度为 300000。

使用哈夫曼编码时，由图可以知道各编码为：

.表格加上编码
[cols="2,6*1",options="header"]
|===
|字符                  |c    |d    |e    |a    |f   |b
|stem:[f_i] 出现频率 %  |4    |8    |12   |18  |26   |32
|stem:[l_i] 编码长度 个 |0100 |0101 |011  |00   |10  |11
|===

因此总的编码长度为:

[stem]
++++
L = \sum_{i=1}^{6} f_i \cdot l_i = 4\%×4 + 8\%×4 + 12\%×3 + 18\%×2 + 26\%×2 + 32\%×2 = 2.36
++++

因此节省的存储空间大小为 stem:[300000 - 2.36 \times 100000 = 64000]

因此节省的存储空间比例为 stem:[\frac{64000}{300000}=21\%]
</t>
<t tx="swot.20250518004209.1">若栈采用顺序存储方式，现有两栈共享空间 V[1..n], top[i] 代表 i (i=1,2) 个栈的栈顶(两个栈都空时 top[1] = 1、top[2] = n)，栈 1 的底在 V[1]，栈 2 的底在 V[n]，则栈满(即 n 个元素暂存在这两个栈)的条件是（ ）。

    A top[1]= top[2]
    B top[1]+ top[2]==1
    C top[1]+ top[2]==n
    D top[1]- top[2]==1

---

*读懂题：*

</t>
<t tx="swot.20250518081336.1">我们就以栈空时 top[1] = 1 来分析。

在栈的顺序存储（数组实现）中，栈顶指针 top 的含义和初始化值取决于具体的实现方式。通常有两种常见的定义方式：

1. top 指向栈顶元素：

* 初始时栈为空，top 可以设置为 -1 或 0（取决于数组下标从 0 还是 1 开始）。
* 例如：
    ** 如果数组下标从 0 开始，初始 top = -1（表示无元素）。
    ** 如果数组下标从 1 开始，初始 top = 0（表示无元素）。
* 入栈时先移动 top，再赋值：top++; stack[top] = x。
* 出栈时先取值，再移动 top：x = stack[top]; top--。

2. top 指向栈顶元素的下一个位置（即“预指向”）：

* 初始时栈为空，top 指向栈的起始位置（如 top = 0 或 top = 1）。
* 例如：
    ** 如果数组下标从 0 开始，初始 top = 0（表示栈空）。
    ** 如果数组下标从 1 开始，初始 top = 1（表示栈空）。
* 入栈时先赋值，再移动 top：stack[top] = x; top++。
* 出栈时先移动 top，再取值：top--; x = stack[top]。


*本题的具体定义*

题目中明确：

* 栈1的底在 V[1]，初始时 top[1] = 1（栈空）。
* 栈2的底在 V[n]，初始时 top[2] = n（栈空）。

因此，本题采用的是 top 指向栈顶元素的下一个位置 的实现方式：

- **栈1**：
  ** 初始 `top[1] = 1`（指向 `V[1]`，但 `V[1]` 尚未存储元素，表示栈空）。
  ** 入栈操作：`V[top[1]] = x; top[1]++`。
  ** 出栈操作：`top[1]--; x = V[top[1]]`。

- **栈2**：
  ** 初始 `top[2] = n`（指向 `V[n]`，但 `V[n]` 尚未存储元素，表示栈空）。
  ** 入栈操作：`V[top[2]] = x; top[2]--`（因为栈2向低地址增长）。
  ** 出栈操作：`top[2]++; x = V[top[2]]`。

*为什么 `top[1] = 1` 表示栈空？*

- 因为 `top[1]` 指向的是 **下一个可以插入的位置**，而不是当前栈顶元素的位置。
- 初始时 `top[1] = 1`，表示下一个可以插入的位置是 `V[1]`，但 `V[1]` 尚未被占用，因此栈中无元素。
- 如果栈中有元素，`top[1]` 会指向比实际栈顶元素高一个的位置。例如：
  ** 插入一个元素 `x` 到栈1：
    *** `V[1] = x; top[1]++` → `top[1] = 2`。
    *** 此时栈顶元素是 `V[1]`，`top[1] = 2` 指向下一个空闲位置。
  ** 再插入一个元素 `y`：
    *** `V[2] = y; top[1]++` → `top[1] = 3`。
    *** 此时栈顶元素是 `V[2]`，`top[1] = 3` 指向下一个空闲位置。

*类比现实场景*

可以类比书桌上的一摞书：

* top 指向的是“可以放下一本书的位置”，而不是“当前最上面的书”。
* 初始时桌面上没有书（栈空），top 指向桌面的起始位置（top = 1）。
* 放一本书后，top 移动到下一个空闲位置（top = 2），而实际最上面的书在位置 1。

*回到题目*

题目中栈满的条件是 `top[1] - top[2] == 1`，因为：
- 栈1从 `V[1]` 向高地址增长，`top[1]` 指向下一个空闲位置。
- 栈2从 `V[n]` 向低地址增长，`top[2]` 指向下一个空闲位置。
- 当 `top[1] - top[2] == 1` 时，表示两个栈的占用区域刚好连续接壤，且没有重叠或空隙，整个数组被占满。

*总结*

初始时 `top[1] = 1` 表示栈空，是因为：

1. `top[1]` 指向的是 **下一个可插入的位置**，而不是当前栈顶元素。
2. 初始时 `V[1]` 未被占用，因此栈中无元素。
3. 这是栈的一种常见实现方式（尤其是双栈共享空间时），目的是统一指针的语义。

最终答案: **D. top[1] - top[2] == 1**</t>
<t tx="swot.20250518083121.1">“栈1的底在 V[1]” 的含义

在顺序存储的双栈共享空间问题中，**“栈1的底在 V[1]”** 表示：

1. **栈1的固定底部位置**：

  - 栈1的**最底层元素**（即**栈底**）始终存储在数组 `V` 的第一个位置 `V[1]`。

  - 这意味着栈1的存储空间从 `V[1]` 开始，向数组的高地址方向（即 `V[2], V[3], ..., V[n]`）增长。

2. **栈1的增长方向**：

  * 栈1的入栈操作（`push`）会使 `top[1]` **增加**（向 `V[n]` 方向移动）。
  * 栈1的出栈操作（`pop`）会使 `top[1]` **减少**（向 `V[1]` 方向移动）。

3. **栈1的初始状态（栈空）**：

  * 初始时，栈1为空，`top[1] = 1`，表示栈顶指针指向 `V[1]`（但 `V[1]` 尚未存储有效数据）。
  * 当第一个元素入栈时，`V[1]` 被填充，`top[1]` 移动到 `V[2]`（指向下一个可插入位置）。


**类比现实场景**

假设有一个书架（数组 `V`），两个栈分别从两端向中间摆放书籍：

- **栈1**：

  ** 从书架的最左侧（`V[1]`）开始放书，`top[1]` 指向下一个可放书的位置。
  ** 初始时没有书（栈空），`top[1] = 1`（指向第一个空位 `V[1]`）。
  ** 放入一本书后，`top[1]` 移动到 `V[2]`（指向下一个空位）。

- **栈2**：

  ** 从书架的最右侧（`V[n]`）开始放书，`top[2]` 指向下一个可放书的位置。
  ** 初始时没有书（栈空），`top[2] = n`（指向第一个空位 `V[n]`）。
  ** 放入一本书后，`top[2]` 移动到 `V[n-1]`（指向下一个空位）。

*为什么“栈1的底在 V[1]”是固定的？*

* 栈的“底”是固定的，因为栈的存储空间是顺序的（数组实现），不能动态调整起始位置。
* 栈1的所有操作（push/pop）都只能在 V[1] 到 top[1] 的范围内进行。
* 栈2同理，其栈底固定在 V[n]，向 V[1] 方向增长。


*栈满的条件推导*

当两个栈的栈顶指针相遇或交叉时，表示空间已满：

* 栈1的 top[1] 指向下一个可插入位置（向高地址增长）。
* 栈2的 top[2] 指向下一个可插入位置（向低地址增长）。
* 栈满时：top[1] - 1（栈1的最后一个元素位置）和 top[2] + 1（栈2的最后一个元素位置）相邻。

** 即 top[1] - 1 == top[2] 或 top[1] == top[2] + 1。
** 题目中采用 top[1] - top[2] == 1 作为栈满条件（选项 D 正确）。

**总结**

- **“栈1的底在 V[1]”** 表示栈1的存储空间从 `V[1]` 开始，向高地址方向增长。
- **初始时 `top[1] = 1` 表示栈空**，因为 `top[1]` 指向的是下一个可插入位置（而非当前栈顶元素）。
- **栈满的条件是 `top[1] - top[2] == 1`**（两个栈的栈顶指针相邻）。

**最终答案** D. top[1] - top[2] == 1
</t>
<t tx="swot.20250518093414.1">写出下面二叉树的先序、中序、后序遍历的关键码序列。

           46
         /    \
       13      54
      /  \       \
     4   38       98
         /        /
       25       62
                   \
                   91
                  /
                79

</t>
<t tx="swot.20250518101209.1">先序遍历的规则：根节点 → 左子树 → 右子树

也就是说：每到一个节点，先访问自己，然后访问左边子树，再访问右边子树。

逐步先序遍历（根 -&gt; 左 -&gt; 右）

---

从根节点 46 开始： [46]

访问 46，左子是 13

访问 13 [46, 13]

* 左子是 4 → 访问 4  [46, 13, 4]
* 右子是 38  [46, 13, 4, 38]

访问 38

* 左子是 25 → 访问 25 [46, 13, 4, 38, 25]
* （38 无右子）

---

回到 46，处理右子：54

* 54 无左 → 访问 54 [46, 13, 4, 38, 25, 54]
* 右子是 98 [46, 13, 4, 38, 25, 54, 98]

访问 98

* 左子是 62 [46, 13, 4, 38, 25, 54, 98， 62]

访问 62

* 没有左子
* 右子是 91 [46, 13, 4, 38, 25, 54, 98， 62, 91]

访问 91

* 左子是 79 → 访问 79 [46, 13, 4, 38, 25, 54, 98， 62, 91, 79]

最终先序遍历结果：[46, 13, 4, 38, 25, 54, 98, 62, 91, 79]

口诀记忆：根左右 —— 一来先访问自己，接着左走到底，最后右处理

</t>
<t tx="swot.20250518101214.1">中序遍历的定义：左子树 → 根 → 右子树

也就是说：

1. 每到一个节点，先去它的左边（如果有）。
2. 左边没有了就访问这个节点。
3. 然后再去它的右边。

---

1. 从 `46` 开始：先访问左子树：到 `13`

2. 到 `13`：先访问左子树：到 `4`

- `4` 没有左 → 访问 `4` ✅
- 回到 `13` → 访问 `13` ✅
- 接着访问右子树：到 `38`

3. 到 `38`：先访问左子树：到 `25`
- `25` 没有左 → 访问 `25` ✅
- 回到 `38` → 访问 `38` ✅

4. 回到根节点：46 → 访问 46 ✅
* #此时为 [4, 13, 25, 38, 46]#

5. 去右子树：到 54
* 54 没有左 → 访问 54 ✅
* 去右子树：到 98

6. 到 98
* 先访问左子树：到 62
* 62 没有左 → 访问 62 ✅
* 去右子树：到 91

7. 到 91
* 先访问左子树：到 79
* 79 没有左 → 访问 79 ✅
* 回到 91 → 访问 91 ✅
* 回到 98 → 访问 98 ✅

所有访问顺序：[4, 13, 25, 38, 46, 54, 62, 79, 91, 98]

小总结技巧：

* 把每个节点当成你“走”到的房间。
* 永远先去左边的房间，一直走到尽头。
* 回头访问自己。
* 然后去右边房间。
</t>
<t tx="swot.20250518101217.1">后序遍历的规则：左子树 → 右子树 → 根节点

也就是说每访问一个节点，先处理它的左边，然后处理右边，最后才访问它自己。

我们从根 46 开始：

---

左子树（13）：

* 左（4）：无左右 → 访问 4，序列为 [4]
* 右（38）：
    ** 左（25）：无左右 → 访问 25，序列为 [4, 25]
    ** 右：无 → 访问 38，序列为 [4, 25, 38]
* 最后访问 13，序列为 [4, 25, 38, 13]

*根节点 46 现在先不访问，要去右子树*

---

右子树（54）：

- 左：无
- 访问右子树（98）：

→ 98 的左子（62）：

- 左：无
- 右（91）：

  ** 左（79）：访问 `79`
  ** 没有右 → 访问 `91`

- 回来访问 `62`

最后访问 `98`

右子树结果是：[79, 91, 62, 98, 54]

*最后访问根节点 46*

总结：最终后序遍历顺序是 [4, 25, 38, 13, 79, 91, 62, 98, 54, 46]

后序口诀帮记忆：左右根（先处理孩子，最后处理自己）
</t>
<t tx="swot.20250519063453.1">:stem: latexmath
某文件系统采用多级索引结构，若磁盘块的大小为 512 字节，每个块号需占 3 字节，
那么根索引采用一级索引时的文件最大长度为 （A） K 字节；
采用二级索引时的文件最大长度为 （C） K 字节。

    A 85    B 170   C 512   D 1024
    A 512   B 1024  C 14450 D 28900

---

*第一问解析：*

磁盘块的大小为 512B，每个块号需占 3B，因此一个磁盘物理块可存放
stem:[512 \div 3 \approx 170] 个块号。

NOTE: 由于不能存半个块号，所以向下取整为 170 个块号。

根索引采用一级索引时的文件最大长度为：
stem:[170 \times 512 \div 1024 = 87040 \div 1024 = 85 \text{KB}]


*第二问解析：*

一级索引结构：根索引块 ——&gt; 直接指向数据块

二级索引结构：根索引块 ——&gt; 指向“一级索引块”（中间层） ——&gt; 每个一级索引块再指向数据块

总共能访问的数据块数量是：stem:[170 \times 170 = 28,900 \text{ 个数据块}]

每个数据块是 512B，所以文件最大大小为：
stem:[28,900 \times 512 = 14796800 \text{ 字节}
= \frac{14796800}{1024} = 14450 \text{ KB}
]

</t>
<t tx="swot.20250519092543.1">设供应商供应零件的关系模式为 SP(Sno，Pno，Qty)，其中 Sno 表示供应商号，Pno 表示零件号，Qty 表示零件数量。查询至少包含了供应商 “168” 所供应的全部零件的供应商号的 SQL 语句如下：

IMPORTANT: 注意这是一张零件表

[source,css]
----
SELECT Sno
FROM SP SPX
WHERE (空1)

(
  SELECT *
  FROM SP SPY
  WHERE (空2) AND NOT EXISTS (
    SELECT *
    FROM SP SPZ
    WHERE (空3)
  )
);
----

***

解：理解题意后要找的是：哪些供应商供应的零件，至少包含了供应商 168 所供应的所有零件？

[source,css]
----
SELECT Sno FROM SP SPX
    WHERE NOT EXISTS (
        SELECT * FROM SP SPY
            WHERE SPY.Sno = '168' AND NOT EXISTS (
                SELECT * FROM SP SPZ
                    WHERE SPZ.Sno = SPX.Sno
                    AND SPZ.Pno = SPY.Pno
                )
    );
----

这种查询模式被称为"关系除法"，是SQL中解决"包含所有"这类问题的标准方法。它使用了双重否定(NOT EXISTS中嵌套NOT EXISTS)来表达"全部包含"的概念。

</t>
<t tx="swot.20250520064315.1">当子查询嵌套得很深时，如何调试、打印每一层的结果？

解法思路总结：虽然不能直接在嵌套的 SQL 中“打印”每一层结果，但可以把子查询单独拎出来，用具体的值代入，然后逐层测试每一层子查询的结果。可以将其拆分为三层，每层都可以单独执行、理解。

我们用一个简化的 SP 表作为例子：

[caption=]
[cols="1,1",options="header"]
|===
| Sno | Pno
| 168 | A  
| 168 | B  
| S1  | A  
| S1  | B  
| S1  | C  
| S2  | A  
| S2  | C  
|===

**第一层：SPY（最简单）**

    SELECT * FROM SP SPY WHERE SPY.Sno = '168';

这会列出供应商 168 供应的所有零件。这一步用于获取“需要包含的全部零件清单”。


**第二层：SPZ（检查某个供应商是否包含指定零件）**

假设想测试 SPX.Sno = 'S1'，可以这样写：

    SELECT * FROM SP SPZ WHERE SPZ.Sno = 'S1' AND SPZ.Pno = 'A';

可以反复用不同的 Pno 测试：

    SELECT * FROM SP SPZ WHERE SPZ.Sno = 'S1' AND SPZ.Pno = 'B';

这两条 SQL 用来测试：S1 是否供应了零件 A 和 B。如果返回结果为空，就说明它没有供应这个零件。


**第三层：完整的 SPY + SPZ 联动检查（某个供应商是否漏了168的某个零件）**

    SELECT * FROM SP SPY WHERE SPY.Sno = '168' AND NOT EXISTS (
    SELECT * FROM SP SPZ WHERE SPZ.Sno = 'S1'   -- 假设我们现在测试 S1
                         AND SPZ.Pno = SPY.Pno
    );

这条 SQL 的含义是：找出供应商 168 的哪些零件 S1 没供应。

* 如果这条查询结果是空的，说明 S1 拥有 168 所有的零件。
* 如果这条查询结果不为空，说明 S1 缺少一些零件。


**最外层：整个结构逐个测试**

遍历所有供应商（Sno），一个一个代入上面这条 SQL：

    -- 替换 SPZ.Sno = 'S1' 为 S2 ...
    SELECT *
    FROM SP SPY
    WHERE SPY.Sno = '168'
      AND NOT EXISTS (
          SELECT * 
          FROM SP SPZ
          WHERE SPZ.Sno = 'S2'
            AND SPZ.Pno = SPY.Pno
      );

* 如果返回结果为空 ⇒ S2 包含所有零件
* 如果有返回 ⇒ S2 少某些零件

**最后就是用 NOT EXISTS 取出相应的 Pno 了**

    SELECT Pno FROM SP SPX WHERE NOT EXISTS (
        -- 把上面的 SQL 放进来
    )
</t>
<t tx="swot.20250520081253.1">假设系统有n (n≥5) 个进程共享资源R，且资源R的可用数为5。若采用PV操作，则相应的信号量S的取值范围应为（D）。

    A -1~n-1
    B -5~5
    C -(n-1)~1
    D -(n-5)~5

---

本题中已知有 n 个进程共享 R 资源，且 R 资源的可用数为 5，故信号量 S 的初值应设为 5。

. 当第1个进程申请资源时，信号量 S 减 1，即 S=4;
. 当第2个进程申请资源时，信号量 S 减 1，即 S=3;
. 当第3个进程申请资源时，信号量 S 减 1，即 S=2;
. 当第4个进程申请资源时，信号量 S 减 1，即 S=1;
. 当第5个进程申请资源时，信号量 S 减 1，即 S=0;
. 当第6个进程申请资源时，信号量 S 减 1，即 S=-1 .....
. 当第n个进程申请资源时，信号量 S 减 1，即 S=-(n-5)。

经上分析，信号量的取值范围应在-(n-5)~5。

NOTE: 信号量可以为负值，负值表示等待资源的进程数。

</t>
<t tx="swot.20250520082915.1">已知文法G: S-&gt;A0|B1，A-&gt;S1|1，B-&gt;S0|0，其中 S 是开始符号。从 S 出发可以推导出（C） 。

    A 所有由0构成的字符串
    B 所有由1构成的字符串
    C 某些0和1个数相等的字符串
    D 所有0和1个数不同的字符串

---

[discrete]
==== 文法规则

    S → A0 | B1  &lt;1&gt;
    A → S1 | 1   &lt;2&gt;
    B → S0 | 0   &lt;3&gt;

[discrete]
==== 关键推导步骤


*基础推导*

    `S → A0 → 10` （0和1各1个）
    `S → B1 → 01` （0和1各1个）

*递归展开示例*

    S → A0 → S10 → (A0)10 → 1010  &lt;1&gt;
    S → B1 → S01 → (B1)01 → 0101  &lt;2&gt;

NOTE: 每次递归调用都会追加平衡的字符对（如 `+0+` 和 `+1+`）

[discrete]
==== 数目关系分析

[cols="1,1,3"]
|===
| 符号 | 数量差特征 | 说明

| S
| 0的数量 = 1的数量
| 因每次展开都会补充对称字符（如A生成`+1+`时必跟`+0+`）

| A
| 0比1少1
| 由规则 &lt;2&gt; 的递归特性决定（`A→S1` 会传递差额）

| B
| 0比1多1
| 由规则 &lt;3&gt; 的递归特性决定（`B→S0` 会传递差额）
|===

[discrete]
==== 选项验证

[cols="1,1,3"]
|===
| 选项 | 结果 | 分析

| A. 全0字符串
| 错误 ×
| 无法生成（所有推导必须同时包含0和1）

| B. 全1字符串
| 错误 ×
| 同上（必须混合0和1）

| C. 某些0和1相等的字符串
| 正确 ✓
| 所有合法推导结果均满足 `n0 = n1`（如10, 01, 1010等）

| D. 所有数目不同的字符串
| 错误 ×
| 与文法特性矛盾（无法生成`n0 ≠ n1`的字符串）
|===

[discrete]
==== 结论

正确答案为选项 *C*

该文法生成的语言是：
`L(G) = { w | w ∈ {0,1}* 且 w中0与1的数量相等 }`
</t>
<t tx="swot.20250520115539.1"></t>
<t tx="swot.20250520115554.1">采用简单选择排序算法对序列(49，38，65，97，76，13，27，49)进行非降序排序，两趟后的序列为（A）。

    A (13，27，65，97，76，49，38，49)
    B (38，49，65，76，13，27，49，97)
    C (13，38，65，97，76，49，27，49)
    D (38，49，65，13，27，49，76，97)

---

简单选择排序（Selection Sort）是每一趟从待排序的序列中选出最小的元素，放到已排序序列的末尾。

给定序列：(49, 38, 65, 97, 76, 13, 27, 49)

第一趟排序：

* 找到最小值，序列中最小的是13。
* 把13与第一个元素49交换，得到：(13, 38, 65, 97, 76, 49, 27, 49)

第二趟排序：

* 从剩余序列(38, 65, 97, 76, 49, 27, 49)中找最小值，最小值是27。
* 把27和第二个元素38交换，得到：(13, 27, 65, 97, 76, 49, 38, 49)

这就是两趟排序后的序列。所以答案为 A

</t>
<t tx="swot.20250520155200.1">一个 C 类网段中划分 5 个子网，每个子网最少使用 20 台主机，应使用的子网掩码是（C）。

    A 255.255.255.128
    B 255.255.255.240
    C 255.255.255.224
    D 255.255.255.192

---

C 类地址前 3 个字节即 24 是网络号，其中需要 5 个子网，至少 3 位；

每个子网 20 个主机，至少 5 位。

因此子网掩码 255.255.255.11100000 即 255.255.255.224，选C。
</t>
<t tx="swot.20250520181051.1">Git Worktree 是 Git 提供的一个强大功能，允许你在同一个仓库中同时检出多个分支，适合多任务开发、测试或部署等场景。

IMPORTANT: 会用于测试多个不同的 nuxt3 功能模块。之前使用了 leo-editor，但是容易出现问题，比如 @file 文件被错误覆盖等等。

[discrete]
==== 添加新的 Worktree

[source,shell]
----
git worktree add &lt;path&gt; &lt;branch&gt;
----

- `&lt;path&gt;`：新的工作目录位置。
- `&lt;branch&gt;`：目标分支。若该分支不存在，可用 `-b` 选项创建。


.新建一个 `feature-xyz` 的工作目录：
[source,shell]
----
git worktree add ../feature-xyz feature-xyz
----

IMPORTANT: 注意这里的 `../` 很重要，即不和当前的代码在同一个目录下，因为会把当前的目录弄乱。


.新建并基于 `origin/main` 分支创建 `feature-xyz` 分支：
[source,shell]
----
git worktree add -b feature-xyz ../feature-xyz origin/main
----

[discrete]
==== 查看所有 Worktree

[source,shell]
----
git worktree list
----

输出示例：
....
/project/main         abcd123 [main]
/project/feature-xyz  def4567 [feature-xyz]
....


[discrete]
==== 移除 Worktree

方式一（自动移除记录并删除目录）：

[source,shell]
----
git worktree remove ../feature-xyz
----

方式二（手动删除后清理记录）：

[source,shell]
----
rm -rf ../feature-xyz
git worktree prune
----

[discrete]
==== 使用场景

.1)并行开发
[source,shell]
----
git worktree add ../docs-update docs
cd ../docs-update
# 修改文档分支，主目录继续开发
----

.2)审核 Pull Request
[source,shell]
----
git worktree add ../review-pr123 pr123
----

.3)构建多个版本
----
git worktree add ../v1.0-release v1.0
git worktree add ../v2.0-release v2.0
----

注意事项

* 每个分支只能同时存在于一个 worktree。
* 所有 worktree 共享主仓库的 `.git` 数据，节省空间。
* 每个 worktree 是独立的工作目录，可以单独执行 `git` 命令。
</t>
<t tx="swot.20250520181057.1">Git Subtree 是 Git 中用于管理子项目的一种机制，它允许你将一个 Git 仓库作为另一个仓库的子目录，并能够独立地同步更新子项目。

IMPORTANT: 用来在一个 leo 文件中管理多个小的项目案例。

[discrete]
==== 添加子项目

将一个外部仓库添加为子项目：

[source,shell]
----
git subtree add --prefix=&lt;子目录路径&gt; &lt;远程仓库地址&gt; &lt;分支名&gt; --squash
----

示例：

[source,shell]
----
git subtree add --prefix=vendor/libfoo https://github.com/example/libfoo.git main --squash
----

[discrete]
==== 提交子项目的更改

将子项目中的更改推送到远程仓库：

[source,shell]
----
git subtree push --prefix=&lt;子目录路径&gt; &lt;远程名称&gt; &lt;分支名&gt;
----

示例：

[source,shell]
----
git subtree push --prefix=vendor/libfoo https://github.com/example/libfoo.git main
----

[discrete]
==== 拉取子项目的更新

从远程仓库拉取子项目的更新并合并到当前项目中：

[source,shell]
----
git subtree pull --prefix=&lt;子目录路径&gt; &lt;远程仓库地址&gt; &lt;分支名&gt; --squash
----

示例：

[source,shell]
----
git subtree pull --prefix=vendor/libfoo https://github.com/example/libfoo.git main --squash
----

.使用 squash 的意义
[TIP]
====
`squash` 选项会将子项目的历史压缩为一次提交，保持主项目历史简洁。
====

[discrete]
==== 子项目也可以单独开发

可以在主项目中开发子项目的代码，然后使用 `git subtree push` 将其推送回原仓库，实现双向同步。
</t>
<t tx="swot.20250520190119.1">https://nuxt.com/docs/getting-started/installation#new-project

Prepare Directory

    mkdir -p nuxt/nuxt3

IMPORTANT: nuxt3-basic 作为最基本的项目目录，后面会使用 `git worktree` 把不同分支的目录放在 nuxt3目录下，它们和 nuxt3-basic 在同级目录下。这样后面再有 nuxt4 的项目，也可以放在 nuxt 目录下，和 nuxt3 目录平行放置。


Create a new nuxt3 project

    cd nuxt/nuxt3
    pnpm create nuxt nuxt3-basic
    # pnpm create nuxt@latest &lt;project-name&gt;


.Install some recommended library
....
&gt; pnpm create nuxt nuxt3-basic

        .d$b.
       i$$A$$L  .d$b
     .$$F` `$$L.$$A$$.
    j$$'    `4$$:` `$$.
   j$$'     .4$:    `$$.
  j$$`     .$$:      `4$L
 :$$:____.d$$:  _____.:$$:
 `4$$$$$$$$P` .i$$$$$$$$P`

ℹ Welcome to Nuxt!                                                                                                                                nuxi 11:13:07 AM
ℹ Creating a new project in nuxt3-basic.                                                                                                          nuxi 11:13:07 AM

✔ Which package manager would you like to use?
pnpm
◐ Installing dependencies...                                                                                                                       nuxi 11:13:09 AM
 WARN  9 deprecated subdependencies found: @types/parse-path@7.1.0, are-we-there-yet@2.0.0, gauge@3.0.2, glob@7.2.3, glob@8.1.0, inflight@1.0.6, node-domexception@1.0.0, npmlog@5.0.1, rimraf@3.0.2
Packages: +763

Progress: resolved 836, reused 757, downloaded 11, added 763, done

&gt; nuxt-app@ postinstall /Users/swot/swot-learning/nuxt/nuxt3/nuxt3-basic
&gt; nuxt prepare

✔ Types generated in .nuxt                                                                                                                        nuxi 11:13:21 AM

dependencies:
+ nuxt 3.17.4
+ vue 3.5.14
+ vue-router 4.5.1

Done in 11.6s
✔ Installation completed.                                                                                                                         nuxi 11:13:21 AM

✔ Initialize git repository?
Yes
ℹ Initializing git repository...                                                                                                                  nuxi 11:13:25 AM

hint: Using 'master' as the name for the initial branch. This default branch name
hint: is subject to change. To configure the initial branch name to use in all
hint: of your new repositories, which will suppress this warning, call:
hint:
hint: 	git config --global init.defaultBranch &lt;name&gt;
hint:
hint: Names commonly chosen instead of 'master' are 'main', 'trunk' and
hint: 'development'. The just-created branch can be renamed via this command:
hint:
hint: 	git branch -m &lt;name&gt;
Initialized empty Git repository in /Users/swot/swot-learning/nuxt/nuxt3/nuxt3-basic/.git/

✔ Would you like to install any of the official modules?
@nuxt/eslint – Project-aware, easy-to-use, extensible and future-proof ESLint integration, @nuxt/fonts – Add custom web fonts with performance in mind, @nuxt/icon –
Icon module for Nuxt with 200,000+ ready to use icons from Iconify, @nuxt/image – Add images with progressive processing, lazy-loading, resizing and providers
support, @nuxt/scripts – Add 3rd-party scripts without sacrificing performance, @nuxt/ui – The Intuitive UI Library powered by Reka UI and Tailwind CSS
ℹ Resolved @nuxt/icon, @nuxt/image, @nuxt/scripts, @nuxt/ui, @nuxt/fonts, @nuxt/eslint, adding modules...                                         nuxi 11:16:40 AM
ℹ Installing @nuxt/icon@1.13.0, @nuxt/image@1.10.0, @nuxt/scripts@0.11.7, @nuxt/ui@3.1.2, @nuxt/fonts@0.11.4, @nuxt/eslint@1.4.1 as dependencies  nuxi 11:16:40 AM
 WARN  9 deprecated subdependencies found: @types/parse-path@7.1.0, are-we-there-yet@2.0.0, gauge@3.0.2, glob@7.2.3, glob@8.1.0, inflight@1.0.6, node-domexception@1.0.0, npmlog@5.0.1, rimraf@3.0.2
Packages: +271
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Progress: resolved 1129, reused 1022, downloaded 3, added 271, done

dependencies:
+ @nuxt/eslint 1.4.1
+ @nuxt/fonts 0.11.4
+ @nuxt/icon 1.13.0
+ @nuxt/image 1.10.0
+ @nuxt/scripts 0.11.7
+ @nuxt/ui 3.1.2

Done in 19.8s
 WARN  9 deprecated subdependencies found: @types/parse-path@7.1.0, are-we-there-yet@2.0.0, gauge@3.0.2, glob@7.2.3, glob@8.1.0, inflight@1.0.6, node-domexception@1.0.0, npmlog@5.0.1, rimraf@3.0.2
Already up to date
Progress: resolved 1129, reused 1025, downloaded 0, added 0, done

dependencies:
+ @unhead/vue ^2.0.3
+ eslint ^9.0.0
+ typescript ^5.6.3

Done in 3s
ℹ Adding @nuxt/icon to the modules                                                                                                                nuxi 11:17:03 AM
ℹ Adding @nuxt/image to the modules                                                                                                               nuxi 11:17:03 AM
ℹ Adding @nuxt/scripts to the modules                                                                                                             nuxi 11:17:03 AM
ℹ Adding @nuxt/ui to the modules                                                                                                                  nuxi 11:17:03 AM
ℹ Adding @nuxt/fonts to the modules                                                                                                               nuxi 11:17:03 AM
ℹ Adding @nuxt/eslint to the modules                                                                                                              nuxi 11:17:03 AM
✔ ESLint config file created at /Users/swot/swot-learning/nuxt/nuxt3/nuxt3-basic/eslint.config.mjs                                                     11:17:05 AM
ℹ If you have .eslintrc or .eslintignore files, you might want to migrate them to the new config file                                                  11:17:05 AM
ℹ Nuxt Icon server bundle mode is set to local                                                                                                         11:17:05 AM
✔ Types generated in nuxt3-basic/.nuxt                                                                                                            nuxi 11:17:08 AM
                                                                                                                                                   nuxi 11:17:08 AM
✨ Nuxt project has been created with the v3 template. Next steps:
 › cd nuxt3-basic                                                                                                                                  nuxi 11:17:08 AM
 › Start development server with pnpm run dev
....
</t>
<t tx="swot.20250521112440.1">这是本来就有的 origin/main 分支。

https://github.com/wangzhaohe/nuxt3-basic.git
</t>
<t tx="swot.20250521144332.1">The Progressive Web Framework

xref:nuxt/nuxt3/nuxt3.adoc[ Read Nuxt3 learning Notes ]

https://nuxt.com/

https://github.com/nuxt/nuxt
</t>
<t tx="swot.20250521145258.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 4
</t>
<t tx="swot.20250521152152.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250521172443.1">. Use leo-editor's swot-learning.leo file to manage outlined knowledge.

. swot-learning.leo is managed by git.

. .gitignore add each project.

. Each project is managed by it's own git.

. Each project use pnpm-workspace.yaml of monorepo.

. Use `git worktree` to manage each project.

</t>
<t tx="swot.20250521181940.1">Add worktree nuxt3-layout

    git worktree add -b nuxt3-layout ../nuxt3-layout origin/main
    git push -u origin nuxt3-layout

https://github.com/wangzhaohe/nuxt3-basic/tree/nuxt3-layout
</t>
<t tx="swot.20250521194811.1">I like pug, so add it.

    pnpm add pug
</t>
<t tx="swot.20250521205725.10">https://element-plus.org/zh-CN/guide/i18n.html#configprovider

ConfigProvider 方式
</t>
<t tx="swot.20250521205725.14"></t>
<t tx="swot.20250521205725.15">@language asciidoc
这是安装命令:

    pnpm i element-plus @element-plus/nuxt -D

在安装完 element-plus 后报错:

.报错提示
....
[Bug Report] [All] Uncaught SyntaxError: The requested module '/_nuxt/node_modules/dayjs/dayjs.min.js?v=391d0c11' does not provide an export named 'default' (at picker2.mjs?v=391d0c11:2:8)
....


在网上查找解决方法为：
https://github.com/element-plus/element-plus/issues/8165

实际解决方法为: pnpm install dayjs
</t>
<t tx="swot.20250521205725.16">@language asciidoc
https://github.com/element-plus/element-plus/issues/18213

```xml
&lt;NuxtLayout&gt;
    &lt;!-- elementUI plus 支持中文 --&gt;
    &lt;el-config-provider :locale="zhCn"&gt;
        &lt;NuxtPage /&gt;
    &lt;/el-config-provider&gt;
&lt;/NuxtLayout&gt;
```

如上面 element-plus 设置中文后，如果在页面(pages/)中再使用组件，则会报警告如下:

&gt; WARN  [Vue warn]: Extraneous non-props attributes (data-v-inspector) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes. 
  at &lt;ElConfigProvider locale= { name: 'zh-cn',
  el:


##解决方法：在 nuxt.config.ts 中临时禁用 componentInspector 功能##

@language javascript
```javascript
export default defineNuxtConfig({
  devtools: {
    enabled: true,
    componentInspector: false
  },
})
```
</t>
<t tx="swot.20250521205725.2">Add worktree nuxt3-element-plus

    git worktree add -b nuxt3-element-plus ../nuxt3-element-plus
    git push -u origin nuxt3-element-plus

[IMPORTANT]
====
一定要注意是从哪个分支创建的，实在不放心就直接指定分支来源吧。
比如从 origin/nuxt3-layout 来创建新的 worktree

    git worktree add -b nuxt3-element-plus ../nuxt3-element-plus origin/nuxt3-layout
====

https://github.com/wangzhaohe/nuxt3-basic/tree/nuxt3-element-plus
</t>
<t tx="swot.20250521205725.3">@language asciidoc
Video: https://www.bilibili.com/video/BV1G14y1z7KF/?spm_id_from=333.337.search-card.all.click&amp;vd_source=392e2829ea8e40de989be86888026747[安装和使用Element Plus组件库] | 
https://www.bilibili.com/video/BV1pd4y1W7eX/?spm_id_from=333.788&amp;vd_source=392e2829ea8e40de989be86888026747[水哥澎湃]

文档: https://nuxt.com/modules/element-plus?[官网详细安装说明]

.安装命令
[source,sql]
----
pnpm i element-plus @element-plus/nuxt -D
----

NOTE: -D 可以作为开发依赖，因为在 build 时会自动收集相关信息
</t>
<t tx="swot.20250522073435.2">Add worktree nuxt3-tailwindcss

    cd nuxt3-basic
    git worktree add -b nuxt3-tailwindcss ../nuxt3-tailwindcss origin/nuxt3-layout
    // 修改之后提交代码
    git push -u origin nuxt3-tailwindcss

https://github.com/wangzhaohe/nuxt3-basic/tree/nuxt3-tailwindcss
</t>
<t tx="swot.20250522073435.3">https://nuxt.com/modules/tailwindcss
目前我没有使用该 @nuxtjs/tailwindcss（集成的是 tailwindcss3），因为 NuxtUI 集成了 tailwindcss4，就不用再单独安装了。

Official Website: https://tailwindcss.com/blog

中文网: https://tailwind.nodejs.cn/docs/installation +
中文网的版本默认是 4.1 2025-05-22 12:50:32

基于 tailwind 开发的 UI https://flowbite.com/ +
感觉很强

基于 tailwind 开发的 UI 特效库 +
https://inspira-ui.com/getting-started/installation +
特别酷

Tailwind CSS Start to Mastery with 18 Project Examples 2024 +
https://www.bilibili.com/video/BV1f2zqYCE84 +
https://github.com/emmanuelbakare/Mastering-Tailwind-CSS-with-Project-Examples +
感觉这个课程挺适合我的，坚持看完了，英语听力长了。
</t>
<t tx="swot.20250522073435.4">vscode install plugin: Tailwind CSS IntelliSense (vscode 的智能提示，需要配置如下)

.在项目的根目录 `.vscode/settings.json` 中添加以下内容
[source,json]
----
{
  "files.associations": {
    "*.css": "tailwindcss"
  },
  "editor.quickSuggestions": {
    "strings": "on"
  },
  "tailwindCSS.classAttributes": ["class", "ui"],
  "tailwindCSS.experimental.classRegex": [
    ["ui:\\s*{([^)]*)\\s*}", "(?:'|\"|`)([^']*)(?:'|\"|`)"]
  ]
}
----

ref: https://ui.nuxt.com/getting-started/installation/nuxt#import-tailwind-css-and-nuxt-ui-in-your-css
</t>
<t tx="swot.20250522125304.1">https://ui.nuxt.com/getting-started/installation/nuxt

使用 NuxtUI 的安装配置就可以了。

</t>
<t tx="swot.20250522172243.1">5分钟、双声道、22.05kHz采样、16位量化的声音，经5:1压缩后，其数字音频的数据量约为（B）。

    A 5.168MB 
    B 5.047MB 
    C 26.460MB 
    D 26.082MB 

---

一、原始音频的数据量计算

给出的音频参数：

* 时长：5 分钟 = 5 × 60 = 300 秒
* 声道数：2（双声道）
* 采样率：22.05 kHz = 22050 次/秒
* 量化位数：16 位
* 压缩比：5:1

公式：原始数据量（位）= 时间（秒）× 采样率 × 量化位数 × 声道数

代入：300 × 22050 × 16 × 2 = 211680000 位

转换为字节（8 位 = 1 字节）：= 211680000 ÷ 8 = 26460000 字节


二、压缩后数据量（压缩比 5:1）

压缩后 = 26460000 ÷ 5 = 5292000 字节


三、换算为 MB

通常使用 1 MB = 1024 × 1024 = 1,048,576 字节：

压缩后大小（MB） = 5292000 ÷ 1048576 ≈ 5.0468 MB ≈ 5.047 MB
</t>
<t tx="swot.20250522173932.1"></t>
<t tx="swot.20250522174032.1">如果“2x”的补码是“90H”，那么x的真值是（B）。

    A 72
    B -56
    C 56
    D 111

---

首先判断符号位（最高位），为 0，表示该数为正数，正数的原码、反码、补码不变；

为1，则该数为负数，负数的补码为其原码的符号位不变，数值部分的按位取反，然后整个数加1。

90H = 1001 0000B，补码为：1001 0000 则原码为 1111 0000，其中最高位代表符号位，1110000 代表数值，即-112，2X=-112，所以 X=-56。

</t>
<t tx="swot.20250522210518.1"></t>
<t tx="swot.20250522210518.2">官网: https://www.iconfont.cn/fonts/detail?cnid=adI1E7HF7yme

1. 字体最好使用 .woff2 字体，很小，加载快。将字体放入 `public/fonts/` 目录下。
+
[source,console]
----
tree public/fonts                                         
public/fonts
├── PuHuiTi-Thin.woff
└── PuHuiTi-Thin.woff2
----
+
.阿里巴巴普惠字体2.0 下载子集是 .woff&amp;.woff2 字体，且下载的只是在 input 框中输入的字
image::img/alibaba_puhui.png[,960]


2. 配置 main.scss 引入字体《阿里巴巴普惠体》

3. 配置 nuxt.config.ts 全局加载 main.scss 文件

</t>
<t tx="swot.20250522210518.6"></t>
<t tx="swot.20250522210521.1">Add worktree nuxt3-font

    cd nuxt3-basic
    git worktree add -b nuxt3-font ../nuxt3-font origin/nuxt3-layout
    // 修改之后提交代码
    git push -u origin nuxt3-font

https://github.com/wangzhaohe/nuxt3-basic/tree/nuxt3-font
</t>
<t tx="swot.20250523083936.1">Add worktree nuxt3-component

    cd nuxt3-basic
    git worktree add -b nuxt3-component ../nuxt3-component origin/nuxt3-tailwindcss
    // 修改之后提交代码
    git push -u origin nuxt3-component

https://github.com/wangzhaohe/nuxt3-basic/tree/nuxt3-component
</t>
<t tx="swot.20250523084009.1"></t>
<t tx="swot.20250523171018.1">有 CookieConsent 的参考页面

. https://www.qlik.com/us/pricing/data-integration-products-pricing
</t>
<t tx="swot.20250524210117.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3</t>
<t tx="swot.20250524210138.1"></t>
<t tx="swot.20250524210146.1">Nuxt 3 中 composables/ 与 utils/ 的区别与用法整理

.概览对比
[cols="1,2,3,4", options="header"]
|===
|目录
|是否自动导入
|推荐用途
|说明

|composables/
|✅ 是
|组合式逻辑（响应式状态）
|封装使用 Vue/Nuxt API 的函数，如 `useFetch`、`ref`、`useState` 等。适合响应式和生命周期相关逻辑。

|utils/
|✅ 是（Nuxt 3.5+）
|通用工具函数
|封装纯函数，不依赖 Vue/Nuxt 上下文。适合处理字符串、日期、数学计算等通用逻辑。
|===

.composables 示例
[source,javascript]
----
export function useUser(userId: string) {
  return useFetch(`/api/users/${userId}`)
}
----

.自动导入使用示例：
[source,javascript]
----
const { data, pending, error } = useUser('abc123')
----

.utils 示例
[source,javascript]
----
export function formatDate(date: Date): string {
  return date.toISOString().split('T')[0]
}
----

.自动导入使用示例（Nuxt 3.5+）：
[source,javascript]
----
const today = formatDate(new Date())
----

.使用场景对比
[cols="1,1", options="header"]
|===
|适合放在 composables/
|适合放在 utils/

|需要响应式状态逻辑：如 `useAuth()`、`useTheme()`、`useXxxFetch()`
|纯函数：如 `formatDate()`、`slugify()`、`trimText()`

|依赖 Vue/Nuxt API，如 `useRoute()`、`useHead()`、`useAsyncData()`
|无任何 Vue/Nuxt 上下文依赖的逻辑

|与组件或页面状态紧密相关
|可在任何 JS 环境中
|===
</t>
<t tx="swot.20250524210230.1">https://nuxt.com/docs/getting-started/configuration#runtimeconfig-vs-appconfig

</t>
<t tx="swot.20250524210625.1"></t>
<t tx="swot.20250524210629.1"></t>
<t tx="swot.20250524213031.1"></t>
<t tx="swot.20250524214956.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250526234255.1">Add worktree nuxt3-sitemap

    cd nuxt3-basic
    git worktree add -b nuxt3-sitemap ../nuxt3-sitemap origin/main
    // 修改之后提交代码
    git push -u origin nuxt3-sitemap

https://github.com/wangzhaohe/nuxt3-basic/tree/nuxt3-sitemap
</t>
<t tx="swot.20250527002101.1">在 Nuxt 中，sitemap.xml 和 sitemap.xsl 文件应该放在 `public/` 目录下。

`public/` 目录用于存放网站的静态资源，这些文件会在根目录下直接提供服务，并且在构建过程中不会被修改。这非常适合那些需要保持原始文件名的文件（如 `robots.txt`）或不太可能更改的文件（如 `favicon.ico`）。

目录结构示例：
```
-| public/
---| favicon.ico
---| sitemap.xml
---| sitemap.xsl
---| robots.txt
```

这些文件将直接在您的网站根目录下可访问，例如：`https://yoursite.com/sitemap.xml`。

[Nuxt 文档 - public 目录](https://nuxt.com/docs/guide/directory-structure/public)

*如果您使用 `@nuxtjs/sitemap` 模块来自动生成站点地图，那么您不需要手动创建这些文件，因为模块会自动生成并放置在正确的位置。*

如果您使用 Nuxt 4 的新目录结构，`public/` 目录仍然是位于项目根目录下，而不是在 `app/` 目录内。
</t>
<t tx="swot.20250527062947.1">@language xsl
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="2.0" 
                xmlns:html="http://www.w3.org/TR/REC-html40"
				xmlns:image="http://www.google.com/schemas/sitemap-image/1.1"
                xmlns:sitemap="http://www.sitemaps.org/schemas/sitemap/0.9"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;
  &lt;xsl:template match="/"&gt;
	&lt;xsl:variable name="fileType"&gt;
	        &lt;xsl:choose&gt;
			  &lt;xsl:when test="//sitemap:url"&gt;Sitemap&lt;/xsl:when&gt;
			  &lt;xsl:otherwise&gt;SitemapIndex&lt;/xsl:otherwise&gt;
	        &lt;/xsl:choose&gt;      
	&lt;/xsl:variable&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;head&gt;
    	&lt;title&gt;
				&lt;xsl:choose&gt;&lt;xsl:when test="$fileType='Sitemap'"&gt;Sitemap&lt;/xsl:when&gt;
				&lt;xsl:otherwise&gt;Sitemap Index&lt;/xsl:otherwise&gt;
				&lt;/xsl:choose&gt;
		&lt;/title&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
    &lt;style type="text/css"&gt;
body {
	font-family: Helvetica, Arial, sans-serif;
	font-size: 68.5%;
}
table {
	border: none;
	border-collapse: collapse;
}
table { font-size:1em; width:75% }
th {  text-align:left; 	padding:5px }
tr.stripe { background-color:#f7f7f7; }
&lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;div id="content"&gt;
    &lt;h1&gt;XML Sitemap&lt;/h1&gt;
    &lt;div&gt;
      &lt;p&gt;&lt;xsl:choose&gt;
				&lt;xsl:when test="$fileType='Sitemap'"&gt;
						  This sitemap contains &lt;xsl:value-of select="count(sitemap:urlset/sitemap:url)"&gt;&lt;/xsl:value-of&gt; URLs&lt;/xsl:when&gt;
					  &lt;xsl:otherwise&gt;This sitemap index contains &lt;xsl:value-of select="count(sitemap:sitemapindex/sitemap:sitemap)"&gt;&lt;/xsl:value-of&gt; sitemaps&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;&lt;/p&gt;
    &lt;/div&gt;
	&lt;xsl:choose&gt;
			&lt;xsl:when test="$fileType='Sitemap'"&gt;
				&lt;xsl:call-template name="sitemapTable"/&gt;&lt;/xsl:when&gt;
		      &lt;xsl:otherwise&gt;&lt;xsl:call-template name="siteindexTable"/&gt;&lt;/xsl:otherwise&gt;
	&lt;/xsl:choose&gt;
    
                  &lt;/div&gt;
    		&lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template name="siteindexTable"&gt;
       &lt;table cellpadding="3"&gt;
						&lt;thead&gt;
							&lt;tr&gt;
								&lt;th width="50%"&gt;URL&lt;/th&gt;
								&lt;th&gt;LastChange&lt;/th&gt;
							&lt;/tr&gt;
						&lt;/thead&gt;
						&lt;tbody&gt;
							&lt;xsl:variable name="lower" select="'abcdefghijklmnopqrstuvwxyz'"/&gt;
							&lt;xsl:variable name="upper" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/&gt;
							&lt;xsl:for-each select="sitemap:sitemapindex/sitemap:sitemap"&gt;
								&lt;tr&gt;
									&lt;xsl:if test="position() mod 2 != 1"&gt;
									&lt;xsl:attribute name="class"&gt;stripe&lt;/xsl:attribute&gt;
									&lt;/xsl:if&gt;
									&lt;td&gt;
										&lt;xsl:variable name="itemURL"&gt;
											&lt;xsl:value-of select="sitemap:loc"/&gt;
										&lt;/xsl:variable&gt;
										&lt;a href="{$itemURL}"&gt;
											&lt;xsl:value-of select="sitemap:loc"/&gt;
										&lt;/a&gt;
									&lt;/td&gt;
									&lt;td&gt;
										&lt;xsl:value-of select="concat(substring(sitemap:lastmod,0,11),concat(' ', substring(sitemap:lastmod,12,5)))"/&gt;
									&lt;/td&gt;
								&lt;/tr&gt;
							&lt;/xsl:for-each&gt;
						&lt;/tbody&gt;
					&lt;/table&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template name="sitemapTable"&gt;
	&lt;table cellpadding="3"&gt;
						&lt;thead&gt;
							&lt;tr&gt;
								&lt;th width="50%"&gt;URL&lt;/th&gt;
								&lt;th&gt;Priority&lt;/th&gt;
								&lt;th&gt;Change Frequency&lt;/th&gt;
								&lt;th&gt;LastChange&lt;/th&gt;
							&lt;/tr&gt;
						&lt;/thead&gt;
						&lt;tbody&gt;
							&lt;xsl:variable name="lower" select="'abcdefghijklmnopqrstuvwxyz'"/&gt;
							&lt;xsl:variable name="upper" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/&gt;
							&lt;xsl:for-each select="sitemap:urlset/sitemap:url"&gt;
								&lt;tr&gt;
									&lt;xsl:if test="position() mod 2 != 1"&gt;
									&lt;xsl:attribute name="class"&gt;stripe&lt;/xsl:attribute&gt;
									&lt;/xsl:if&gt;
									&lt;td&gt;
										&lt;xsl:variable name="itemURL"&gt;
											&lt;xsl:value-of select="sitemap:loc"/&gt;
										&lt;/xsl:variable&gt;
										&lt;a href="{$itemURL}"&gt;
											&lt;xsl:value-of select="sitemap:loc"/&gt;
										&lt;/a&gt;
									&lt;/td&gt;
									&lt;td&gt;
										&lt;xsl:if test="string(number(sitemap:priority))!='NaN'"&gt;
											&lt;xsl:value-of select="concat(sitemap:priority*100,'%')"/&gt;
										&lt;/xsl:if&gt;
									&lt;/td&gt;
									&lt;td&gt;
										&lt;xsl:value-of select="concat(translate(substring(sitemap:changefreq, 1, 1),concat($lower, $upper),concat($upper, $lower)),substring(sitemap:changefreq, 2))"/&gt;
									&lt;/td&gt;
									&lt;td&gt;
										&lt;xsl:value-of select="concat(substring(sitemap:lastmod,0,11),concat(' ', substring(sitemap:lastmod,12,5)))"/&gt;
									&lt;/td&gt;
								&lt;/tr&gt;
							&lt;/xsl:for-each&gt;
						&lt;/tbody&gt;
					&lt;/table&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</t>
<t tx="swot.20250527063027.1">@language asciidoc
V7.3.0 https://nuxtseo.com/docs/sitemap/getting-started/installation

.install
[source,console]
----
pnpm i @nuxtjs/sitemap
----

.vim nuxt.config.ts
[source,javascript]
----
export default defineNuxtConfig({
  modules: [
    '@nuxtjs/sitemap',
  ],
})
----

visit result: http://localhost:3000/sitemap.xml

***

目前是静态的, 动态网站则需使用 sources，参考
https://nuxtseo.com/docs/sitemap/guides/dynamic-urls#_2-create-your-own-endpoint

    sitemap: {
        sources: [
            '/api/__sitemap__/urls',
        ]
    },
</t>
<t tx="swot.20250527111518.1">Add worktree nuxt3-sqlite

    cd nuxt3-basic
    git worktree add -b nuxt3-sqlite ../nuxt3-sqlite origin/main
    // 修改之后提交代码
    git push -u origin nuxt3-sqlite

https://github.com/wangzhaohe/nuxt3-basic/tree/nuxt3-sqlite
</t>
<t tx="swot.20250527112248.1">在 Nuxt3 项目中使用 `Knex.js` 连接 `SQLite` 数据库是完全可行的，尤其适合轻量级项目或本地开发。

    // pnpm add knex sqlite3   sqlite3 需要编译，很麻烦
    pnpm add knex better-sqlite3
</t>
<t tx="swot.20250527171946.1">.执行命令报错 knex migrate:latest
....
Using environment: development
Could not locate the bindings file. Tried:
 → /Users/swot/swot-learning/nuxt/nuxt3/node_modules/.pnpm/better-sqlite3@11.10.0/node_modules/better-sqlite3/build/better_sqlite3.node
 → /Users/swot/swot-learning/nuxt/nuxt3/node_modules/.pnpm/better-sqlite3@11.10.0/node_modules/better-sqlite3/build/Debug/better_sqlite3.node
 → /Users/swot/swot-learning/nuxt/nuxt3/node_modules/.pnpm/better-sqlite3@11.10.0/node_modules/better-sqlite3/build/Release/better_sqlite3.node
 → /Users/swot/swot-learning/nuxt/nuxt3/node_modules/.pnpm/better-sqlite3@11.10.0/node_modules/better-sqlite3/out/Debug/better_sqlite3.node
 → /Users/swot/swot-learning/nuxt/nuxt3/node_modules/.pnpm/better-sqlite3@11.10.0/node_modules/better-sqlite3/Debug/better_sqlite3.node
 → /Users/swot/swot-learning/nuxt/nuxt3/node_modules/.pnpm/better-sqlite3@11.10.0/node_modules/better-sqlite3/out/Release/better_sqlite3.node
 → /Users/swot/swot-learning/nuxt/nuxt3/node_modules/.pnpm/better-sqlite3@11.10.0/node_modules/better-sqlite3/Release/better_sqlite3.node
 → /Users/swot/swot-learning/nuxt/nuxt3/node_modules/.pnpm/better-sqlite3@11.10.0/node_modules/better-sqlite3/build/default/better_sqlite3.node
 → /Users/swot/swot-learning/nuxt/nuxt3/node_modules/.pnpm/better-sqlite3@11.10.0/node_modules/better-sqlite3/compiled/20.12.1/darwin/x64/better_sqlite3.node
 → /Users/swot/swot-learning/nuxt/nuxt3/node_modules/.pnpm/better-sqlite3@11.10.0/node_modules/better-sqlite3/addon-build/release/install-root/better_sqlite3.node
 → /Users/swot/swot-learning/nuxt/nuxt3/node_modules/.pnpm/better-sqlite3@11.10.0/node_modules/better-sqlite3/addon-build/debug/install-root/better_sqlite3.node
 → /Users/swot/swot-learning/nuxt/nuxt3/node_modules/.pnpm/better-sqlite3@11.10.0/node_modules/better-sqlite3/addon-build/default/install-root/better_sqlite3.node
 → /Users/swot/swot-learning/nuxt/nuxt3/node_modules/.pnpm/better-sqlite3@11.10.0/node_modules/better-sqlite3/lib/binding/node-v115-darwin-x64/better_sqlite3.node
....
</t>
<t tx="swot.20250527172139.1">参考来源: https://github.com/WiseLibs/better-sqlite3/issues/146#issuecomment-2813283542

&gt; I had no build folder in node_modules/better-sqlite3. I got it working by going into node_modules/better-sqlite3 and running pnpm run build-release. Now I have a build folder and the error is gone.

所以执行如下命令就好了

    cd node_modules/better-sqlite3
    pnpm run build-release
</t>
<t tx="swot.20250527190016.1">Add worktree nuxt3-slug

    cd nuxt3-sqlite
    git worktree add -b nuxt3-slug ../nuxt3-slug
    // 修改之后提交代码
    git push -u origin nuxt3-slug

https://github.com/wangzhaohe/nuxt3-basic/tree/nuxt3-slug
</t>
<t tx="swot.20250527190349.3">@doc
下面使用 users 表作为 slug 入门例子。

一般情况 users 表中的 username 字段没有空格分隔，因为用户名不允许有空格。

我们只是作为一个 Example 来演示 slug 的使用。
</t>
<t tx="swot.20250527190349.4">@language asciidoc
为前面已经创建的 users 表增加字段 slug

    knex migrate:make add_slug_to_users

迁移字段

    knex migrate:latest

检查状态

    knex migrate:status
</t>
<t tx="swot.20250528071453.1"></t>
<t tx="swot.20250528071457.1">[discrete]
=== Postman Body 数据传递方式总结

在 Postman 中发送请求时，`Body` 部分常用的三种数据格式包括：

[discrete]
==== 1. form-data

- Content-Type: `multipart/form-data`
- 用途：
  * 多用于表单数据提交
  * 支持上传文件
- 数据结构：键值对，每个字段单独处理
- 使用场景：带文件的表单上传（如头像）

[discrete]
==== 2. x-www-form-urlencoded

- Content-Type: `application/x-www-form-urlencoded`
- 用途：
  * 传统 Web 表单提交方式
  * 不支持文件，仅传普通键值对
- 数据结构：`key1=value1&amp;key2=value2` 形式
- 使用场景：简单表单提交，如登录表单

[discrete]
==== 3. raw - JSON

- Content-Type: `application/json`
- 用途：
  * RESTful 接口推荐格式
  * 支持嵌套结构（对象、数组等）
- 数据结构：纯 JSON 格式
- 使用场景：现代前后端分离架构的接口交互

.对比表格
[cols="2,2,1,1,2", options="header"]
|===
| 类型
| Content-Type
| 支持文件
| 支持结构化
| 常见使用场景

| form-data
| multipart/form-data
| 是
| 否
| 表单提交、文件上传

| x-www-form-urlencoded
| application/x-www-form-urlencoded
| 否
| 否
| 登录、注册等传统表单

| raw - JSON
| application/json
| 否
| 是
| 前后端交互的 API 接口
|===

</t>
<t tx="swot.20250528073829.1">[discrete]
==== 1. multipart/form-data 上传文件（form-data）

[source,shell]
----
http --form POST https://example.com/upload name=ChatGPT file@./image.png
----

说明：

- 使用 `-f --form` 参数
    * 如果传入了文件就是 `multipart/form-data`
    * 否则是 application/x-www-form-urlencoded
- 使用 `--multipart` 参数则始终是 `multipart/form-data`
- `name=ChatGPT` 是普通字段
- `file@./image.png` 表示上传文件

.自动设置的请求头：
[source,text]
----
Content-Type: multipart/form-data; boundary=...
----

常用于表单上传或文件上传接口。

[discrete]
==== 2. application/x-www-form-urlencoded 提交表单数据

.使用 -f 或 --form
[source,shell]
----
http --form POST https://example.com/login username=admin password=123456
----

说明：

- 使用 `--form` 参数启用 `x-www-form-urlencoded`
- 所有字段以 `key=value` 格式发送

.自动设置的请求头：
[source,text]
----
Content-Type: application/x-www-form-urlencoded
----

适用于传统 Web 表单提交（如登录、注册等）。

[discrete]
==== 3. application/json 提交 JSON 数据

默认情况下，不加 `-f` 或 `--form`，HTTPie 自动使用 JSON：

[source,shell]
----
http POST https://example.com/api name=ChatGPT role=assistant
----

.也可以显式指定请求头：
[source,shell]
----
http POST https://example.com/api Content-Type:application/json name=ChatGPT role=assistant
----

发送的数据将被自动序列化为 JSON：

[source,json]
----
{
  "name": "ChatGPT",
  "role": "assistant"
}
----

.自动设置的请求头：
[source,text]
----
Content-Type: application/json
----

适用于现代前后端分离的 API 接口。

[discrete]
==== 三种格式对比表

[cols="1,2,1", options="header"]
|===
| 格式
| 示例命令
| Content-Type

| form-data
| `http --form POST URL key=value file@file`
| multipart/form-data

| x-www-form-urlencoded
| `http --form POST URL key=value`
| application/x-www-form-urlencoded

| JSON
| `http POST URL key=value`
| application/json
|===
</t>
<t tx="swot.20250528074031.1">可以使用 `--print` 参数来控制 HTTPie 显示请求和响应的哪些部分。

[discrete]
==== 显示请求和响应的全部内容

```bash
http --print=HBhb POST https://example.com/api name=ChatGPT
```

说明：

* `H`：请求头（Request headers）
* `B`：请求体（Request body）
* `h`：响应头（Response headers）
* `b`：响应体（Response body）

[discrete]
==== 只查看发送的请求（不显示响应）

```bash
http --print=HB POST https://example.com/api name=ChatGPT
```

这将显示：

* 请求头
* 请求体

不会显示响应部分。

[discrete]
==== 示例输出（请求部分）

```text
POST /api HTTP/1.1
Accept: application/json, */*
Content-Type: application/json
User-Agent: HTTPie/3.0.0

{
    "name": "ChatGPT"
}
```

[discrete]
==== 仅调试请求而不发送

使用 `--offline` 模拟请求但不发送，可用于本地调试：

```bash
http --offline --print=HB POST https://example.com/api name=ChatGPT
```

[discrete]
==== 快捷选项

* `--verbose` 或 `-v` 相当于 `--print=HhBb`，即显示完整请求和响应内容。
</t>
<t tx="swot.20250528090941.1">Add worktree nuxt3-server

    cd nuxt3-basic
    git worktree add -b nuxt3-server ../nuxt3-server origin/main
    // 修改之后提交代码
    git push -u origin nuxt3-server

https://github.com/wangzhaohe/nuxt3-basic/tree/nuxt3-server
</t>
<t tx="swot.20250528091411.1"></t>
<t tx="swot.20250528091441.1"></t>
<t tx="swot.20250528091447.1"></t>
<t tx="swot.20250528091447.2"></t>
<t tx="swot.20250528113307.1">[source,shell]
----
http -f -v post :3000/api/handle_urlencoded_and_json username=river password=123
----

.result
....
POST /api/handle-form-data HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: 27
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Host: localhost:3000
User-Agent: HTTPie/3.2.4

username=river&amp;password=123


HTTP/1.1 200 OK
connection: close
content-length: 66
content-type: application/json
date: Wed, 28 May 2025 03:26:47 GMT

{
    "body": {
        "password": "123",
        "username": "river"
    }
}
....
</t>
<t tx="swot.20250528113321.1">[source,shell]
----
http -j -v post :3000/api/handle-form-data username=river password=123
----

.result
....
POST /api/handle-form-data HTTP/1.1
Accept: application/json, */*;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: 40
Content-Type: application/json
Host: localhost:3000
User-Agent: HTTPie/3.2.4

{
    "password": "123",
    "username": "river"
}


HTTP/1.1 200 OK
connection: close
content-length: 66
content-type: application/json
date: Wed, 28 May 2025 03:27:21 GMT

{
    "body": {
        "password": "123",
        "username": "river"
    }
}
....
</t>
<t tx="swot.20250528113332.1">[source,shell]
----
http --multipart -v post :3000/api/handle-multipart username=river password=123
----

.result
....
POST /api/handle-multipart HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: 224
Content-Type: multipart/form-data; boundary=7ef282699c7e40a2a3f655aaa6193e47
Host: localhost:3000
User-Agent: HTTPie/3.2.4

--7ef282699c7e40a2a3f655aaa6193e47
Content-Disposition: form-data; name="username"

river
--7ef282699c7e40a2a3f655aaa6193e47
Content-Disposition: form-data; name="password"

123
--7ef282699c7e40a2a3f655aaa6193e47--


HTTP/1.1 200 OK
connection: close
content-length: 146
content-type: application/json
date: Wed, 28 May 2025 07:08:22 GMT

{
    "fields": {
        "password": [
            "123"
        ],
        "username": [
            "river"
        ]
    },
    "files": {},
    "message": "Form data received"
}
....
</t>
<t tx="swot.20250528145724.1">[source,shell]
----
http --multipart -v post :3000/api/handle-multipart username=river password=123 file@./test_upload.txt
----

.result
....
POST /api/handle-multipart HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: 395
Content-Type: multipart/form-data; boundary=453dbf53b9a5414ba08d0c57b1a52d78
Host: localhost:3000
User-Agent: HTTPie/3.2.4

--453dbf53b9a5414ba08d0c57b1a52d78
Content-Disposition: form-data; name="username"

river
--453dbf53b9a5414ba08d0c57b1a52d78
Content-Disposition: form-data; name="password"

123
--453dbf53b9a5414ba08d0c57b1a52d78
Content-Disposition: form-data; name="file"; filename="test_upload.txt"
Content-Type: text/plain

This is a test file for upload!

--453dbf53b9a5414ba08d0c57b1a52d78--


HTTP/1.1 200 OK
connection: close
content-length: 480
content-type: application/json
date: Wed, 28 May 2025 07:04:59 GMT

{
    "fields": {
        "password": [
            "123"
        ],
        "username": [
            "river"
        ]
    },
    "files": {
        "file": [
            {
                "filepath": "/var/folders/nz/bqt3s78s1nd_k0hmpmgd9_f00000gn/T/h7476dt8uw5kttjthus40s7os",
                "mimetype": "text/plain",
                "mtime": "2025-05-28T07:04:59.449Z",
                "newFilename": "h7476dt8uw5kttjthus40s7os",
                "originalFilename": "test_upload.txt",
                "size": 32
            }
        ]
    },
    "message": "Form data received"
}
....
</t>
<t tx="swot.20250528150736.1">[source,shell]
----
http --multipart -v post :3000/api/handle_urlencoded_and_json username=river password=123
----

.result
....
POST /api/handle_urlencoded_and_json HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: 224
Content-Type: multipart/form-data; boundary=f6caf4c14ac94cf4a06e25bb0cde98da
Host: localhost:3000
User-Agent: HTTPie/3.2.4

--f6caf4c14ac94cf4a06e25bb0cde98da
Content-Disposition: form-data; name="username"

river
--f6caf4c14ac94cf4a06e25bb0cde98da
Content-Disposition: form-data; name="password"

123
--f6caf4c14ac94cf4a06e25bb0cde98da--


HTTP/1.1 200 OK
connection: close
content-length: 262
content-type: application/json
date: Wed, 28 May 2025 07:13:23 GMT

{
    "body": "--f6caf4c14ac94cf4a06e25bb0cde98da\r\nContent-Disposition: form-data; name=\"username\"\r\n\r\nriver\r\n--f6caf4c14ac94cf4a06e25bb0cde98da\r\nContent-Disposition: form-data; name=\"password\"\r\n\r\n123\r\n--f6caf4c14ac94cf4a06e25bb0cde98da--\r\n"
}
....
</t>
<t tx="swot.20250528151437.1"></t>
<t tx="swot.20250528153849.1">模板使用了 pug 格式，优点是不用再写结束标签了。以缩进作为层级，类似于 python 语言。

https://pugjs.org/api/getting-started.html

安装 pug

    pnpm add -D pug
</t>
<t tx="swot.20250528182428.1">Add worktree nuxt3-i18n

    cd nuxt3-basic
    git worktree add -b nuxt3-i18n ../nuxt3-i18n origin/nuxt3-layout
    // 修改之后提交代码
    git push -u origin nuxt3-i18n

https://github.com/wangzhaohe/nuxt3-basic/tree/nuxt3-i18n

Install i18n

    cd nuxt3-i18n
    pnpm add @nuxtjs/i18n
</t>
<t tx="swot.20250528215755.1">原始文档: https://casl.js.org/v6/en/cookbook/roles-with-persisted-permissions

原始代码: https://github.com/stalniy/casl-persisted-permissions-example

TIP: github 例子好久没有更新了，自己更新了一下。

* 后端的 RBAC(Role based access control) 实现，不同角色的多用户登录后使用。

* 在这篇文章中，使用 knex 操作数据库，很棒的库！
</t>
<t tx="swot.20250528215755.2">[source,console]
----
// 安装包
pnpm i

// 查看迁移状态
pnpm run migration.status
    or
knex migrate:status
----

.result
....
Using environment: development
Found 2 Completed Migration file/files.
20250527164201_create_users_table.js
20250527190502_add_slug_to_users.js
Found 4 Pending Migration file/files.
20250528222910_create_roles_table.js
20250528222920_change_users_table.js
20250528222930_create_articles_table.js
20250528222940_add_status_to_users.js
....

NOTE: 有未迁移的文件，执行 `pnpm run migrate` 即可

[source,console]
----
// 生成迁移文件: 注意新版本 knex 生成 ES6 语法代码，与现在的例子一样了
pnpm run migration.new your-table-name
    or
knex migrate:make your-table-name

// 生成数据库表
pnpm run migrate
    or
knex migrate:latest

// 生成种子文件、生成数据库表数据
pnpm run seed.new
    or
knex seed:make

pnpm run seed
    or
knex seed:run

// 执行程序
pnpm run start
    or
ts-node src/run.ts
----

////
// 在从之前的例子中移过来后，没有写下面的两个文件，不能这么测试。
// 允许普通用户创建管理员级别的文章
pnpm run allowMembersToCreateAnyArticle
    or
ts-node src/updateMemberRole.ts

// 运行验证一下
pnpm run start
    or
ts-node src/run.ts
////
</t>
<t tx="swot.20250528215800.1">Add worktree nuxt3-casl

    cd nuxt3-slug
    git worktree add -b nuxt3-casl ../nuxt3-casl origin/nuxt3-slug
    // 修改之后提交代码
    git push -u origin nuxt3-casl

https://github.com/wangzhaohe/nuxt3-basic/tree/nuxt3-casl

Install casl

    cd nuxt3-casl
    pnpm add @casl/ability
</t>
<t tx="swot.20250529072113.1">@language json
{
  "name": "nuxt-app",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare",
    "migration.status": "knex migrate:status",
    "migration.new": "knex migrate:make",
    "migrate": "knex migrate:latest",
    "seed.new": "knex seed:make",
    "seed": "knex seed:run",
    "start": "ts-node src/run.ts",
    "allowMembersToCreateAnyArticle": "ts-node src/updateMemberRole.ts"
  },
  "dependencies": {
    "@casl/ability": "^6.7.3",
    "@nuxt/eslint": "1.4.1",
    "@nuxt/fonts": "0.11.4",
    "@nuxt/icon": "1.13.0",
    "@nuxt/image": "1.10.0",
    "@nuxt/scripts": "0.11.7",
    "@nuxt/ui": "3.1.2",
    "@unhead/vue": "^2.0.3",
    "bcryptjs": "^3.0.2",
    "better-sqlite3": "^11.10.0",
    "eslint": "^9.0.0",
    "jsonwebtoken": "^9.0.2",
    "knex": "^3.1.0",
    "nuxt": "^3.17.3",
    "pug": "^3.0.3",
    "typescript": "^5.6.3",
    "vue": "^3.5.14",
    "vue-router": "^4.5.1"
  },
  "devDependencies": {
    "eslint-plugin-vue": "^10.1.0"
  }
}
</t>
<t tx="swot.20250530111037.1">@language asciidoc
[plantuml, target=img/diagram-2025-05-30-233449, format=svg]
....
@startuml
skinparam componentStyle rectangle

database "sqlite3" {
  frame "roles" {
    [permissions]
  }
}

actor Browser

package "shared" {
    [utils/appAbility.ts]
}

package "Frontend (Nuxt3)" {
  package "pages" {
    [login.vue]
    note left of [login.vue]
      const form = reactive({
        username: "wzh",
        password: "123",
      });
    end note
    [index.vue]
  }
  package "composables" {
    [stores.ts]
    [clientFetch.ts]
  }
  package "middleware" {
    [auth-middleware]
  }
}

package "Backend (Server API)" {
    package "api" {
      [login.post.ts]
      [users/index.post.ts]
    }
    package "utils" {
      [agordo.ts]
      [permissions.ts]
    }
    [middleware/auth.ts]
}

Browser --&gt; [auth-middleware] : submit \n login form
[auth-middleware] --&gt; [login.vue]: 无 token 重定向
[auth-middleware] --&gt; [index.vue]: 有 token 重定向
[login.vue] --&gt; [stores.ts] : authenticateUser(form)

[clientFetch.ts] --&gt; [stores.ts] : { token } =\n useAuthStore()
[stores.ts] --&gt; [clientFetch.ts] : clientFetch()
[clientFetch.ts] --&gt; [middleware/auth.ts]

[middleware/auth.ts] ..&gt; [agordo.ts]: need_token?
[middleware/auth.ts] --&gt; [login.post.ts] : need_token\nfalse
[middleware/auth.ts] --&gt; [users/index.post.ts] : need_token true \n ability
[stores.ts] ..&gt; Browser : auto \n persist save
[stores.ts] &lt;.. Browser : auto \n persist read

[users/index.post.ts] ..&gt; [permissions.ts] : checkPermission\n(ability,action,subject)
[middleware/auth.ts] ..&gt; [permissions] : user.permissions
[middleware/auth.ts] ..&gt; [utils/appAbility.ts] : createAbility
@enduml
....
</t>
<t tx="swot.20250530202228.1"></t>
<t tx="swot.20250530202305.1"></t>
<t tx="swot.20250530202535.1"></t>
<t tx="swot.20250530202614.1"></t>
<t tx="swot.20250530202630.1"></t>
<t tx="swot.20250530224614.1"></t>
<t tx="swot.20250602081407.1">https://mycolor.space/
这个配色网站很棒，还支持 3-color-gradient
</t>
<t tx="swot.20250604113830.1">css汇总： https://github.com/dbohdan/classless-css

Pico.css 好不好？

* https://github.com/picocss/pico
* https://picocss.com/


</t>
<t tx="swot.20250604115240.1">1. Svelte: 不用虚拟 dom，比 react 更好写。

2. Web Component: 代表有 Lit。

3. htmx: 原始风
</t>
<t tx="swot.20250609210130.1">Leo Editor 的 Nav（“Nav” 标签页）搜索功能是支持正则表达式的，不过需要借助 leo's QuickSearch 插件，你需要确保已加载此插件。

以下是详情：

1. 确保在 Leo &gt; Plugins 配置中已启用 quicksearch.py 插件。

2. 切换到 Nav 标签页（通常在 Log 窗口）。

3. 输入搜索内容：

* 普通搜索：例如 todo* 使用通配符；
* 正则搜索：例如 r:^def\s+\w+ 查找以 def 开头的函数定义；
* 不区分大小写：使用 r:(?i)pattern。

回车执行搜索
</t>
<t tx="swot.20250613103138.1"></t>
<t tx="swot.20250613103144.1">macOS: Cmd + Option + J 直接打开到 Console 面板

Windows/Linux: Ctrl + Shift + J 直接打开到 Console 面板
</t>
<t tx="swot.20250715075203.1">@language asciidoc
需求如下：

没有路由权限的用户**不能访问该路由**，要么直接不跳转，要么自动跳转到别的页面（比如 403/首页/登录页）。

**最佳实践**  

在 Nuxt3 + CASL 场景下，推荐用“路由守卫”或“中间件”来做权限拦截，而不是只靠页面内容隐藏。
</t>
<t tx="swot.20250715075655.1">1. **在页面 meta 里声明权限需求**: +
   在 `app/pages/users/index.vue` 里加：
+
```ts
definePageMeta({
   title: '用户',
   requiredAbility: { action: 'read', subject: 'users' }
})
```

2. **在全局中间件里做拦截**: +
   修改 `app/middleware/auth-middleware.global.ts`，大致如下（伪代码，需根据你的实际 $ability 获取方式调整）：
+
```ts
export default defineNuxtRouteMiddleware((to, from) =&gt; {
   const nuxtApp = useNuxtApp();
   const ability = nuxtApp.$ability; // 你插件里 provide 的

   // 读取页面 meta 里的 requiredAbility
   const required = to.meta.requiredAbility;
   if (required &amp;&amp; !ability.can(required.action, required.subject)) {
       // 没权限，重定向到 403 或首页
       return navigateTo('/403'); // 或 '/login' 或 '/'
   }
});
```

3. **新建 403 页面（可选）** +
新建 `app/pages/403.vue`，内容随意。
</t>
<t tx="swot.20250715075712.1">如果是通过按钮/菜单跳转，可以在跳转前判断权限，不让跳转：

```ts
const nuxtApp = useNuxtApp();

if (nuxtApp.$ability.can('read', 'users')) {
    navigateTo('/users');
} else {
    ElMessage.error('无权限访问');
}
```

NOTE: 但这种方式只能防止“主动点击”，不能防止用户手动输入 URL。
</t>
<t tx="swot.20250715075722.1">
- 菜单|按钮 不显示无权限项（你已经做了）。需要把例子放过来。

- 路由中间件兜底，防止用户手动输入 URL。
</t>
<t tx="swot.20250715075745.1">- **只用 `&lt;Can&gt;` 隐藏内容体验不好，建议用 Nuxt3 中间件做路由级权限拦截。**

- 推荐在页面 meta 里声明权限需求，在全局中间件里统一判断。

- 没权限时自动跳转到 403 或首页，用户体验更好。
</t>
<t tx="swot.20250721131040.1"></t>
<t tx="swot.20250721131113.1">输入 if 选择 vIf 可以生成条件语句

输入 for 选择 vFor 可以生成循环语句
</t>
<t tx="swot.20250721131156.1">输入 vbase-3-set... Vue Single File Component，可以生成 Vue3 模板。
</t>
<t tx="swot.20250811154633.1"></t>
<t tx="swot.20250811160652.1">PBR 是 Physically-Based Rendering 的缩写，中文通常翻译为“基于物理的渲染”。

材质资源网站 https://freepbr.com/pbr-tutorials-resources/

这个网站（freepbr.com）是一个专门提供免费PBR（Physically-Based Rendering，基于物理的渲染）材质资源的平台。

商业用途需要支付一点点儿授权费用（16$ 2025-08-12 09:05:38）
</t>
<t tx="swot.20250812084836.1">1. **MeshBasicMaterial**
- **光照响应**：**不响应任何光照**（没有阴影、没有高光）。
- **用途**：用于简单着色、贴图，或调试。
- **性能**：**最快**。
- **示例**：纯色物体、UI 元素、背景。

2. **MeshLambertMaterial**
- **光照响应**：支持 **漫反射（Diffuse）**，但 **不支持镜面反射**（无高光）。
- **特点**：适合 **哑光材质**，如纸张、墙壁。
- **性能**：中等，比 Basic 慢，比 Phong 快。
- **限制**：不支持镜面高光（specular highlights）。

3. **MeshPhongMaterial**
- **光照响应**：支持 **漫反射 + 镜面反射（高光）**。
- **特点**：适合 **有光泽的物体**，如塑料、金属。
- **性能**：比 Lambert 慢，但效果更真实。
- **高光控制**：可以通过 `shininess` 调整高光强度。

4. **MeshStandardMaterial**
- **光照响应**：使用 **PBR（基于物理的渲染）**。
- **特点**：更真实，支持 **金属度（metalness）** 和 **粗糙度（roughness）**。
- **性能**：比 Phong 慢，但效果更现代。
- **用途**：现代 3D 应用、游戏、产品展示。

5. **MeshPhysicalMaterial**
- **光照响应**：是 **MeshStandardMaterial 的扩展**。
- **额外特性**：
  - **清漆层（clearcoat）**：模拟汽车漆、清漆。
  - **透射（transmission）**：模拟玻璃、水。
  - **更复杂的反射模型**。
- **性能**：**最慢**，但效果最逼真。
- **用途**：高端渲染、汽车、玻璃、液体等。

---

[caption=]
.总结对比表：
[cols="2,1,1,1,1,1",options="header"]
|===
| 材质类型 | 光照模型 | 高光  | 金属/粗糙度 | 性能  | 典型用途
| MeshBasicMaterial | 无   | ❌   | ❌   | 快   | 纯色、UI、背景
| MeshLambertMaterial | Lambert | ❌   | ❌   | 中   | 哑光表面（墙、纸）
| MeshPhongMaterial | Phong | ✅   | ❌   | 中   | 塑料、低光泽金属
| MeshStandardMaterial | PBR | ✅   | ✅   | 慢   | 现代材质、游戏
| MeshPhysicalMaterial | 高级 PBR | ✅   | ✅ + 扩展 | 最慢  | 高端渲染、玻璃、车漆
|===

简单记忆法：

- **Basic**：无光照，最快。
- **Lambert**：哑光，无高光。
- **Phong**：有高光，像塑料。
- **Standard**：PBR，现代标准。
- **Physical**：PBR+，最逼真。
</t>
<t tx="swot.20250812085446.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3</t>
<t tx="swot.20250812085536.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250812113455.1"></t>
<t tx="swot.20250812113515.1"></t>
<t tx="swot.20250812113624.1">问：用 200 字以内文字，说明建模时如何保持数据流图平衡？

答：

1. 父图中加工的输入输出数据流必须与子图中的输入输出数据流在数量上和名字上相同；
2. 父图中的一个输入（输出）数据流对应子图中的几个输入（输出）数据流；
3. 而子图中组成这些数据流的数据项全体正好是父图中的这一条数据流。
</t>
<t tx="swot.20250812210640.1"></t>
<t tx="swot.20250831095539.1">@language asciidoc
如果在 arm64 的 MacOS 下不能运行 leo-editor，可以试试下面的方法。

怎么样在 M1|M2 Mac终端中快速切换 arm64 或 x86 架构
https://aibi8.com/news/3140.html

在 M1|M2|M3 Mac上，可以使用 arch 命令在终端中快速切换架构。

要从 ARM64 切换到 x86 架构，请在终端中输入以下命令：

    arch -x86_64 zsh

此命令将在当前终端会话中切换到 x86_64 架构，以便可以在 M1|M2|M3 MacOS 上运行只适用于 x86 架构的应用程序。

要从 x86 切换回 ARM64 架构，请在终端中输入以下命令：

    arch -arm64 zsh

这将在当前终端会话中切换回 ARM64 架构。请注意，只有 M1|M2|M# MacOS 支持 ARM64 架构。

</t>
<t tx="swot.20250831100251.1">The following is from LeoDocs.leo. Selecting some text with mouse or keyboard arrow key, then between the first cursor and the end cursor is the columns that being selected.

------

.. _`Emacs rectangle commands`: http://www.gnu.org/software/emacs/manual/html_node/emacs/Rectangles.html

The following commands emulate the `Emacs rectangle commands`_::

```
rectangle-clear
rectangle-delete

rectangle-open
rectangle-close

rectangle-kill
rectangle-yank

rectangle-string
```

Given::

```
I'm really glad the docs are being updated. I know that's a
monumental task. I only use a fraction of Leo's commands, mostly
because I don't even know what they're supposed to accomplish. A few
examples:
```

Placing the cursor immediately before the first "I", holding shift and moving it to immediately before the word`examples` selects a zero width rectangle from the beginning to the end of the selection (zero width because the selection starts and ends in the same column. Then running `rectangle-string [largo]&lt;space&gt;&lt;enter&gt;` yields::

....
[largo] I'm really glad the docs are being updated. I know that's a
[largo] monumental task. I only use a fraction of Leo's commands, mostly
[largo] because I don't even know what they're supposed to accomplish. A few
[largo] examples:
....
</t>
<t tx="swot.20250906075341.1"></t>
<t tx="swot.20250906075354.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3</t>
<t tx="swot.20250906075409.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250906075427.1">@language asciidoc
* Linux Install docker
+
https://docs.docker.com/engine/install/


* Windows &amp; Macos Install docker
+
https://www.docker.com/get-started/
+
image::img/dockerdesktop_install.png[]

</t>
<t tx="swot.20250906082625.1">@language asciidoc
Docker 是一个“**一次打包、随处运行**”的轻量级容器引擎，它把应用和依赖打成一个镜像，秒级启动、隔离运行，解决“我机器上能跑，别人机器上不能跑”的环境不一致问题。

</t>
<t tx="swot.20250906084634.1">@language asciidoc
.docker_pull_redis
image::img/docker_pull_redis.png[]

.docker_run_redis
image::img/docker_run_redis.png[]

.docker_run_port
image::img/docker_run_port.png[,600]

.docker_container_redis
image::img/docker_container_redis.png[]

.docker_container_redis_exec
image::img/docker_container_redis_exec.png[]

NOTE: save 落盘只是为了给学生发送已经有数据的容器打包。

在宿主机测试连接到 redis 服务器::
redis-cli

</t>
<t tx="swot.20250906093952.1">@language asciidoc
1. 把正在跑的容器打成镜像

    docker commit redis_8 redis_8-with-data:2025

2. 导出为单个 tar 文件（几百 MB 到几 GB 不等）

    docker save -o redis_8-with-data.tar redis_8-with-data:2025

3. 学生导入镜像

    docker load -i redis_8-with-data.tar

4. 直接运行（端口、卷都不用再配）

    docker run -d --name my-redis -p 6379:6379 redis_8-with-data:2025


[NOTE]
====
1. 镜像文件较大，可先用 gzip redis-with-data.tar 压缩再传。压缩后的文件大小，要看镜像内容的实际情况。
2. 如果数据还在内存、没触发过 SAVE/BGSAVE，先手动执行一次 SAVE，再 commit，否则镜像里可能没数据。
====
</t>
<t tx="swot.20250906101555.1"></t>
<t tx="swot.20250906102110.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032352d30382d33317103752e">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3</t>
<t tx="swot.20250906102110.10">@language asciidoc
.验证码
[source,redis]
----
&gt; SET mobile:code:13800138000 123456 NX EX 300
OK
----
**解释**  
`SET` 是“存值”；`NX`（Not eXists）只有当手机号没验证码时才成功，**用来做分布式锁或防重复发送**；`EX 300` 让它 300 秒后自动消失，**省得手删**。

[source,redis]
----
&gt; GET mobile:code:13800138000
"123456"
----
**解释**  
`GET` 把刚才的值拿回来，双引号说明它是字符串。300s 后就没值了。


.统计 PV/点赞数
[source,redis]
----
&gt; INCR api:count
(integer) 1
&gt; INCR api:count
(integer) 2
----
**解释**  
`INCR` 把值当成“数字”原子地加 1，**多人同时调用也不会算错**，常用来统计 PV/点赞数。


.设置多值
[source,redis]
----
&gt; MSET user:1:name Lucy user:1:age 22
OK
&gt; MGET user:1:name user:1:age
1) "Lucy"
2) "22"
----
**解释**  
`MSET` / `MGET` 一次存/取多个键，**减少网络往返**，省流量也更快。


.追加内容
[source,redis]
----
&gt; APPEND user:1:name " (VIP)"
(integer) 10
&gt; GET user:1:name
"Lucy (VIP)"
----
**解释**  
`APPEND` 把字符串直接拼在后面，**返回的是新长度** 10 -&gt; Lucy 4 + 空格1 + (VIP)5
</t>
<t tx="swot.20250906102110.11">@language asciidoc

[source,redis]
----
HSET product:1001 name "iPhone15" price 7999 stock 100
(integer) 3
----
**解释**  
`HSET` 一次存 3 个“字段-值”到 `product:1001` 这个 Hash 表里，**比存 JSON 字符串更省内存且可单独改字段**。

[source,redis]
----
HGET product:1001 price
"7999"
----
**解释**  
`HGET` 只拿价格字段，**不用把整个对象取出来再解析**。

[source,redis]
----
HINCRBY product:1001 stock -1
(integer) 99
----
**解释**  
原子地把库存减 1，**返回剩余库存**。高并发下也不会出现“超卖”。

[source,redis]
----
HGETALL product:1001
1) "name"
2) "iPhone15"
3) "price"
4) "7999"
5) "stock"
6) "99"
----
**解释**  
`HGETALL` 把整张 Hash 一次性拉回，**顺序是“字段 值 字段 值 …”**。

[source,redis]
----
HMSET product:1002 name "AirPods" price 1299
OK
----
**解释**  
`HMSET` 一次存多个字段，**和 HSET 功能一样**（Redis 4+ 已合并，但老代码常见）。
</t>
<t tx="swot.20250906102110.12">.查看 List 内容（不弹出）
[source,redis]
----
LRANGE tasks 0 -1
(empty array)
----
* 0 -1 表示查看整个列表
* 0 2 表示前 3 个元素


.查看 List 两端元素（不弹出）
[source,redis]
----
LINDEX mylist 0      # 查看第一个元素
LINDEX mylist -1     # 查看最后一个元素
----


.LPUSH 从“左侧”塞进两条任务，**像栈一样后进先出**。
[source,redis]
----
LPUSH tasks email-job sms-job
(integer) 2
----

.RPUSH 从“右侧”追加，**形成“左进右出”就是队列**。
[source,redis]
----
RPUSH tasks push-job
(integer) 3
----

.LLEN 看当前队列长度，**常用来做监控报警**。
[source,redis]
----
LLEN tasks
(integer) 3
----

.LPOP 把最左边的任务弹出来，**FIFO 队列的消费者就这么写**
[source,redis]
----
LPOP tasks
"sms-job"
----

.BRPOP 阻塞地等 5 秒，**有数据就立即弹出，没数据就空等**；
[source,redis]
----
BRPOP tasks 5
1) "tasks"   // &lt;1&gt;
2) "push-job"
----

&lt;1&gt; 返回值先给队列名再给元素，**用来实现“简单消息队列”**。
+
* 如果 5 秒内 tasks 列表有元素，就立即返回并弹出最左边的一个；
* 超时返回 nil。
</t>
<t tx="swot.20250906102110.13">@language asciidoc
.SADD 往集合里加用户 ID，**重复元素自动忽略**，所以只增加了 2 个。
[source,redis]
----
SADD lucky:u1001 u123 u456 u123
(integer) 2
----


.SMEMBERS 列出所有成员，**无序**。
[source,redis]
----
SMEMBERS lucky:u1001
1) "u123"
2) "u456"
----

.SCARD 返回集合大小，**用来告诉你“已报名人数”**。
[source,redis]
----
SCARD lucky:u1001
(integer) 2
----

.SPOP 随机弹 1 个，**做抽奖最方便**：谁被弹出谁中奖。
[source,redis]
----
SPOP lucky:u1001
"u456"
----
</t>
<t tx="swot.20250906102110.14">@language asciidoc
.ZADD 把“分数 成员”成对写进去，**分数可重复，成员唯一**。
[source,redis]
----
ZADD rank:score 100 user:1 90 user:2 100 user:3
(integer) 3
----


.按“分数值升序”取前 3 名，`WITHSCORES` 把分数一起带出来，**排行榜页面直接渲染**。
[source,redis]
----
127.0.0.1:6379&gt; ZRANGE rank:score 0 2 WITHSCORES
1) "user:2"
2) "90"
3) "user:1"
4) "100"
5) "user:3"
6) "100"

127.0.0.1:6379&gt; ZREVRANGE rank:score 0 2 WITHSCORES
1) "user:3"
2) "100"
3) "user:1"
4) "100"
5) "user:2"
6) "90"
----
* ZRANGE 先按分数正排，分数相同再按成员名升序排。
* ZREVRANGE 把整条链表整体翻转再输出（不会再对 user:x 字典序二次排序）。


.ZINCRBY 给 user:2 加 5 分，**返回新分数 95**，原子操作不怕并发。
[source,redis]
----
ZINCRBY rank:score 5 user:2
"95"
----


.ZRANK 按“分数从低→高”排名，取单个成员，**返回下标从 0 开始**；若要高分在前用 `ZREVRANK`。
[source,redis]
----
ZRANK rank:score user:2
(integer) 0
----


.把“最低分段”的那 1 个人踢掉，**清理垫底用户**。
[source,redis]
----
ZREMRANGEBYRANK rank:score 0 0
(integer) 1
----


.移除排名第 0, 1, 2 的成员（即排名最低的前 3 名）。
[source,redis]
----
ZREMRANGEBYRANK rank:score 0 2
----

</t>
<t tx="swot.20250906102110.15">@language asciidoc

[source,redis]
----
SET session:abc "uid=9527" EX 1800
OK
----
**解释**  
`EX 1800` 让会话半小时后自己消失，**省得手删，秒变“自动登出”**。

[source,redis]
----
TTL session:abc
(integer) 1795
----
**解释**  
`TTL` 告诉你“还剩多少秒活”，**-2 表示已死，-1 表示永不过期**。

[source,redis]
----
PERSIST session:abc
(integer) 1
----
**解释**  
`PERSIST` 取消过期时间，**1 表示成功，0 表示本来就没过期时间或 key 不存在**。

====
比如实际应用中可以处理 `token abcdef...` 的过期时间。
====
</t>
<t tx="swot.20250906102110.16">@language asciidoc

[source,redis]
----
DBSIZE
(integer) 42
----
**解释**  
`DBSIZE` 当前库一共有 42 个 key，**做监控面板很方便**。

[source,redis]
----
INFO memory
# Memory
used_memory_human:1.23M
----
**解释**  
`INFO memory` 只看内存，**used_memory_human 给人类看的单位**。

[source,redis]
----
SLOWLOG GET 3
1) 1) (integer) 200
   2) (integer) 1680000000
   3) (integer) 10503
   4) 1) "KEYS"
      2) "*"
----
**解释**  

* `SLOWLOG` 列出最慢 3 条命令，**第 3 字段 10503 表示用了 10.5 毫秒**；
* 生产环境建议在 redis.conf 中加 `slowlog-log-slower-than 1000`，记录所有耗时超过 1 毫秒的命令。

[source,redis]
----
MONITOR
OK
----
**解释**  

* `MONITOR` 实时打印所有请求，**调试用，线上勿长开**，会拖慢性能。退出客户端
* MONITOR 不是 Redis 的服务配置，只要退出执行它的客户端连接，就算“关闭”了。


[source,redis]
----
CONFIG GET maxmemory
1) "maxmemory"
2) "0"
----
**解释**  

* `CONFIG GET` 查看运行配置，**0 表示没设内存上限**；
* 可动态 `CONFIG SET maxmemory 100mb`。

[source,redis]
----
FLUSHALL
OK
----
**解释**

* `FLUSHALL` 清空所有库，**危险！** 
* 建议改名或设 `rename-command FLUSHALL ""` 禁止线上执行。
</t>
<t tx="swot.20250906102110.17">@language asciidoc
把上面命令一条一条敲完，你对 Redis 的 **String/Hash/List/Set/Zset** 五大模块就全摸过一遍了。  

**记得：**

1. 线上禁用 `KEYS *` 和 `FLUSHALL`。
2. 内存设置 `maxmemory` + 淘汰策略 `allkeys-lru`。
3. 慢查询定期看，**超过 1 ms 就要关注**。
</t>
<t tx="swot.20250906102110.2">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20250906102110.3">Redis（Remote Dictionary Server）是一个开源的 **内存数据结构存储系统**，常用作数据库、缓存与消息队列。

它支持丰富的数据类型，提供微秒级响应，并可通过持久化、主从、哨兵与集群等机制保证高可用与水平扩展。

</t>
<t tx="swot.20250906102110.4">. **纯内存访问**：单线程模型，Qps 可达 10w+。

. **丰富的数据结构**：String / Hash / List / Set / SortedSet / Bitmap / HyperLogLog / Stream。

. **原子操作 &amp; Lua 脚本**：单线程串行执行，支持事务（MULTI/EXEC）与 Lua 自定义逻辑。

. **高可用 &amp; 扩展**：
  **主从复制** • **哨兵 Sentinel** • **Cluster 分片（16384 槽）**

. **持久化双策略**：
  **RDB**（快照，快速恢复） • **AOF**（追加日志，更高安全） • 可混合使用。
</t>
<t tx="swot.20250906102110.5">[cols="1,2a",options="header"]
|===
|平台 |一键步骤

|Windows
|1. 下载社区版 MSI https://github.com/microsoftarchive/redis/releases +
2. 双击安装 → 勾选“加入 PATH” → 完成 +
3. 启动 `redis-server.exe` 与 `redis-cli.exe`

|Linux（Ubuntu/Debian）
|[source,bash]
----
sudo apt update &amp;&amp; sudo apt install redis-server
sudo systemctl enable --now redis-server
redis-cli ping   # 返回 PONG 即成功
----

|macOS
|[source,bash]
----
brew install redis
brew services start redis
redis-cli ping
----
|===

TIP: 我们还可以使用 docker 来运行 redis
</t>
<t tx="swot.20250906102110.6">1) 命令行交互::
  `redis-cli [-h host -p port -a password]`

2) 官方 GUI::
  RedisInsight（仅部分开源（社区版功能阉割，企业版收费）） +
  Tiny RDM（开源（GPL-3.0） https://github.com/tiny-craft/tiny-rdm

3)各语言客户端（TCP 协议，默认 6379）::
+
====
* Python: `redis-py`
* Java: `Jedis` / `Lettuce`
* Go: `go-redis`
* Node: `ioredis`
====

4) SpringBoot 集成::
  `spring-boot-starter-data-redis` + `RedisTemplate`

</t>
<t tx="swot.20250906102110.7">[cols="1,3",options="header"]
|===
|类型 |速查表

|键 Key
|`DEL` `EXISTS` `EXPIRE` `TTL` `KEYS pattern`

|String
|`SET` `GET` `MSET` `MGET` `INCR`

|Hash
|`HSET` `HGET` `HGETALL` `HLEN` `HDEL`

|List
|`LPUSH` `RPOP` `LRANGE` `LLEN` `LTRIM`

|Set
|`SADD` `SMEMBERS` `SISMEMBER` `SCARD` `SINTER`

|SortedSet
|`ZADD` `ZRANGE` `ZREVRANK` `ZSCORE` `ZCARD`

|服务器
|`PING` `INFO` `FLUSHALL` `SAVE` `BGSAVE`
|===

</t>
<t tx="swot.20250906102110.8">[source,console]
----
redis-cli

127.0.0.1:6379&gt; SET site redis.io
OK

127.0.0.1:6379&gt; GET site
"redis.io"

127.0.0.1:6379&gt; EXPIRE site 60
(integer) 1    # &lt;.&gt;

127.0.0.1:6379&gt; TTL site
(integer) 58
----

&lt;1&gt; 表示命令执行成功，并且键 site 存在，且成功设置了 60 秒的过期时间。
</t>
<t tx="swot.20250906102110.9">@language asciidoc
// 统一提示块样式
.新手 Tips
[TIP]
====
* 返回结果中的 `(integer) 1` 表示 Redis 告诉你“影响了 1 条数据”。
* `OK` 就是“成功”；
* `(nil)` 就是“没查到，空的”。
====

</t>
<t tx="swot.20250916164207.1">@language asciidoc
.docker pull MySQL
image::img/docker_pull_mysql.png[]

.docker_run_MySQL
image::img/docker_run_mysql.png[]

.docker_run_MySQL_port
image::img/docker_run_mysql_port.png[,600]

.docker_container_mysql
image::img/docker_container_mysql.png[]

在宿主机测试连接到 redis 服务器::
mysql -h127.0.0.1 -P3307 -uroot -p

[TIP]
====
MySQL 本身永远只监听容器内的 3306 端口，
“连 3307” 其实是指连宿主机上映射出来的 3307 端口，
宿主机再把流量转发到容器的 3306。
====
</t>
<t tx="swot.20250921231329.1">@language asciidoc
.docker_pull_nginx 
image::img/docker_pull_nginx.png[]

.docker_run_nginx
image::img/docker_run_nginx.png[]

.docker_run_nginx_port
image::img/docker_run_nginx_port.png[,600]

.docker_container_nginx
image::img/docker_container_nginx.png[]

</t>
<t tx="swot.20250927110835.1">@language asciidoc
https://github.com/redis/redis

For developers, who are building real-time data-driven applications, Redis is the preferred, fastest, and most feature-rich cache, data structure server, and document and vector query engine.


</t>
</tnodes>
</leo_file>
