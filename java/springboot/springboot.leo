<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="swot.20241028143347.1"><vh>@adoc SpringBoot-1-Introduce.adoc</vh>
<v t="swot.20241028143347.2"><vh>Spring Boot 基本介绍</vh>
<v t="swot.20241028143347.3"><vh>官网介绍</vh></v>
<v t="swot.20241028143347.4"><vh>安装 JDK</vh></v>
<v t="swot.20241028143347.5"><vh>创建一个空的工程</vh></v>
<v t="swot.20241028143347.6"><vh>快速入门</vh>
<v t="swot.20241028143347.7"><vh>initializr 创建 Spring Boot 模块</vh></v>
<v t="swot.20241028143347.8"><vh>aliyun 创建 Spring Boot 模块(了解)</vh></v>
<v t="swot.20241028143347.9"><vh>导入自己创建的 Spring Boot 模块</vh></v>
<v t="swot.20241028143347.10"><vh>定义控制类并添加方法</vh>
<v t="swot.20241028143347.11"><vh>#file spring-boot-ketang/hello-spring-boot/src/main/java/com/tjise/HelloController.java</vh></v>
</v>
<v t="swot.20241028143347.12"><vh>运行测试</vh></v>
</v>
<v t="swot.20241028143347.13"><vh>HTTP协议</vh>
<v t="swot.20241028143347.14"><vh>HTTP 概述</vh></v>
<v t="swot.20241028143347.15"><vh>HTTP 请求协议 GET</vh></v>
<v t="swot.20241028143347.16"><vh>HTTP 请求协议 POST</vh></v>
<v t="swot.20241028143347.17"><vh>HTTP 响应协议</vh></v>
<v t="swot.20241028143347.18"><vh>HTTP 响应状态码</vh></v>
<v t="swot.20241028143347.19"><vh>HTTP 协议解析</vh>
<v t="swot.20241028143347.20"><vh>自定义 Socket 服务器解析 HTTP 请求</vh>
<v t="swot.20241028143347.21"><vh>#file spring-boot-ketang/simple-http-server/src/main/java/SimpleHttpServer.java</vh></v>
</v>
</v>
</v>
<v t="swot.20241028143347.22"><vh>Tomcat(Web Server) 了解</vh>
<v t="swot.20241028143347.23"><vh>Tomcat 安装使用</vh></v>
<v t="swot.20241028143347.24"><vh>Tomcat 启动时可能出现问题</vh></v>
</v>
</v>
</v>
<v t="swot.20241015083350.1"><vh>@adoc SpringBoot-2-request.adoc </vh>
<v t="swot.20241015083350.2"><vh>Spring Boot 请求数据</vh>
<v t="swot.20241015083350.3"><vh>HTTP 请求调试工具</vh>
<v t="swot.20241015083350.4"><vh>Postman 国外</vh></v>
<v t="swot.20241015083350.5"><vh>Apifox  国产</vh></v>
<v t="swot.20241015083350.6"><vh>Apipost 国产</vh></v>
<v t="swot.20250910075822.1"><vh>httpie  命令行工具</vh>
<v t="swot.20250910141955.1"><vh>安装</vh></v>
<v t="swot.20250910141943.1"><vh>发送 GET 请求</vh></v>
<v t="swot.20250910141937.1"><vh>发送 POST 请求</vh></v>
<v t="swot.20250910141928.1"><vh>发送 PUT 和 PATCH 请求</vh></v>
<v t="swot.20250910141920.1"><vh>发送 DELETE 请求</vh></v>
<v t="swot.20250910141915.1"><vh>添加 HTTP 头</vh></v>
<v t="swot.20250910141846.1"><vh>表单提交</vh></v>
<v t="swot.20250910141841.1"><vh>文件上传</vh></v>
<v t="swot.20250910141835.1"><vh>查询参数</vh></v>
<v t="swot.20250910141823.1"><vh>输出处理</vh></v>
<v t="swot.20250910141816.1"><vh>会话与认证</vh></v>
<v t="swot.20250910141808.1"><vh>综合示例：测试 JSONPlaceholder API</vh></v>
<v t="swot.20250910141800.1"><vh>总结</vh></v>
</v>
</v>
<v t="swot.20241015083350.7"><vh>新创建请求响应模块</vh></v>
<v t="swot.20241015083350.8"><vh>request  请求数据</vh>
<v t="swot.20241015083350.9"><vh>file -&gt; spring-boot-ketang/spring-boot-request-response/src/main/java/com/tjise/controller/RequestController.java</vh>
<v t="swot.20241015083350.10"><vh>简单请求参数原始方式演示(了解以后不用)</vh></v>
<v t="swot.20241015083350.11"><vh>简单请求参数: 前端提交与方法形参一致</vh></v>
<v t="swot.20241015083350.12"><vh>@RequestParam 简单请求参数不一致</vh></v>
<v t="swot.20241015083350.13"><vh>简单实体对象参数</vh></v>
<v t="swot.20241015083350.14"><vh>复杂实体对象参数（嵌套）</vh></v>
<v t="swot.20241015083350.15"><vh>使用数组接收参数（默认）</vh></v>
<v t="swot.20241015083350.16"><vh>@RequestParam   使用集合接收参数（需使用 @RequestParam 指定）</vh></v>
<v t="swot.20241015083350.17"><vh>@DateTimeFormat 日期参数</vh></v>
<v t="swot.20241015083350.18"><vh>@RequestBody    解析前端上传的 json 数据</vh></v>
<v t="swot.20241015083350.19"><vh>@PathVariable   路径参数</vh></v>
</v>
<v t="swot.20241015083350.20"><vh>创建包 pojo 再创建下面实体类</vh>
<v t="swot.20241015083350.21"><vh>#file spring-boot-ketang/spring-boot-request-response/src/main/java/com/tjise/pojo/User.java</vh></v>
<v t="swot.20241015083350.22"><vh>#file spring-boot-ketang/spring-boot-request-response/src/main/java/com/tjise/pojo/User.java</vh></v>
<v t="swot.20241015083350.23"><vh>#file spring-boot-ketang/spring-boot-request-response/src/main/java/com/tjise/pojo/Address.java</vh></v>
</v>
</v>
</v>
</v>
<v t="swot.20241016134143.1"><vh>@adoc SpringBoot-3-response.adoc</vh>
<v t="swot.20241016134143.2"><vh>Spring Boot 响应数据</vh>
<v t="swot.20241017094230.1"><vh>@path spring-boot-ketang/spring-boot-request-response/</vh>
<v t="swot.20241016134143.3"><vh>@ResponseBody 了解内容</vh></v>
<v t="swot.20250912080734.1"><vh>三种常用 response 类型</vh>
<v t="swot.20241016134143.4"><vh>file -&gt; src/main/java/com/tjise/controller/ResponseController.java</vh>
<v t="swot.20241016134143.5"><vh>return String</vh></v>
<v t="swot.20241016134143.6"><vh>return User json</vh></v>
<v t="swot.20241016134143.7"><vh>return List json</vh></v>
</v>
</v>
<v t="swot.20241016134143.8"><vh>定义统一响应结果类 Result</vh>
<v t="swot.20241016134143.9"><vh>file -&gt; src/main/java/com/tjise/pojo/Result.java</vh></v>
<v t="swot.20250911104818.1"><vh>file -&gt; src/main/java/com/tjise/controller/ResponseController.java</vh>
<v t="swot.20250911104818.2"><vh>return Result -&gt; String</vh></v>
<v t="swot.20250911104818.3"><vh>return Result -&gt; User</vh></v>
<v t="swot.20250911104818.4"><vh>return Result -&gt; List</vh></v>
</v>
</v>
<v t="swot.20241016134143.14"><vh>统一响应结果类中封装静态方法 static Result success</vh>
<v t="swot.20241016134143.15"><vh>file -&gt; src/main/java/com/tjise/pojo/Result.java</vh>
<v t="swot.20241016134143.16"><vh>@ignore-node 省略构造方法和 getter &amp; setter</vh></v>
</v>
<v t="swot.20241016134143.17"><vh>file -&gt; src/main/java/com/tjise/controller/ResponseController.java</vh>
<v t="swot.20241016134143.18"><vh>return Result -&gt; String</vh></v>
<v t="swot.20241016134143.19"><vh>return Result -&gt; User</vh></v>
<v t="swot.20241016134143.20"><vh>return Result -&gt; List</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="swot.20241017141815.1"><vh>@adoc SpringBoot-4-xml-example.adoc</vh>
<v t="swot.20241017141815.2"><vh>XML数据打通前后端案例</vh>
<v t="swot.20241017141815.3"><vh>1) user.xml 数据文件</vh>
<v t="swot.20241017141815.4"><vh>#file spring-boot-ketang/spring-boot-request-response/src/main/resources/user.xml</vh></v>
</v>
<v t="swot.20241017141815.5"><vh>2) pom.xml 增加依赖 dom4j</vh></v>
<v t="swot.20241017141815.6"><vh>3) 工具类 utils/XmlParserUtils.java</vh>
<v t="swot.20241017141815.7"><vh>#file spring-boot-ketang/spring-boot-request-response/src/main/java/com/tjise/utils/XmlParserUtils.java</vh></v>
</v>
<v t="swot.20241017141815.10"><vh>4) 写api功能方法</vh>
<v t="swot.20241017145139.1"><vh>#file spring-boot-ketang/spring-boot-request-response/src/main/java/com/tjise/controller/UserController.java</vh></v>
</v>
<v t="swot.20241017141815.8"><vh>5) user.html 放入资源目录</vh>
<v t="swot.20241017141815.9"><vh>#file spring-boot-ketang/spring-boot-request-response/src/main/resources/static/user.html</vh></v>
</v>
<v t="swot.20241017141815.12"><vh>6) 运行项目并测试网页</vh></v>
</v>
</v>
<v t="swot.20241018082408.1"><vh>@adoc SpringBoot-5-three-layers.adoc</vh>
<v t="swot.20241018082408.2"><vh>三层架构改造</vh>
<v t="swot.20241018093655.1"><vh>@path spring-boot-ketang/spring-boot-request-response</vh>
<v t="swot.20241018082408.3"><vh>代码结构在设计上存在的问题</vh>
<v t="swot.20241018084615.1"><vh>#file src/main/java/com/tjise/controller/UserController.java</vh></v>
</v>
<v t="swot.20241018082408.5"><vh>三层架构拆分代码</vh>
<v t="swot.20241018082408.6"><vh>1) dao 层数据访问</vh>
<v t="swot.20241018082408.7"><vh>#file src/main/java/com/tjise/dao/UserDaoA.java</vh></v>
</v>
<v t="swot.20241018082408.8"><vh>2) service 层逻辑处理</vh>
<v t="swot.20241018082408.9"><vh>#file src/main/java/com/tjise/service/UserServiceA.java</vh></v>
</v>
<v t="swot.20241018082408.10"><vh>3) controller 层处理请求、响应数据</vh>
<v t="swot.20241018082408.11"><vh>#file src/main/java/com/tjise/controller/UserController.java</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="swot.20241028160046.1" descendentVnodeUnknownAttributes="7d71005807000000302e302e302e3371017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032342d31302d303971077573732e"><vh>@adoc SpringBoot-6-decoupling.adoc</vh>
<v t="swot.20241028160207.1" descendentVnodeUnknownAttributes="7d71005805000000302e302e3371017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032342d31302d303971077573732e"><vh>三层架构分层的解耦</vh>
<v t="swot.20241028160248.1" descendentVnodeUnknownAttributes="7d71005803000000302e3371017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032342d31302d303971077573732e"><vh>@path spring-boot-ketang/spring-boot-request-response/src/main/java/com/tjise</vh>
<v t="swot.20241018105726.4"><vh>1. 高内聚低耦合问题描述</vh>
<v t="swot.20241018105726.5"><vh>#file service/UserServiceA.java</vh></v>
<v t="swot.20241018105726.6"><vh>#file controller/UserController.java</vh></v>
</v>
<v t="swot.20241018105726.7"><vh>2. 降低获取数据时左边类型的耦合 -&gt; left多态</vh>
<v t="swot.20241018105726.8"><vh>#file dao/UserDao.java</vh></v>
<v t="swot.20241018105726.9"><vh>#file dao/UserDaoA.java</vh></v>
<v t="swot.20241018105726.10"><vh>#file service/UserServiceA.java</vh></v>
</v>
<v t="swot.20241018105726.11"><vh>3. 降低处理逻辑时左边类型的耦合 -&gt; left多态</vh>
<v t="swot.20241018105726.12"><vh>#file service/UserService.java</vh></v>
<v t="swot.20241018105726.13"><vh>#file service/UserServiceA.java</vh></v>
<v t="swot.20241018105726.14"><vh>#file controller/UserController.java</vh></v>
</v>
<v t="swot.20241018105726.15" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032342d31302d303971077573732e"><vh>4. 降低获取数据时右边类型的耦合 -&gt; right IOC/DI</vh>
<v t="swot.20241018105726.16"><vh>#file dao/UserDaoA.java</vh></v>
<v t="swot.20241018105726.17"><vh>#file service/UserServiceA.java</vh></v>
<v t="swot.20241018105726.18"><vh>#file controller/UserController.java</vh></v>
</v>
<v t="swot.20241018105726.19"><vh>5. 查看 IOC 容器中的 Bean 对象</vh>
<v t="swot.20241018105726.20"><vh>方法1 使用 Actuator -&gt; **推荐**</vh></v>
<v t="swot.20241018105726.21"><vh>方法2 在日志中输出</vh></v>
<v t="swot.20241018105726.22"><vh>方法3 启动类输出 ApplicationContext</vh></v>
</v>
<v t="swot.20241018105726.23"><vh>6. 声明 IOC 容器中的 Bean 对象拓展</vh>
<v t="swot.20241018105726.24"><vh>#file dao/UserDaoA.java</vh></v>
<v t="swot.20241018105726.25"><vh>#file service/UserServiceA.java</vh></v>
<v t="swot.20241018105726.26"><vh>#file controller/UserController.java</vh></v>
</v>
<v t="swot.20241018105726.27"><vh>7. 声明 IOC 容器中的 Bean 对象注意事项</vh>
<v t="swot.20241018105726.28"><vh>ICO 容器中 bean 对象命名规则</vh>
<v t="swot.20241018105726.29"><vh>#file service/UserServiceA.java</vh></v>
</v>
<v t="swot.20241018105726.30"><vh>Web 开发控制器只能用 @Controller</vh></v>
</v>
<v t="swot.20241018105726.31"><vh>8. 进入 IOC 容器中的 Bean 对象扫描</vh></v>
<v t="swot.20241018105726.32"><vh>9. 使用 IOC 容器中的 Bean 对象注入报错</vh>
<v t="swot.20241018105726.33"><vh>#file controller/UserController.java</vh></v>
<v t="swot.20241018105726.34"><vh>#file service/UserServiceA.java</vh></v>
<v t="swot.20241018105726.35"><vh>#file service/UserServiceB.java</vh></v>
</v>
<v t="swot.20241018105726.36"><vh>10. 选择 IOC 容器中的 Bean 对象注入方式 @Primary</vh>
<v t="swot.20241018105726.37"><vh>#file service/UserServiceA.java</vh></v>
</v>
<v t="swot.20241018105726.38"><vh>11. 选择 IOC 容器中的 Bean 对象注入方式 @Qualifier</vh>
<v t="swot.20241018105726.39"><vh>#file controller/UserController.java</vh></v>
</v>
<v t="swot.20241018105726.40"><vh>12. 选择 IOC 容器中的 Bean 对象注入方式 @Resource</vh>
<v t="swot.20241018105726.41"><vh>#file controller/UserController.java</vh></v>
</v>
</v>
</v>
</v>
<v t="swot.20241013133847.1"><vh>@adoc SpringBoot-7-Mybatis.adoc</vh>
<v t="swot.20241013133847.2"><vh>Mybatis 入门</vh>
<v t="swot.20250914220406.1"><vh>MyBatis 介绍</vh></v>
<v t="swot.20241013133847.4"><vh>MyBatis 快速入门</vh>
<v t="swot.20241011155227.9"><vh>导入自己创建的 Spring Boot 模块</vh></v>
<v t="swot.20241013223431.1"><vh>检查所有依赖版本</vh></v>
<v t="swot.20241013133847.7"><vh>创建用户表 user</vh></v>
<v t="swot.20241013133847.8"><vh>创建对应的实体类 User</vh>
<v t="swot.20241013175526.1"><vh>#file spring-boot-ketang/mybatis-quickstart/src/main/java/com/tjise/pojo/User.java</vh></v>
</v>
<v t="swot.20241013133847.9"><vh>编写 application.properties</vh>
<v t="swot.20241013185549.1"><vh>#file spring-boot-ketang/mybatis-quickstart/src/main/resources/application.properties</vh></v>
</v>
<v t="swot.20241014120257.1"><vh>文件乱码 application.properties</vh></v>
<v t="swot.20241013133847.10"><vh>编写持久层接口 UserMapper 及 SQL</vh>
<v t="swot.20241013192152.1"><vh>#file spring-boot-ketang/mybatis-quickstart/src/main/java/com/tjise/dao/UserMapper.java</vh></v>
</v>
<v t="swot.20241013133847.11"><vh>单元测试</vh>
<v t="swot.20241013192859.1"><vh>#file spring-boot-ketang/mybatis-quickstart/src/test/java/com/tjise/MybatisQuickstartApplicationTests.java</vh></v>
</v>
</v>
<v t="swot.20241013133847.12"><vh>JDBC 介绍(了解)</vh></v>
<v t="swot.20241013133847.13"><vh>数据库连接池 Druid</vh></v>
<v t="swot.20241013133847.14"><vh>lombok 注解简化 pojo 类代码</vh>
<v t="swot.20241015110533.1"><vh>#file spring-boot-ketang/mybatis-quickstart/src/main/java/com/tjise/pojo/User.java</vh></v>
</v>
</v>
</v>
<v t="swot.20241015114619.1"><vh>@adoc SpringBoot-8-Mybatis-crud-运行测试类.adoc</vh>
<v t="swot.20241015114654.1"><vh>1. Mybatis 基础增删改查 -&gt; 删除</vh>
<v t="swot.20241016171631.1"><vh>@path spring-boot-ketang/mybatis_quickstart-crud</vh>
<v t="swot.20241015113043.1"><vh>案例准备工作</vh></v>
<v t="swot.20241011155227.9"></v>
<v t="swot.20241013223431.1"></v>
<v t="swot.20241015140346.1"><vh>编写 application.properties</vh>
<v t="swot.20241015140346.2"><vh>#file src/main/resources/application.properties</vh></v>
</v>
<v t="swot.20241015140945.1"><vh>创建数据库表 emp</vh></v>
<v t="swot.20241015161423.1"><vh>插入数据到表 emp</vh></v>
<v t="swot.20241015141007.1"><vh>创建对应的实体类 Emp</vh>
<v t="swot.20241015171320.1"><vh>#file src/main/java/com/tjise/pojo/Emp.java</vh></v>
</v>
<v t="swot.20241015155338.1"><vh>创建 Mapper 接口 EmpMapper</vh>
<v t="swot.20241015172918.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh></v>
</v>
<v t="swot.20241015154730.1"><vh>删除记录练习</vh>
<v t="swot.20241016160357.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh></v>
<v t="swot.20241016164835.1"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh></v>
</v>
<v t="swot.20241017105433.1"><vh>打开 mybatis 日志查看执行的 sql 语句</vh>
<v t="swot.20241017110155.1"><vh>#file src/main/resources/application.properties</vh></v>
</v>
<v t="swot.20241016162731.1"><vh>预编译 SQL 知识介绍</vh></v>
<v t="swot.20241017171352.1"><vh>参数占位符</vh>
<v t="swot.20241017172315.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh></v>
</v>
<v t="swot.20241017230959.1"><vh>测试 ${} 的使用场景</vh>
<v t="swot.20241017233030.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh></v>
<v t="swot.20241017233039.1"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh></v>
</v>
</v>
</v>
<v t="swot.20241017235753.1"><vh>2. Mybatis 基础增删改查 -&gt; 新增</vh>
<v t="swot.20241018000113.1"><vh>@path spring-boot-ketang/mybatis_quickstart-crud</vh>
<v t="swot.20241018111146.1"><vh>Mapper(Dao层) Insert 记录</vh>
<v t="swot.20241018163833.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh>
<v t="swot.20241018164917.1"><vh>@ignore-node Delete</vh></v>
</v>
</v>
<v t="swot.20241018111823.1"><vh>单元测试 insertEmpTest</vh>
<v t="swot.20241018165656.1"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh>
<v t="swot.20241018170027.1"><vh>@ignore-node delete test</vh></v>
</v>
</v>
<v t="swot.20241018111925.1"><vh>获取自增主键 id -&gt; Options</vh>
<v t="swot.20241019073624.1"><vh>file -&gt; src/main/java/com/tjise/mapper/EmpMapper.java</vh>
<v t="swot.20241019073624.2"><vh>@ignore-node Delete</vh></v>
</v>
<v t="swot.20241019132212.1"><vh>file -&gt; src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh>
<v t="swot.20241019132212.2"><vh>@ignore-node delete test</vh></v>
</v>
</v>
</v>
</v>
<v t="swot.20241019134748.1"><vh>3. Mybatis 基础增删改查 -&gt; 更新</vh>
<v t="swot.20241019134827.1"><vh>@path spring-boot-ketang/mybatis_quickstart-crud</vh>
<v t="swot.20241019140657.1"><vh>Mapper(Dao层) Update 记录</vh>
<v t="swot.20241019141143.1"><vh>file -&gt; src/main/java/com/tjise/mapper/EmpMapper.java</vh>
<v t="swot.20241019141143.2"><vh>@ignore-node Delete &amp; Insert</vh></v>
</v>
</v>
<v t="swot.20241019195417.1"><vh>单元测试 updateEmpTest</vh>
<v t="swot.20241019194520.1"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh>
<v t="swot.20241019194520.2"><vh>@ignore-node delete test</vh></v>
</v>
</v>
</v>
</v>
<v t="swot.20241019201320.1"><vh>4. Mybatis 基础增删改查 -&gt; 查询</vh>
<v t="swot.20241019212645.1"><vh>@path spring-boot-ketang/mybatis_quickstart-crud</vh>
<v t="swot.20241019201654.1"><vh>Mapper(Dao层)  Select 单条件查询</vh>
<v t="swot.20241019203857.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh>
<v t="swot.20241019203857.2"><vh>@ignore-node Delete &amp; Insert</vh></v>
</v>
<v t="swot.20250915162444.1"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh>
<v t="swot.20250915162516.1"><vh>@ignore-node delete test</vh></v>
<v t="swot.20250915162835.1"><vh>@ignore-node insertEmpTest</vh></v>
<v t="swot.20250915162847.1"><vh>@ignore-node updateEmpTest</vh></v>
</v>
<v t="swot.20241020074923.1"><vh>1) @Select  数据封装 -&gt; 起别名 (了解)</vh>
<v t="swot.20241020080523.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh>
<v t="swot.20241020080523.2"><vh>@ignore-node Delete &amp; Insert</vh></v>
</v>
</v>
<v t="swot.20241020074943.1"><vh>2) @Results 数据封装 -&gt; 手动结果映射 @Result (了解)</vh>
<v t="swot.20241020084506.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh>
<v t="swot.20241020084506.2"><vh>@ignore-node Delete &amp; Insert</vh></v>
</v>
</v>
<v t="swot.20241020074953.1"><vh>3) 配置文件  数据封装 -&gt; 开启驼峰命名映射 (推荐)</vh>
<v t="swot.20241020090529.1"><vh>#file src/main/resources/application.properties</vh></v>
<v t="swot.20241020091051.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh>
<v t="swot.20241020091051.2"><vh>@ignore-node Delete &amp; Insert</vh></v>
</v>
</v>
</v>
<v t="swot.20241020093531.1"><vh>Mapper(Dao层)  Select 多条件查询</vh>
<v t="swot.20241020122951.1"><vh>报错案例 %#{name}%</vh>
<v t="swot.20241020100949.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh>
<v t="swot.20241020100949.2"><vh>@ignore-node Delete &amp; Insert</vh></v>
</v>
<v t="swot.20241020102249.1"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh>
<v t="swot.20241020102249.2"><vh>@ignore-node delete test</vh></v>
</v>
</v>
<v t="swot.20241020144239.1"><vh>方案一改成 %${name}% (字符串拼接)</vh>
<v t="swot.20241020144239.2"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh>
<v t="swot.20241020144239.3"><vh>@ignore-node Delete &amp; Insert</vh></v>
</v>
</v>
<v t="swot.20241020150709.1"><vh>方案二改成函数 concat (有预编译)</vh>
<v t="swot.20241020154020.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh>
<v t="swot.20241020154020.2"><vh>@ignore-node Delete &amp; Insert</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="swot.20241020175210.1" descendentVnodeUnknownAttributes="7d7100285809000000302e302e312e312e3371017d7102285808000000616e6e6f7461746571037d71042858080000007072696f7269747971054b01580a000000707269736574646174657106580a000000323032342d31302d3231710775580500000069636f6e7371085d71097d710a28580400000074797065710b580400000066696c65710c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269312e706e67710d580700000072656c50617468710e580d000000636c656f2f707269312e706e67710f580500000077686572657110580e0000006265666f7265486561646c696e6571115807000000796f666673657471124b005807000000786f666673657471134b0258040000007870616471144b0158020000006f6e71155805000000766e6f646571165808000000636c656f49636f6e711758010000003171187561755809000000302e302e312e312e3471197d711a285808000000616e6e6f74617465711b7d711c2858080000007072696f72697479711d4b02580a00000070726973657464617465711e580a000000323032342d31302d3231711f75580500000069636f6e7371205d71217d712228680b680c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269322e706e677123680e580d000000636c656f2f707269322e706e6771246810681168124b0068134b0268144b0168156816681768187561755809000000302e302e312e312e3571257d7126285808000000616e6e6f7461746571277d71282858080000007072696f7269747971294b03580a00000070726973657464617465712a580a000000323032342d31302d3231712b75580500000069636f6e73712c5d712d7d712e28680b680c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269332e706e67712f680e580d000000636c656f2f707269332e706e6771306810681168124b0068134b0268144b0168156816681768187561755809000000302e302e312e312e3671317d7132285808000000616e6e6f7461746571337d71342858080000007072696f7269747971354b04580a000000707269736574646174657136580a000000323032342d31302d3231713775580500000069636f6e7371385d71397d713a28680b680c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269342e706e67713b680e580d000000636c656f2f707269342e706e67713c6810681168124b0068134b0268144b0168156816681768187561755809000000302e302e312e312e39713d7d713e285808000000616e6e6f74617465713f7d71402858080000007072696f7269747971414b01580a000000707269736574646174657142580a000000323032342d31302d3231714375580500000069636f6e7371445d71457d714628680b680c680c680d680e580d000000636c656f2f707269312e706e6771476810681168124b0068134b0268144b016815681668176818756175580a000000302e302e312e312e313071487d7149285808000000616e6e6f74617465714a7d714b2858080000007072696f72697479714c4b02580a00000070726973657464617465714d580a000000323032342d31302d3231714e75580500000069636f6e73714f5d71507d715128680b680c680c6823680e580d000000636c656f2f707269322e706e6771526810681168124b0068134b0268144b016815681668176818756175580a000000302e302e312e312e313171537d7154285808000000616e6e6f7461746571557d71562858080000007072696f7269747971574b03580a000000707269736574646174657158580a000000323032342d31302d3231715975580500000069636f6e73715a5d715b7d715c28680b680c680c682f680e580d000000636c656f2f707269332e706e67715d6810681168124b0068134b0268144b016815681668176818756175580a000000302e302e312e312e3132715e7d715f285808000000616e6e6f7461746571607d71612858080000007072696f7269747971624b04580a000000707269736574646174657163580a000000323032342d31302d3231716475580500000069636f6e7371655d71667d716728680b680c680c683b680e580d000000636c656f2f707269342e706e6771686810681168124b0068134b0268144b016815681668176818756175752e"><vh>@adoc SpringBoot-9-Mybatis-dynamic-SQL.adoc</vh>
<v t="swot.20241013133847.16" descendentVnodeUnknownAttributes="7d7100285807000000302e312e312e3371017d7102285808000000616e6e6f7461746571037d71042858080000007072696f7269747971054b01580a000000707269736574646174657106580a000000323032342d31302d3231710775580500000069636f6e7371085d71097d710a28580400000074797065710b580400000066696c65710c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269312e706e67710d580700000072656c50617468710e580d000000636c656f2f707269312e706e67710f580500000077686572657110580e0000006265666f7265486561646c696e6571115807000000796f666673657471124b005807000000786f666673657471134b0258040000007870616471144b0158020000006f6e71155805000000766e6f646571165808000000636c656f49636f6e711758010000003171187561755807000000302e312e312e3471197d711a285808000000616e6e6f74617465711b7d711c2858080000007072696f72697479711d4b02580a00000070726973657464617465711e580a000000323032342d31302d3231711f75580500000069636f6e7371205d71217d712228680b680c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269322e706e677123680e580d000000636c656f2f707269322e706e6771246810681168124b0068134b0268144b0168156816681768187561755807000000302e312e312e3571257d7126285808000000616e6e6f7461746571277d71282858080000007072696f7269747971294b03580a00000070726973657464617465712a580a000000323032342d31302d3231712b75580500000069636f6e73712c5d712d7d712e28680b680c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269332e706e67712f680e580d000000636c656f2f707269332e706e6771306810681168124b0068134b0268144b0168156816681768187561755807000000302e312e312e3671317d7132285808000000616e6e6f7461746571337d71342858080000007072696f7269747971354b04580a000000707269736574646174657136580a000000323032342d31302d3231713775580500000069636f6e7371385d71397d713a28680b680c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269342e706e67713b680e580d000000636c656f2f707269342e706e67713c6810681168124b0068134b0268144b0168156816681768187561755807000000302e312e312e39713d7d713e285808000000616e6e6f74617465713f7d71402858080000007072696f7269747971414b01580a000000707269736574646174657142580a000000323032342d31302d3231714375580500000069636f6e7371445d71457d714628680b680c680c680d680e580d000000636c656f2f707269312e706e6771476810681168124b0068134b0268144b0168156816681768187561755808000000302e312e312e313071487d7149285808000000616e6e6f74617465714a7d714b2858080000007072696f72697479714c4b02580a00000070726973657464617465714d580a000000323032342d31302d3231714e75580500000069636f6e73714f5d71507d715128680b680c680c6823680e580d000000636c656f2f707269322e706e6771526810681168124b0068134b0268144b0168156816681768187561755808000000302e312e312e313171537d7154285808000000616e6e6f7461746571557d71562858080000007072696f7269747971574b03580a000000707269736574646174657158580a000000323032342d31302d3231715975580500000069636f6e73715a5d715b7d715c28680b680c680c682f680e580d000000636c656f2f707269332e706e67715d6810681168124b0068134b0268144b0168156816681768187561755808000000302e312e312e3132715e7d715f285808000000616e6e6f7461746571607d71612858080000007072696f7269747971624b04580a000000707269736574646174657163580a000000323032342d31302d3231716475580500000069636f6e7371655d71667d716728680b680c680c683b680e580d000000636c656f2f707269342e706e6771686810681168124b0068134b0268144b016815681668176818756175752e"><vh>Mybatis 动态 SQL</vh>
<v t="swot.20250914230425.1"><vh>引入 XML 映射语句的必要性</vh></v>
<v t="swot.20241021103443.1" descendentVnodeUnknownAttributes="7d7100285805000000302e312e3371017d7102285808000000616e6e6f7461746571037d71042858080000007072696f7269747971054b01580a000000707269736574646174657106580a000000323032342d31302d3231710775580500000069636f6e7371085d71097d710a28580400000074797065710b580400000066696c65710c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269312e706e67710d580700000072656c50617468710e580d000000636c656f2f707269312e706e67710f580500000077686572657110580e0000006265666f7265486561646c696e6571115807000000796f666673657471124b005807000000786f666673657471134b0258040000007870616471144b0158020000006f6e71155805000000766e6f646571165808000000636c656f49636f6e711758010000003171187561755805000000302e312e3471197d711a285808000000616e6e6f74617465711b7d711c2858080000007072696f72697479711d4b02580a00000070726973657464617465711e580a000000323032342d31302d3231711f75580500000069636f6e7371205d71217d712228680b680c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269322e706e677123680e580d000000636c656f2f707269322e706e6771246810681168124b0068134b0268144b0168156816681768187561755805000000302e312e3571257d7126285808000000616e6e6f7461746571277d71282858080000007072696f7269747971294b03580a00000070726973657464617465712a580a000000323032342d31302d3231712b75580500000069636f6e73712c5d712d7d712e28680b680c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269332e706e67712f680e580d000000636c656f2f707269332e706e6771306810681168124b0068134b0268144b0168156816681768187561755805000000302e312e3671317d7132285808000000616e6e6f7461746571337d71342858080000007072696f7269747971354b04580a000000707269736574646174657136580a000000323032342d31302d3231713775580500000069636f6e7371385d71397d713a28680b680c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269342e706e67713b680e580d000000636c656f2f707269342e706e67713c6810681168124b0068134b0268144b0168156816681768187561755805000000302e312e39713d7d713e285808000000616e6e6f74617465713f7d71402858080000007072696f7269747971414b01580a000000707269736574646174657142580a000000323032342d31302d3231714375580500000069636f6e7371445d71457d714628680b680c680c680d680e580d000000636c656f2f707269312e706e6771476810681168124b0068134b0268144b0168156816681768187561755806000000302e312e313071487d7149285808000000616e6e6f74617465714a7d714b2858080000007072696f72697479714c4b02580a00000070726973657464617465714d580a000000323032342d31302d3231714e75580500000069636f6e73714f5d71507d715128680b680c680c6823680e580d000000636c656f2f707269322e706e6771526810681168124b0068134b0268144b0168156816681768187561755806000000302e312e313171537d7154285808000000616e6e6f7461746571557d71562858080000007072696f7269747971574b03580a000000707269736574646174657158580a000000323032342d31302d3231715975580500000069636f6e73715a5d715b7d715c28680b680c680c682f680e580d000000636c656f2f707269332e706e67715d6810681168124b0068134b0268144b0168156816681768187561755806000000302e312e3132715e7d715f285808000000616e6e6f7461746571607d71612858080000007072696f7269747971624b04580a000000707269736574646174657163580a000000323032342d31302d3231716475580500000069636f6e7371655d71667d716728680b680c680c683b680e580d000000636c656f2f707269342e706e6771686810681168124b0068134b0268144b016815681668176818756175752e"><vh>@path spring-boot-ketang/mybatis_quickstart-crud</vh>
<v t="swot.20241020191402.1"><vh>SQL 映射配置文件 XML规范</vh>
<v t="swot.20241021103711.1"><vh>#file src/main/resources/com/tjise/mapper/EmpMapper.xml</vh></v>
<v t="swot.20241021111600.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh>
<v t="swot.20241021111600.2"><vh>@ignore-node Delete &amp; Insert</vh></v>
</v>
<v t="swot.20241021162613.1"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh>
<v t="swot.20241021162613.2"><vh>@ignore-node delete test</vh></v>
</v>
</v>
<v t="swot.20241021155916.1" descendentVnodeUnknownAttributes="7d7100285803000000302e3371017d7102285808000000616e6e6f7461746571037d71042858080000007072696f7269747971054b01580a000000707269736574646174657106580a000000323032342d31302d3231710775580500000069636f6e7371085d71097d710a28580400000074797065710b580400000066696c65710c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269312e706e67710d580700000072656c50617468710e580d000000636c656f2f707269312e706e67710f580500000077686572657110580e0000006265666f7265486561646c696e6571115807000000796f666673657471124b005807000000786f666673657471134b0258040000007870616471144b0158020000006f6e71155805000000766e6f646571165808000000636c656f49636f6e711758010000003171187561755803000000302e3471197d711a285808000000616e6e6f74617465711b7d711c2858080000007072696f72697479711d4b02580a00000070726973657464617465711e580a000000323032342d31302d3231711f75580500000069636f6e7371205d71217d712228680b680c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269322e706e677123680e580d000000636c656f2f707269322e706e6771246810681168124b0068134b0268144b0168156816681768187561755803000000302e3571257d7126285808000000616e6e6f7461746571277d71282858080000007072696f7269747971294b03580a00000070726973657464617465712a580a000000323032342d31302d3231712b75580500000069636f6e73712c5d712d7d712e28680b680c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269332e706e67712f680e580d000000636c656f2f707269332e706e6771306810681168124b0068134b0268144b0168156816681768187561755803000000302e3671317d7132285808000000616e6e6f7461746571337d71342858080000007072696f7269747971354b04580a000000707269736574646174657136580a000000323032342d31302d3231713775580500000069636f6e7371385d71397d713a28680b680c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269342e706e67713b680e580d000000636c656f2f707269342e706e67713c6810681168124b0068134b0268144b0168156816681768187561755803000000302e39713d7d713e285808000000616e6e6f74617465713f7d71402858080000007072696f7269747971414b01580a000000707269736574646174657142580a000000323032342d31302d3231714375580500000069636f6e7371445d71457d714628680b680c680c680d680e580d000000636c656f2f707269312e706e6771476810681168124b0068134b0268144b0168156816681768187561755804000000302e313071487d7149285808000000616e6e6f74617465714a7d714b2858080000007072696f72697479714c4b02580a00000070726973657464617465714d580a000000323032342d31302d3231714e75580500000069636f6e73714f5d71507d715128680b680c680c6823680e580d000000636c656f2f707269322e706e6771526810681168124b0068134b0268144b0168156816681768187561755804000000302e313171537d7154285808000000616e6e6f7461746571557d71562858080000007072696f7269747971574b03580a000000707269736574646174657158580a000000323032342d31302d3231715975580500000069636f6e73715a5d715b7d715c28680b680c680c682f680e580d000000636c656f2f707269332e706e67715d6810681168124b0068134b0268144b0168156816681768187561755804000000302e3132715e7d715f285808000000616e6e6f7461746571607d71612858080000007072696f7269747971624b04580a000000707269736574646174657163580a000000323032342d31302d3231716475580500000069636f6e7371655d71667d716728680b680c680c683b680e580d000000636c656f2f707269342e706e6771686810681168124b0068134b0268144b016815681668176818756175752e"><vh>xml 标签 &lt;if&gt;</vh>
<v t="swot.20241021164304.1"><vh>#file src/main/resources/com/tjise/mapper/EmpMapper.xml</vh>
<v t="swot.20241021165158.1"><vh>@ignore-node others</vh></v>
</v>
<v t="swot.20241021164309.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh>
<v t="swot.20241021164309.2"><vh>@ignore-node others</vh></v>
</v>
<v t="swot.20241021173757.1"><vh>根据测试类传入的参数不同，分几种情况分析</vh></v>
<v t="swot.20241021164313.1" descendentVnodeUnknownAttributes="7d710058010000003071017d7102285808000000616e6e6f7461746571037d71042858080000007072696f7269747971054b01580a000000707269736574646174657106580a000000323032342d31302d3231710775580500000069636f6e7371085d71097d710a28580400000074797065710b580400000066696c65710c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269312e706e67710d580700000072656c50617468710e580d000000636c656f2f707269312e706e67710f580500000077686572657110580e0000006265666f7265486561646c696e6571115807000000796f666673657471124b005807000000786f666673657471134b0258040000007870616471144b0158020000006f6e71155805000000766e6f646571165808000000636c656f49636f6e71175801000000317118756175732e"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh></v>
<v t="swot.20241021173920.1" descendentVnodeUnknownAttributes="7d710058010000003071017d7102285808000000616e6e6f7461746571037d71042858080000007072696f7269747971054b02580a000000707269736574646174657106580a000000323032342d31302d3231710775580500000069636f6e7371085d71097d710a28580400000074797065710b580400000066696c65710c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269322e706e67710d580700000072656c50617468710e580d000000636c656f2f707269322e706e67710f580500000077686572657110580e0000006265666f7265486561646c696e6571115807000000796f666673657471124b005807000000786f666673657471134b0258040000007870616471144b0158020000006f6e71155805000000766e6f646571165808000000636c656f49636f6e71175801000000317118756175732e"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh></v>
<v t="swot.20241021202253.1" descendentVnodeUnknownAttributes="7d710058010000003071017d7102285808000000616e6e6f7461746571037d71042858080000007072696f7269747971054b03580a000000707269736574646174657106580a000000323032342d31302d3231710775580500000069636f6e7371085d71097d710a28580400000074797065710b580400000066696c65710c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269332e706e67710d580700000072656c50617468710e580d000000636c656f2f707269332e706e67710f580500000077686572657110580e0000006265666f7265486561646c696e6571115807000000796f666673657471124b005807000000786f666673657471134b0258040000007870616471144b0158020000006f6e71155805000000766e6f646571165808000000636c656f49636f6e71175801000000317118756175732e"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh></v>
<v t="swot.20241021203300.1" descendentVnodeUnknownAttributes="7d710058010000003071017d7102285808000000616e6e6f7461746571037d71042858080000007072696f7269747971054b04580a000000707269736574646174657106580a000000323032342d31302d3231710775580500000069636f6e7371085d71097d710a28580400000074797065710b580400000066696c65710c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269342e706e67710d580700000072656c50617468710e580d000000636c656f2f707269342e706e67710f580500000077686572657110580e0000006265666f7265486561646c696e6571115807000000796f666673657471124b005807000000786f666673657471134b0258040000007870616471144b0158020000006f6e71155805000000766e6f646571165808000000636c656f49636f6e71175801000000317118756175732e"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh></v>
<v t="swot.20241021204112.1"><vh>使用 &lt;where&gt; 标签解决 where 和 and 多或少的问题</vh></v>
<v t="swot.20241021204202.1"><vh>#file src/main/resources/com/tjise/mapper/EmpMapper.xml</vh>
<v t="swot.20241021204202.2"><vh>@ignore-node others</vh></v>
</v>
<v t="swot.20241021204736.1" descendentVnodeUnknownAttributes="7d710058010000003071017d7102285808000000616e6e6f7461746571037d71042858080000007072696f7269747971054b01580a000000707269736574646174657106580a000000323032342d31302d3231710775580500000069636f6e7371085d71097d710a28580400000074797065710b580400000066696c65710c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269312e706e67710d580700000072656c50617468710e580d000000636c656f2f707269312e706e67710f580500000077686572657110580e0000006265666f7265486561646c696e6571115807000000796f666673657471124b005807000000786f666673657471134b0258040000007870616471144b0158020000006f6e71155805000000766e6f646571165808000000636c656f49636f6e71175801000000317118756175732e"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh></v>
<v t="swot.20241021205103.1" descendentVnodeUnknownAttributes="7d710058010000003071017d7102285808000000616e6e6f7461746571037d71042858080000007072696f7269747971054b02580a000000707269736574646174657106580a000000323032342d31302d3231710775580500000069636f6e7371085d71097d710a28580400000074797065710b580400000066696c65710c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269322e706e67710d580700000072656c50617468710e580d000000636c656f2f707269322e706e67710f580500000077686572657110580e0000006265666f7265486561646c696e6571115807000000796f666673657471124b005807000000786f666673657471134b0258040000007870616471144b0158020000006f6e71155805000000766e6f646571165808000000636c656f49636f6e71175801000000317118756175732e"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh></v>
<v t="swot.20241021205410.1" descendentVnodeUnknownAttributes="7d710058010000003071017d7102285808000000616e6e6f7461746571037d71042858080000007072696f7269747971054b03580a000000707269736574646174657106580a000000323032342d31302d3231710775580500000069636f6e7371085d71097d710a28580400000074797065710b580400000066696c65710c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269332e706e67710d580700000072656c50617468710e580d000000636c656f2f707269332e706e67710f580500000077686572657110580e0000006265666f7265486561646c696e6571115807000000796f666673657471124b005807000000786f666673657471134b0258040000007870616471144b0158020000006f6e71155805000000766e6f646571165808000000636c656f49636f6e71175801000000317118756175732e"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh></v>
<v t="swot.20241021205922.1" descendentVnodeUnknownAttributes="7d710058010000003071017d7102285808000000616e6e6f7461746571037d71042858080000007072696f7269747971054b04580a000000707269736574646174657106580a000000323032342d31302d3231710775580500000069636f6e7371085d71097d710a28580400000074797065710b580400000066696c65710c680c58320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269342e706e67710d580700000072656c50617468710e580d000000636c656f2f707269342e706e67710f580500000077686572657110580e0000006265666f7265486561646c696e6571115807000000796f666673657471124b005807000000786f666673657471134b0258040000007870616471144b0158020000006f6e71155805000000766e6f646571165808000000636c656f49636f6e71175801000000317118756175732e"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh></v>
</v>
<v t="swot.20241022122122.1"><vh>xml 标签 &lt;set&gt;</vh>
<v t="swot.20241022163517.1"><vh>EmpMapper.java: 之前有 bug 的 sql</vh>
<v t="swot.20241019141143.1"></v>
</v>
<v t="swot.20241022163550.1"><vh>EmpMapper.java: 使用 xml 后删除 sql</vh>
<v t="swot.20241022130715.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh>
<v t="swot.20241022130715.2"><vh>@ignore-node others</vh></v>
</v>
</v>
<v t="swot.20241022163613.1"><vh>EmpMapper.xml: 增加 &lt;if&gt; 标签后的 xml</vh>
<v t="swot.20241022131317.1"><vh>#file src/main/resources/com/tjise/mapper/EmpMapper.xml</vh>
<v t="swot.20241022131317.2"><vh>@ignore-node others</vh></v>
</v>
</v>
<v t="swot.20241022163949.1"><vh>测试所有字段正常</vh>
<v t="swot.20241022135842.1"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh></v>
</v>
<v t="swot.20241022164047.1"><vh>测试部分字段错误</vh>
<v t="swot.20241022164110.1"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh></v>
</v>
<v t="swot.20241022164652.1"><vh>EmpMapper.xml: 使用 &lt;set&gt; 标签解决</vh>
<v t="swot.20241022162857.1"><vh>#file src/main/resources/com/tjise/mapper/EmpMapper.xml</vh>
<v t="swot.20241022162857.2"><vh>@ignore-node others</vh></v>
</v>
</v>
<v t="swot.20241022164758.1"><vh>测试部分字段正确</vh>
<v t="swot.20241022164758.2"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh></v>
</v>
</v>
<v t="swot.20241022162213.1"><vh>xml 标签 &lt;foreach&gt;</vh>
<v t="swot.20241022173912.1"><vh>#file src/main/java/com/tjise/mapper/EmpMapper.java</vh>
<v t="swot.20241022173912.2"><vh>@ignore-node others</vh></v>
</v>
<v t="swot.20241022174234.1"><vh>#file src/main/resources/com/tjise/mapper/EmpMapper.xml</vh>
<v t="swot.20241022174234.2"><vh>@ignore-node others</vh></v>
</v>
<v t="swot.20241022222115.1"><vh>#file src/test/java/com/tjise/MybatisQuickstartCrudApplicationTests.java</vh></v>
</v>
<v t="swot.20241022170331.1"><vh>xml 标签 &lt;sql&gt;&lt;include&gt;</vh>
<v t="swot.20241022231327.1"><vh>#file src/main/resources/com/tjise/mapper/EmpMapper.xml</vh>
<v t="swot.20241022231327.2"><vh>@ignore-node others</vh></v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="swot.20241011155227.9">@language asciidoc
1. 解压下载的 Spring Boot 代码，如 hello-spring-boot.zip，可以发现就是一个 Maven 模块的目录结构。
+
image::img/hello-spring-boot-unzip.png[,640]

2. 使用 IDEA 导入 hello-spring-boot 模块

* 进入 File -&gt; Project Structure 对话框，选择 Modules
* 点击 `+` 号，选择要导入的模块目录，如 hello-spring-boot
+
image::img/import_module_0.png[,400]

3. 在导入时有两个选项：

* Create module from existing sources（从现有源创建模块）用于导入没有使用构建工具如 maven 的项目
* Import module from external model（从外部模型导入模块）用于导入使用构建工具如 maven 创建的项目。因为我们是用 maven 来管理代码的，所以选择 `Import module from external model`
+
[.thumb]
image::img/import_module_1.png[,640]

4. 然后会看见 IDEA 自动安装了依赖。

5. 更改 hello-spring-boot 中的 pom.xml 文件中的 Spring Boot 和 JDK 版本号。
+
[source,xml,linenums,highlight=4;8]
----
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.7.18&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
&lt;properties&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
&lt;/properties&gt;
----</t>
<t tx="swot.20241013133847.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc:
:toc: right
:toc-title: 目录
:toclevels: 3
</t>
<t tx="swot.20241013133847.10">@language asciidoc
对于持久层，我们可以使用包名 dao，但是以后建议使用 mapper。

创建包 dao，并在其中创建接口 UserMapper，我们以取数据库表 user 中的所有记录为例，代码如下：
</t>
<t tx="swot.20241013133847.11">@language asciidoc
</t>
<t tx="swot.20241013133847.12">@language asciidoc
JDBC (Java DataBase Connectivity) 是使用 Java 语言操作关系型数据库的一套 API。

[caption=]
.JDBC 定义了接口
[cols="1,1,1",options="header"]
|===
|程序                   |接口规范抽象方法             |各厂商实现类(驱动)
.4+^.^|Java 代码调用 -&gt;  .4+^.^|JDBC Interface -&gt;    |MySQL
                                                   |ORACLE
                                                   |SQLServer
                                                   |...
|===


* JDBC 是 sun 公司官方定义的一套操作所有关系型数据库的规范，即接口。
* 各个数据库厂商去实现这套接口，提供数据库驱动 jar 包。
* 我们可以使用这套接口(JDBC)编程，真正执行的代码是驱动 jar 包中的实现类 *(面向对象中多态的应用)*。
</t>
<t tx="swot.20241013133847.13">@language asciidoc
数据库连接池是个容器，负责分配、管理数据库连接(Connection)。

* 资源重用，提升系统响应速度：它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。
* 避免数据库连接遗漏：如果数据库连接没有及时释放，那么会在数据连接池中获取其他可用的连接。

常用数据库连接池：

* Druid 阿里巴巴的德鲁伊。
* Hikari(追光者)，是 Spring Boot 默认的。
+
image::img/default_HikariPool.png[]

***
*切换 Druid 数据库连接池*

官方地址: https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter

.pom.xml 增加 Druid 依赖
[source,xml]
----
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.2.23&lt;/version&gt;
&lt;/dependency&gt;
----

.编写 application.properties (##可选操作，如果不成功就加上这4行##)
[source,properties]
----
# cj 表示支持高版本 mysql8
spring.datasource.druid.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.druid.url=jdbc:mysql://localhost:3306/mybatis_db
spring.datasource.druid.username=root
spring.datasource.druid.password=root
----

.使用 Druid 数据库连接池成功
image::img/useDruidPool.png[]
</t>
<t tx="swot.20241013133847.14">@language asciidoc
Lombok是一个实用的java工具包，可以通过简单的注解来简化和消除一些必须有但显得很臃肿的Java代码。

[caption=]
.lombok 注解说明 (红色的常用)
[cols="1,3",options="header",stripes=even]
|===
|注解             	    |作用
|@Getter/@Setter      |为所有的属性提供 get/set方法
|@ToString	           |会给类自动生成易阅读的 toString 方法
|@EqualsAndHashCode	  |根据类所拥有的非静态字段自动重写 equals 方法和 hashCode 方法
|[red]#@Data#	                |提供了更综合的生成代码功能（@Getter + @Setter + @ToString + @EqualsAndHashCode）
|[red]#@NoArgsConstructor#   |为实体类生成无参的构造器方法
|[red]#@AllArgsConstructor#	 |为实体类生成除了 static 修饰的字段之外带有各参数的构造器方法。
|===

.pom.xml 增加依赖 lombok
[source,xml]
----
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
&lt;/dependency&gt;
----

Lombok 依赖会在编译时，自动生成对应的 java 代码。在使用 lombok 时，还需要安装一个 IDEA's lombok 插件。

image::img/plugin_lombok.png[,800]

NOTE: 如果使用 Lombok 依赖而没有安装 IDEA 的 Lombok 插件，IDE 可能无法识别 Lombok 的注解，导致代码看起来像是缺失 getter/setter 等方法，尽管它们在编译时会正常生成。因此，安装这个插件是为了确保 Lombok 注解在开发过程中能够被 IDEA 正确识别和处理。

我们可以使用 lombok 依赖简化前面创建的实体类 pojo/User.java，简化后的代码如下，
同时执行单元测试 class MybatisQuickstartApplicationTests -&gt; public void testListUser() 正常通过。
</t>
<t tx="swot.20241013133847.16">
++++
&lt;button id="toggleButton"&gt;目录&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++

</t>
<t tx="swot.20241013133847.2">@language asciidoc

++++
&lt;button id="toggleButton"&gt;目录&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++

</t>
<t tx="swot.20241013133847.4">使用 https://start.spring.io/ 创建 Spring Boot 工程，如下所示。

注：给工程命名为 mybatis-quickstart，在创建工程时选择 mybatis 起步依赖、mysql 驱动包依赖。

image::img/mybatis_quickstart.png[]

*下面引用之前学过的文档内容，请注意项目名称更改为 mybatis-quickstart.zip 即可。*
</t>
<t tx="swot.20241013133847.7">@language asciidoc
创建用户表时最好选择 utf8 中文，这样可以避免中文乱码问题。

[source,sql]
----
create database mybatis_db character set 'utf8';
use mybatis_db;

create table user
(
    id      int unsigned primary key auto_increment comment 'ID',
    name    varchar(100) comment '姓名',
    age     tinyint unsigned comment '年龄',
    gender  tinyint unsigned comment '性别, 1:男, 2:女',
    phone   varchar(11)      comment '手机号'
) comment '用户表';

INSERT INTO user (id, name, age, gender, phone)
VALUES
    (null, '白眉鹰王', 55, '1', '18900000000'),
    (null, '金毛狮王', 45, '1', '18900000001'),
    (null, '青翼蝠王', 38, '1', '18900000002'),
    (null, '紫衫龙王', 42, '2', '18800000003'),
    (null, '光明左使', 37, '1', '18800000004'),
    (null, '光明右使', 48, '1', '18800000005');
----

////
macos 启动 mysql
&gt; sudo /usr/local/mysql/support-files/mysql.server start
Password:
Starting MySQL
... SUCCESS!
////

</t>
<t tx="swot.20241013133847.8">@language asciidoc
1. 实体类应该放在包 pojo 中，所以创建包 com.tjise.pojo

2. 在包 pojo 中创建实体类 User

</t>
<t tx="swot.20241013133847.9">配置数据库连接信息。
</t>
<t tx="swot.20241013175526.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.pojo;

public class User {
//  private int id;      // 因为 int 默认值是 0, 但是数据库中 int 默认为 null
    private Integer id;  // 所以为了对应，建议此处用 Integer
    private String name;
    private Integer age;
    private Integer gender;
    private String phone;

    public User() {
    }

    public User(Integer id, String name, Integer age, Integer gender, String phone) {
        this.id = id;
        this.name = name;
        this.age = age;
        this.gender = gender;
        this.phone = phone;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Integer getGender() {
        return gender;
    }

    public void setGender(Integer gender) {
        this.gender = gender;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", age=" + age +
                ", gender=" + gender +
                ", phone='" + phone + '\'' +
                '}';
    }
}
@doc
----
</t>
<t tx="swot.20241013185549.1">@language python
@doc
[source,properties,linenums]
----
@c
spring.application.name=mybatis-quickstart

# 配置文件行最后不能有空格

# 驱动类名称
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
# 数据库连接的 url
spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_db
# 连接数据库的用户名
spring.datasource.username=root
# 连接数据库的密码
spring.datasource.password=root
@doc
----
</t>
<t tx="swot.20241013192152.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.dao;

import com.tjise.pojo.User;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;

/* Mapper 注解
    1. 让此接口被 mybatis 框架识别
    2. Spring Boot 会自动创建此接口的实现类对象，交给 IOC 容器管理
*/

@Mapper
public interface UserMapper {
    // 抽象方法
    @Select("select * from user")
    public abstract List&lt;User&gt; listUser();
}
@doc
----
</t>
<t tx="swot.20241013192859.1">@language java
@doc
.单元测试代码
[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.dao.UserMapper;
import com.tjise.pojo.User;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;

@SpringBootTest
class MybatisQuickstartApplicationTests {

    @Autowired        // 此依赖注入功能为取 IOC 容器中 UserMapper 类型的对象
    private UserMapper userMapper;

    @Test
    public void testListUser() {
        List&lt;User&gt; list = userMapper.listUser();
        for (User user : list) {
            System.out.println(user);
        }
    }
}
@doc
----

.运行单元测试结果如下
....
User{id=1, name='白眉鹰王', age=55, gender=1, phone='18900000000'}
User{id=2, name='金毛狮王', age=45, gender=1, phone='18900000001'}
User{id=3, name='青翼蝠王', age=38, gender=1, phone='18900000002'}
User{id=4, name='紫衫龙王', age=42, gender=2, phone='18800000003'}
User{id=5, name='光明左使', age=37, gender=1, phone='18800000004'}
User{id=6, name='光明右使', age=48, gender=1, phone='18800000005'}
....
</t>
<t tx="swot.20241013223431.1">@language asciidoc
.将 mbatis 依赖的版本调整为支持 JDK1.8，然后刷新 Maven。
[source,xml,linenums,highlight=4;10]
----
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.3.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter-test&lt;/artifactId&gt;
    &lt;version&gt;2.3.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
----

</t>
<t tx="swot.20241014120257.1">@language asciidoc
文件 application.properties 默认的编码是 ISO-8859-1，这样在写中文的时候会出现乱码问题，按照下图设置为 UTF-8 编码即可。

.src/main/resources/application.properties 文件乱码解决方法
image::img/application.properties_gibberish.png[,900]

</t>
<t tx="swot.20241015083350.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc: right
:toc-title: 目录
:toclevels: 3

</t>
<t tx="swot.20241015083350.10">@language java
@doc
[source,java,linenums]
----
@c
@RequestMapping("/simpleParamOld")
public String simpleParamOld(HttpServletRequest request,
                             HttpServletResponse response)
{
    String name = request.getParameter("name");
    String age  = request.getParameter("age");
    System.out.println(name + " : " + age);
    return "ok";
}
@doc
----

使用 httpie 测试：

http "http://localhost:8080/simpleParamOld?name=Swot&amp;age=19"

NOTE:  只能获取 url 携带的参数。
</t>
<t tx="swot.20241015083350.11">@doc
[source,java,linenums]
----
@c
@language java
@RequestMapping("/simpleParam1")
public String simpleParam1(String name, Integer age) {
    System.out.println(name + " : " + age);
    return "ok";
}
@language asciidoc
@doc
----

注意事项:

. 前端请求参数名与形参变量名相同，定义形参即可接收数据
    * 如前端请求 http://localhost:8080/simpleParam1/?name=王林&amp;age=400
    * url 中的 name 对应形参 String name，age  对应形参 Integer age

. 参数类型可以自动类型转换，基本类型需要使用包装类类型接收
    * age 网上传过来的是 String，现在已经是 Integer 类型了
    * Integer 是包装类类型

. 如果前端请求参数名与方法形参名称不一致，可以使用 @RequestParam 完成映射
    * 参下面 @RequestParam 例子

此方法可获取 get 方法 url 携带的参数（如上面的 url）或者 post 方法 body 使用 x-www-form-urlencoded 形式携带的参数。

body 中发送 http://localhost:8080/simpleParam1 选择 x-www-form-urlencoded 类型的数据如下图所示

image::img/request_simple_param_post_body1.png[]

.使用 httpie 测试
[source,console]
----
http --form POST localhost:8080/simpleParam1 \
  name="王林" \
  age="400"
----
</t>
<t tx="swot.20241015083350.12">@language java
@doc
[source,java,linenums]
----
@c
@RequestMapping("/simpleParam2")
public String simpleParam2(@RequestParam("username") String name,
                           Integer age) {
    System.out.println(name + " : " + age);
    return "ok";
}
@doc
----

如果前端请求参数名与方法形参名称不一致，可以使用 @RequestParam 完成映射

    * 如前端请求 http://localhost:8080/simpleParam2/?username=韩立&amp;age=2000
    * username 的内容会被 name 接收到

.使用 httpie 测试
[source,console]
----
http "http://localhost:8080/simpleParam2/?username=韩立&amp;age=2000"
----
</t>
<t tx="swot.20241015083350.13">@language java
@doc
1. 创建包 pojo，User 实体类放在包 pojo 中，参 pojo/User.java
    * POJO: 在 Java 中，POJO 是 Plain Old Java Object 的缩写，意为简单的 Java 对象。它指的是一个普通的没有任何特殊要求或依赖的 Java 类，通常用来作为实体类来封装数据。POJO 类并不继承特定的父类，也不需要实现特定的接口，因此保持了很大的自由度和简单性。

2. 前端传入参数名与 User 属性名相同
    * 访问 url: http://localhost:8080/simplePojo/?name=韩立&amp;age=2000
    * 服务器打印数据: `User{name='韩立', age=2000}`

[source,java,linenums]
----
@c
@RequestMapping("/simplePojo")
public String simplePojo(User user) {
    System.out.println(user);
    return "ok";
}
@doc
----
</t>
<t tx="swot.20241015083350.14">@language java
@doc
. 请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套 POJO 属性参数。
    * popo/Uesr.java 包含三个属性 user, name, address （address 对应 Address.java）
    * popo/Address.java 包含两个属性 province, city

. 前端传入参数名与 User 属性名相同
    * 访问 url: http://localhost:8080/complexPojo/?name=韩立&amp;age=2000&amp;address.province=河北&amp;address.city=张家口
    * 服务器打印数据: `User{name='韩立', age=2000, address=Address{province='河北', city='张家口'}}`

[source,java,linenums]
----
@c
@RequestMapping("/complexPojo")
public String complexPojo(User user) {
    System.out.println(user);
    return "ok";
}
@doc
----
</t>
<t tx="swot.20241015083350.15">@doc
数组参数：请求参数为多个且参数的键是相同的，定义数组类型形参即可接收参数。

访问 url: http://localhost:8080/arrayParam?state=绝情&amp;state=安逸&amp;state=岁月

****
state 取自 state of mind 翻译为意境，《仙逆》中王林体验的三种化神意境，分别为绝情之境、安逸之境、岁月之境。
****

[source,java,linenums]
----
@c
@language java
@RequestMapping("/arrayParam")
public String arrayParam(String[] state) {
    System.out.println(Arrays.toString(state));
    return "ok";
}
@doc
----
</t>
<t tx="swot.20241015083350.16">@doc
集合参数：请求参数为多个且参数的键是相同的，定义集合类型形参接收并使用 @RequestParam 绑定参数关系。

访问 url: http://localhost:8080/listParam?state=绝情&amp;state=安逸&amp;state=岁月

****
state 取自 state of mind 翻译为意境，《仙逆》中王林体验的三种化神意境，分别为绝情之境、安逸之境、岁月之境。
****

[source,java,linenums]
----
@c
@language java
@RequestMapping("/listParam")
public String listParam(@RequestParam List&lt;String&gt; state) {
    System.out.println(state);  // Spring Boot 默认使用 ArrayList 实现类
    return "ok";
}
@doc
----
</t>
<t tx="swot.20241015083350.17">@doc
日期参数: 前端请求的参数是一个日期，使用日期参数接收且使用 @DateTimeFormat 注解完成日期参数格式转换。

访问url: http://localhost:8080/dateParam?updateTime=2024-10-08 19:19:19
[source,java,linenums]
----
@c
@language java
@RequestMapping("/dateParam")
public String dateParam(@DateTimeFormat(pattern="yyyy-MM-dd HH:mm:ss") LocalDateTime updateTime) {

    System.out.println(updateTime);
    return "ok";
}
@doc
----

打印结果是 `2024-10-08T19:19:19` 是 **ISO 8601** 格式的日期时间表示法，具体来说是 **`LocalDateTime`** 类型的标准字符串输出。

解释::
- **`2024-10-08`**：表示日期（年-月-日）。
- **`T`**：是日期和时间的分隔符，在 ISO 8601 标准中使用。
- **`19:19:19`**：表示时间（时:分:秒）。

Spring Boot 的 `LocalDateTime` 类型在进行 `toString()` 时会自动按照这种 ISO 8601 格式进行输出。所以，打印出来的结果是 `LocalDateTime` 默认的输出格式。

这个格式不包含时区信息，仅仅表示日期和时间。
</t>
<t tx="swot.20241015083350.18">@doc
1. 请求参数是 JSON 数据，使用 POJO 类型接收参数。
2. 需使用 @RequestBody 标识形参

.获取 json 数据
[source,java,linenums]
----
@c
@language java
@RequestMapping("/jsonParam")
public String jsonParam(@RequestBody User user) {
    System.out.println(user);  // &lt;1&gt;
    return "ok";
}
@doc
----

.Postman 使用 POST 方法访问 url: http://localhost:8080/jsonParam 提交 body 中的 json
[source,json]
----
{
    "name": "王林",
    "age": 400,
    "address": {
        "province": "赵国",
        "city": "夔牛镇"
    }
}
----

&lt;1&gt; 后端打印结果为
+
....
User{name='王林', age=400, address=Address{province='赵国', city='夔牛镇'}}
....


.httpie 测试
[source,console]
----
http -v POST http://localhost:8080/jsonParam \
  name="王林" \
  age:=400 \
  address:='{"province": "赵国", "city": "夔牛镇"}'
----
</t>
<t tx="swot.20241015083350.19">@doc
1. 参数在 url 路径中
2. 需使用 {变量名} 标识该路径参数
3. 需要使用 @PathVariable 获取路径参数

Postman 访问 url: http://localhost:8080/pathParam/19 (RESTful风格的单条记录处理方式)

.获取路径参数
[source,java,linenums]
----
@c
@language java
@RequestMapping("/pathParam/{id}")
public String pathParam(@PathVariable Integer id) {
    System.out.println(id);  // 19
    return "ok";
}
@doc
----


.扩展多个路径参数举例
====
Postman 访问 url: http://localhost:8080/pathParam/19/李慕婉

[source,java,linenums]
----
@c
@language java
@RequestMapping("/pathParam/{id}/{girl}")
public String pathParam(@PathVariable Integer id,
                        @PathVariable String girl)
{
    System.out.println(id);    // 19
    System.out.println(girl);  // 李慕婉
    return "ok";
}
@doc
----
====
</t>
<t tx="swot.20241015083350.2">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20241015083350.20">这是上面案例演示需要的实体类代码。
</t>
<t tx="swot.20241015083350.21">@language java
@doc
只包含两个属性 name &amp; age，为了演示简单实体对象参数的获取。

[source,java,linenums]
----
@c
package com.tjise.pojo;

public class User {
    private String name;
    private int age;

    public User() {
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
@doc
----
</t>
<t tx="swot.20241015083350.22">@language java
@doc
改造成包含三个属性 name &amp; age &amp; address，为了演示复杂实体对象参数的获取。

[source,java,linenums]
----
@c
package com.tjise.pojo;

public class User {
    private String name;
    private int age;
    private Address address;

    public User() {
    }

    public User(String name, int age, Address address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public Address getAddress() {
        return address;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", address=" + address +
                '}';
    }
}
@doc
----
</t>
<t tx="swot.20241015083350.23">@language java
@doc
.会被 User.java 使用
[source,java,linenums]
----
@c
package com.tjise.pojo;

public class Address {
    private String province;
    private String city;

    public Address() {
    }

    public Address(String city, String province) {
        this.city = city;
        this.province = province;
    }

    public String getProvince() {
        return province;
    }

    public void setProvince(String province) {
        this.province = province;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    @Override
    public String toString() {
        return "Address{" +
                "province='" + province + '\'' +
                ", city='" + city + '\'' +
                '}';
    }
}
@doc
----
</t>
<t tx="swot.20241015083350.3"></t>
<t tx="swot.20241015083350.4">@language asciidoc
由美国 Postman, Inc. 公司开发的老牌工具
https://www.postman.com/

1. 注册帐号

2. Create Workspace

3. Create Collection

4. Create Request (创建您自己的请求)
</t>
<t tx="swot.20241015083350.5">@language asciidoc
https://apifox.com/
</t>
<t tx="swot.20241015083350.6">@language asciidoc
https://www.apipost.cn/
</t>
<t tx="swot.20241015083350.7">@language asciidoc
具体操作参考前面的快速入门内容。

1. 可以在 https://start.spring.io/ 创建新的模块，也可以复制之前已经创建的模块目录。#最好新创建，复制后需要更改不少设置。#
* 模块名为 spring-boot-request-response

2. 更改 pom.xml 文件中的 Spring Boot 和 JDK 版本号（如果不是自己想要的版本号的话）。

3. 导入模块到项目中
* 进入 File -&gt; Project Structure 对话框，选择 Modules
* 点击 `+` 号，选择要导入的模块目录，如 spring-boot-request-response

</t>
<t tx="swot.20241015083350.8">
</t>
<t tx="swot.20241015083350.9">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.controller;

// import 都是下面例子用到的时候逐个导入的
import com.tjise.pojo.User;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

@RestController
public class RequestController {
    // @others 伪代码表示此处还会有很多具体的代码
    @others
}
@doc
----
</t>
<t tx="swot.20241015110533.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
//  private int id;      // 因为 int 默认值是 0, 但是数据库中 int 默认为 null
    private Integer id;  // 所以为了对应，建议此处用 Integer
    private String name;
    private Integer age;
    private Integer gender;
    private String phone;
}
@doc
----

.单元测试通过，说明 lombok 的注解生效了
....
User(id=1, name=白眉鹰王, age=55, gender=1, phone=18900000000)
User(id=2, name=金毛狮王, age=45, gender=1, phone=18900000001)
User(id=3, name=青翼蝠王, age=38, gender=1, phone=18900000002)
User(id=4, name=紫衫龙王, age=42, gender=2, phone=18800000003)
User(id=5, name=光明左使, age=37, gender=1, phone=18800000004)
User(id=6, name=光明右使, age=48, gender=1, phone=18800000005)
....</t>
<t tx="swot.20241015113043.1">@language asciidoc
使用 https://start.spring.io/ 创建 Spring Boot 工程，如下所示。

注：给工程命名为 mybatis-quickstart-crud，在创建工程时选择对应的起步依赖 mybatis, mysql, lombok。

image::img/mybatis_quickstart_crud_initializr.png[]

*下面引用之前学过的文档内容，请注意项目名称更改为 mybatis-quickstart-crud.zip 即可*
</t>
<t tx="swot.20241015114619.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc:
:toc: right
:toc-title: 目录
:toclevels: 3
:doctype: book


++++
&lt;button id="toggleButton"&gt;目录&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20241015114654.1"></t>
<t tx="swot.20241015140346.1">配置数据库连接信息。
</t>
<t tx="swot.20241015140346.2">@language python
@doc
[source,properties,linenums]
----
@c
spring.application.name=mybatis_quickstart-crud

# 配置文件行最后不能有空格

# 驱动类名称
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
# 数据库连接的 url
spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_db
# 连接数据库的用户名
spring.datasource.username=root
# 连接数据库的密码
spring.datasource.password=root
@doc
----
</t>
<t tx="swot.20241015140945.1">@language asciidoc
.在数据库管理软件中执行命令
[source,sql,linenums]
----
use mybatis_db;

create table emp (
  id          int unsigned primary key auto_increment comment 'ID',
  username    varchar(20) not null unique comment '用户名',
  password    varchar(32) default '123456' comment '密码',
  name        varchar(10) not null comment '姓名',
  gender      tinyint unsigned not null comment '性别, 说明: 1 男, 2 女',
  image       varchar(300) comment '图像',
  job         tinyint unsigned comment '职位, 说明: 1班主任, 2讲师, 3学工主管, 4教研主管, 5咨询师',
  entrydate   date comment '入职时间',
  dept_id     int unsigned comment '部门ID',
  create_time datetime not null comment '创建时间',
  update_time datetime not null comment '修改时间'
) comment='员工表';
----
</t>
<t tx="swot.20241015141007.1">@language asciidoc
创建 pojo 包，在包里创建 Emp.java 实体类。

实体类属性采用小驼峰命名模式，可能会与数据库中字段的命名方式不同，以后会讲解如何处理该问题。

</t>
<t tx="swot.20241015154730.1">@language asciidoc
删除记录的 SQL 语句::
    delete from 表名 where id = id值; +
    delete from emp where id = 15;
</t>
<t tx="swot.20241015155338.1">@language asciidoc
创建包 mapper (和以前的 dao 的含义是一样的，只是 Spring Boot 项目习惯使用 mapper 而已)，在包中创建接口 EmpMapper.java
</t>
<t tx="swot.20241015161423.1">@language asciidoc
.在数据库管理软件中执行命令
[source,sql,linenums]
----
INSERT INTO emp
(id, username, password, name, gender, image, job, entrydate,dept_id, create_time, update_time) VALUES
( 1 ,'jinyong'    ,'123456' ,'金庸'   , 1  ,'1.jpg'  , 4  ,'2000-01-01', 2  , now() , now()),
( 2 ,'zhangwuji'  ,'123456' ,'张无忌' , 1  ,'2.jpg'  , 2  ,'2015-01-01', 2  , now() , now()),
( 3 ,'yangxiao'   ,'123456' ,'杨逍'   , 1  ,'3.jpg'  , 2  ,'2008-05-01', 2  , now() , now()),
( 4 ,'weiyixiao'  ,'123456' ,'韦一笑' , 1  ,'4.jpg'  , 2  ,'2007-01-01', 2  , now() , now()),
( 5 ,'changyuchun','123456' ,'常遇春' , 1  ,'5.jpg'  , 2  ,'2012-12-05', 2  , now() , now()),
( 6 ,'xiaozhao'   ,'123456' ,'小昭'   , 2  ,'6.jpg'  , 3  ,'2013-09-05', 1  , now() , now()),
( 7 ,'jixiaofu'   ,'123456' ,'纪晓芙' , 2  ,'7.jpg'  , 1  ,'2005-08-01', 1  , now() , now()),
( 8 ,'zhouzhiruo' ,'123456' ,'周芷若' , 2  ,'8.jpg'  , 1  ,'2014-11-09', 1  , now() , now()),
( 9 ,'dingminjun' ,'123456' ,'丁敏君' , 2  ,'9.jpg'  , 1  ,'2011-03-11', 1  , now() , now()),
(10 ,'zhaomin'    ,'123456' ,'赵敏'   , 2  ,'10.jpg' , 1  ,'2013-09-05', 1  , now() , now()),
(11 ,'luzhangke'  ,'123456' ,'鹿杖客' , 1  ,'11.jpg' , 5  ,'2007-02-01', 3  , now() , now()),
(12 ,'hebiweng'   ,'123456' ,'鹤笔翁' , 1  ,'12.jpg' , 5  ,'2008-08-18', 3  , now() , now()),
(13 ,'fangdongbai','123456' ,'方东白' , 1  ,'13.jpg' , 5  ,'2012-11-01', 3  , now() , now()),
(14 ,'zhangsanfeng','123456','张三丰' , 1  ,'14.jpg' , 2  ,'2002-08-01', 2  , now() , now()),
(15 ,'yulianzhou' ,'123456' ,'俞莲舟' , 1  ,'15.jpg' , 2  ,'2011-05-01', 2  , now() , now()),
(16 ,'songyuanqiao','123456','宋远桥' , 1  ,'16.jpg' , 2  ,'2010-01-01', 2  , now() , now()),
(17 ,'chenyouliang','123456','陈友谅' , 1  ,'17.jpg' ,NULL,'2015-03-21',NULL , now(), now());
----</t>
<t tx="swot.20241015171320.1">@language java
@doc
[source,java,linenums,highlight=22..24]
----
@c
package com.tjise.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Emp {
    private Integer id;
    private String username;
    private String password;
    private String name;
    private Short gender;
    private String image;
    private Short job;
    private LocalDate entrydate;
    private Integer deptId;     // 这里三行采用了小驼峰命名，数据库中一般为下划线命名方式
    private LocalDateTime createTime;   // 后面会学如何处理这种不对应的问题
    private LocalDateTime updateTime;
}
@doc
----</t>
<t tx="swot.20241015172918.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.mapper;

import org.apache.ibatis.annotations.Mapper;

/* Mapper 注解
    1. 让此接口被 mybatis 框架识别
    2. Spring Boot 会自动创建此接口的实现类对象，交给 IOC 容器管理
*/

@Mapper
public interface EmpMapper {

}
@doc
----</t>
<t tx="swot.20241016134143.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc:
:toc: right
:toc-title: 目录
:toclevels: 3</t>
<t tx="swot.20241016134143.14">给 Result.java 封装一个静态方法 success，以减少代码的书写。
</t>
<t tx="swot.20241016134143.15">@language java
@doc
.Result.java 新增静态方法 success
[source,java,linenums,highlight=8..11]
----
@c
package com.tjise.pojo;

public class Result {
    private Integer code;   //  响应码: 1 成功，0 失败
    private String msg;     // 响应码描述字符串
    private Object data;    // 返回数据

    // 新增静态方法 success
    public static Result success(Object data) {  // &lt;1&gt;
        return new Result(1, "success", data);
    }

    // @others 表示省略显示构造方法和 getter &amp; setter
    @others
}
@doc
----

&lt;1&gt; Object 是所有类型的父类，因为我们不知道 data 会是什么样的数据，所以此处用 Object 来声明形参变量 data。
</t>
<t tx="swot.20241016134143.16">public Result() {}

public Result(Integer code, String msg, Object data) {
    this.code = code;
    this.msg = msg;
    this.data = data;
}

public Integer getCode() {
    return code;
}

public void setCode(Integer code) {
    this.code = code;
}

public String getMsg() {
    return msg;
}

public void setMsg(String msg) {
    this.msg = msg;
}

public Object getData() {
    return data;
}

public void setData(Object data) {
    this.data = data;
}

@Override
public String toString() {
    return "Result{" +
            "code=" + code +
            ", msg='" + msg + '\'' +
            ", data=" + data +
            '}';
}
</t>
<t tx="swot.20241016134143.17">@language java
@doc
.使用 Result 改造后的代码
[source,java,linenums]
----
@c
package com.tjise.controller;

import com.tjise.pojo.Result;
import com.tjise.pojo.User;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.List;

// 已经包含 @ResponseBody 注解
@RestController
public class ResponseController {
    // 此处用 @others 表示还有很多代码
    @others
}
@doc
----
</t>
<t tx="swot.20241016134143.18">@doc
.使用 Result 封装响应数据
[source,java,linenums,highlight=5]
----
@language java
@c
@RequestMapping("/hello")
public Result hello(){
    System.out.println("Hello World!");
    // Result result = new Result(1, "success", "Hello World!");
    return Result.success("Hello World!");  // 调用静态方法 success
}
@doc
----

.访问 http://localhost:8080/hello
....
{
    "code": 1,
    "msg": "success",
    "data": "Hello World!"
}
....
</t>
<t tx="swot.20241016134143.19">@doc
.使用 Result 封装响应数据
[source,java,linenums,highlight=11]
----
@language java
@c
@RequestMapping("/getUser")
public Result getUser(){

    // User user = new User("王林", 400, null);
    User user = new User();
    user.setName("王林");
    user.setAge(400);

    System.out.println(user);
    // return new Result(1, "success", user);
    return Result.success(user);  // 调用静态方法 success
}
@doc
----

.访问 http://localhost:8080/getUser
....
{
    "code": 1,
    "msg": "success",
    "data": {
        "name": "王林",
        "age": 400,
        "address": null
    }
}
....
</t>
<t tx="swot.20241016134143.2">
++++
&lt;button id="toggleButton"&gt;目录&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20241016134143.20">@doc
.使用 Result 封装响应数据
[source,java,linenums,highlight=12]
----
@language java
@c
@RequestMapping("/getList")
public Result getList(){
    User user = new User();
    user.setName("王林");
    user.setAge(400);

    List&lt;User&gt; list = new ArrayList&lt;&gt;();
    list.add(user);

    System.out.println(list);
    // return new Result(1, "susscess", list);
    return Result.success(list);  // 调用静态方法 success
}
@doc
----

.访问 http://localhost:8080/getList
....
{
    "code": 1,
    "msg": "susscess",
    "data": [
        {
            "name": "王林",
            "age": 400,
            "address": null
        }
    ]
}
....
</t>
<t tx="swot.20241016134143.3">位置：属于方法注解、类注解，使用在控制器方法上/类上。

作用：将当前方法返回值直接返回

* 如果是 String 返回 String
* 如果是实体/集合，则转换为 JSON 返回

IMPORTANT: [red]#*@RestController 注解已经包含了 @ResponseBody 的作用，所以无需额外再添加 @ResponseBody*#

</t>
<t tx="swot.20241016134143.4">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.controller;

import com.tjise.pojo.User;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.List;

// 已经包含 @ResponseBody 注解
@RestController
public class ResponseController {
    // 此处用 @others 表示还有很多代码
    @others
}
@doc
----
</t>
<t tx="swot.20241016134143.5">@doc
[source,java,linenums]
----
@language java
@c
@RequestMapping("/hello")
public String hello(){
    System.out.println("Hello World!");
    return "Hello World!";
}
@doc
----

使用 httpie 测试 api

    http :8080/hello

</t>
<t tx="swot.20241016134143.6">@doc
[source,java,linenums]
----
@language java
@c
@RequestMapping("/getUser")
public User getUser(){
    // User user = new User("王林", 400, null);
    User user = new User();
    user.setName("王林");
    user.setAge(400);
    System.out.println(user);
    return user;
}
@doc
----

使用 httpie 测试 api

    http -v :8080/getUser

.访问 http://localhost:8080/getUser
....
{
    "name": "王林",
    "age": 400,
    "address": null
}
....
</t>
<t tx="swot.20241016134143.7">@doc
[source,java,linenums]
----
@language java
@c
@RequestMapping("/getList")
public List&lt;User&gt; getList(){
    User user = new User();
    user.setName("王林");
    user.setAge(400);

    List&lt;User&gt; list = new ArrayList&lt;&gt;();
    list.add(user);

    System.out.println(list);
    return list;
}
@doc
----

使用 httpie 测试 api

    http -v :8080/getList


.访问 http://localhost:8080/getList
....
[
    {
        "name": "王林",
        "age": 400,
        "address": null
    }
]
....
</t>
<t tx="swot.20241016134143.8">@doc
对以上代码进行改造，使用统一响应结果 Result 类。
</t>
<t tx="swot.20241016134143.9">@language java
@doc
.定义返回数据的实体类 Result 的基本功能
[source,java,linenums]
----
@c
package com.tjise.pojo;

public class Result {

    //  响应码: 1 成功，0 失败
    private Integer code;
    // 响应码描述字符串
    private String msg;
    // 返回 Object 类型的数据
    private Object data;

    public Result() {
    }

    public Result(Integer code, String msg, Object data) {
        this.code = code;
        this.msg = msg;
        this.data = data;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    @Override
    public String toString() {
        return "Result{" +
                "code=" + code +
                ", msg='" + msg + '\'' +
                ", data=" + data +
                '}';
    }
}
@doc
----
</t>
<t tx="swot.20241016160357.1">@language java
@doc
删除记录接口方法如下

[source,java,linenums]
----
@c
package com.tjise.mapper;

import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Mapper;

/* Mapper 注解
    1. 让此接口被 mybatis 框架识别
    2. Spring Boot 会自动创建此接口的实现类对象，交给 IOC 容器管理
*/

@Mapper
public interface EmpMapper {

    @Delete("delete from emp where id = #{id}")  // &lt;1&gt;
    public abstract void deleteEmpById(Integer id);
}
@doc
----

&lt;1&gt; 如果 mapper 接口方法形参只有一个普通类型的参数，\#{...} 里面的属性名可以随便写，如: #{id}、#{value}。
+
*但是在实际开发中，我们还是要见名思意，不要随便起名字。*

</t>
<t tx="swot.20241016162731.1">@language asciidoc
预编译的 SQL，有两个优势：

* 性能更高 -&gt; 预编译SQL，编译一次之后会将编译后的SQL语句缓存起来，后面再次执行这条insert语句时，SQL语句一样，不会再次编译。 只是输入的参数不同。
+
[.thumb]
image::img/precompile_vs_noprecompile.png[]


* 防止 SQL 注入 -&gt; 将敏感字进行转义，安全。

** SQL 注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。

** 非预编译 sql 是直接对 sql 进行拼接，再进行编译，会出现 sql 注入问题。
+
.SQL 注入举例 (目前的网站已无此问题，在此学习一下原理而已)
[source,sql]
----
-- 下面是正常的执行语句，会返回 1，说明登录成功。
select count(*) from emp where username = 'jinyong' and password = '123456';

-- 下面是有 SQL 注入的情况，也会返回 1，说明也登录成功。(在 DBeaver 中执行成功，在 Antares 中执行不成功。)
-- 用户在前端输入 'jinyong'-- '，直接把后面的 ' and password = '123456'; 给注释了，如下所示:
select count(*) from emp where username = 'jinyong'-- ' and password = '123456';
----

** 预编译 sql，使用占位符替代具体的参数，编译之后再进行对占位符的赋值。这样就解决了 sql 注入问题。
+
[source,sql]
----
select count(*) from emp where username = ? and password = ?;
----
</t>
<t tx="swot.20241016164835.1">@language java
@doc
接下来，我们就可以直接在单元测试类中通过 @Autowired 注解 EmpMapper 接口。
然后就可以直接调用其 deleteEmpById 方法传递参数进行测试了。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    void deleteEmpByIdTest() {
        empMapper.deleteEmpById(15);
    }

}
@doc
----

测试结果为删除了指定的数据库记录。
</t>
<t tx="swot.20241016171631.1"></t>
<t tx="swot.20241017094230.1"></t>
<t tx="swot.20241017105433.1">@language asciidoc
可以在 application.properties 中，打开 mybatis 的日志，并指定输出到控制台，参下面文件所示。

开启日志之后，我们再次运行单元测试。可以看到在控制台中，输出了执行的 SQL 语句。
....
==&gt;  Preparing: delete from emp where id = ?
==&gt; Parameters: 15(Integer)
&lt;==    Updates: 1
....


但是发现输出的SQL语句为: `delete from emp where id = ?`，我们输入的参数 15 并没有在后面拼接，id 的值是使用 ? 进行占位。那这种SQL语句我们称为 #预编译 SQL#。

</t>
<t tx="swot.20241017110155.1">@language python
@doc
[source,properties,linenums,highlight=13;14]
----
@c
# 配置文件行最后不能有空格
spring.application.name=mybatis_quickstart-crud

# 驱动类名称
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
# 数据库连接的 url
spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_db
# 连接数据库的用户名
spring.datasource.username=root
# 连接数据库的密码
spring.datasource.password=root

# 指定mybatis输出日志的位置, 输出控制台
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

@doc
----</t>
<t tx="swot.20241017141815.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc:
:toc: right
:toc-title: 目录
:toclevels: 3
</t>
<t tx="swot.20241017141815.10">创建控制器 UserController，代码完成后可以使用 postman 工具或者浏览器测试该 api。
</t>
<t tx="swot.20241017141815.12">访问：http://127.0.0.1:8080/user.html

[.thumb]
image::img/xml_data_show.png[]</t>
<t tx="swot.20241017141815.2">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++


CAUTION: [red]#要使用前面的工程来实现本例。#

目标：获取 `user.xml` 文件中的用户数据，返回统一响应结果，在页面渲染展示。
</t>
<t tx="swot.20241017141815.3"></t>
<t tx="swot.20241017141815.4">@first &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
@language xml
@doc
.user 数据文件
```xml
@c
&lt;users&gt;
    &lt;user&gt;
        &lt;name&gt;金毛狮王&lt;/name&gt;
        &lt;age&gt;55&lt;/age&gt;
        &lt;address&gt;
            &lt;province&gt;北京&lt;/province&gt;
            &lt;city&gt;昌平&lt;/city&gt;
        &lt;/address&gt;
    &lt;/user&gt;
    &lt;user&gt;
        &lt;name&gt;白眉鹰王&lt;/name&gt;
        &lt;age&gt;65&lt;/age&gt;
        &lt;address&gt;
            &lt;province&gt;陕西&lt;/province&gt;
            &lt;city&gt;西安&lt;/city&gt;
        &lt;/address&gt;
    &lt;/user&gt;
    &lt;user&gt;
        &lt;name&gt;青翼蝠王&lt;/name&gt;
        &lt;age&gt;45&lt;/age&gt;
        &lt;address&gt;
            &lt;province&gt;四川&lt;/province&gt;
            &lt;city&gt;成都&lt;/city&gt;
        &lt;/address&gt;
    &lt;/user&gt;
    &lt;user&gt;
        &lt;name&gt;紫衫龙王&lt;/name&gt;
        &lt;age&gt;38&lt;/age&gt;
        &lt;address&gt;
            &lt;province&gt;广东&lt;/province&gt;
            &lt;city&gt;广州&lt;/city&gt;
        &lt;/address&gt;
    &lt;/user&gt;
&lt;/users&gt;
@doc
```</t>
<t tx="swot.20241017141815.5">@language xml
[source,xml]
----
&lt;dependency&gt;
    &lt;groupId&gt;dom4j&lt;/groupId&gt;
    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
    &lt;version&gt;1.6.1&lt;/version&gt;
&lt;/dependency&gt;
----
</t>
<t tx="swot.20241017141815.6">先在 IDEA 中创建包 utils，然后再生成工具类文件。
</t>
<t tx="swot.20241017141815.7">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.utils;

import com.tjise.pojo.Address;
import com.tjise.pojo.User;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;
import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class XmlParserUtils {
    public static List&lt;User&gt; parse(String file)  {
        ArrayList&lt;User&gt; list = new ArrayList&lt;&gt;(); //封装解析出来的数据

        try {
            //1.获取一个解析器对象
            SAXReader saxReader = new SAXReader();
            //2.利用解析器把xml文件加载到内存中,并返回一个文档对象
            Document document = saxReader.read(new File(file));
            //3.获取到根标签
            Element rootElement = document.getRootElement();
            //4.通过根标签来获取 user 标签
            List&lt;Element&gt; userElements = rootElement.elements("user");

            //5.遍历集合,得到每一个 user 标签
            for (Element element : userElements) {
                //获取 name 属性
                String name = element.element("name").getText();

                //获取 age 标签
                String age = element.element("age").getText();

                //获取 address 标签
                Element address = element.element("address");
                String province = address.element("province").getText();
                String city = address.element("city").getText();

                //组装数据
                User user = new User();
                user.setName(name);
                user.setAge(Integer.parseInt(age));

                Address addr = new Address();
                addr.setProvince(province);
                addr.setCity(city);
                user.setAddress(addr);

                list.add(user);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return list;
    }
}
@doc
----
</t>
<t tx="swot.20241017141815.8"></t>
<t tx="swot.20241017141815.9">@first &lt;!DOCTYPE html&gt;
@tabwidth -2
@language html
@doc
[source,html,linenums]
----
@c
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;用户信息&lt;/title&gt;
&lt;/head&gt;

&lt;!--&lt;script src="./js/vue.js"&gt;&lt;/script&gt;--&gt;
&lt;!--&lt;script src="./js/axios-0.18.0.js"&gt;&lt;/script&gt;--&gt;

&lt;!-- Vue.js 2.6.10 CDN --&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.min.js"&gt;&lt;/script&gt;

&lt;!-- Axios 0.18.0 CDN --&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/axios@0.18.0/dist/axios.min.js"&gt;&lt;/script&gt;

&lt;!-- element-ui 引入样式 --&gt;
&lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt;
&lt;!-- element-ui 引入组件库 --&gt;
&lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt;

&lt;body&gt;
  &lt;h1 align="center"&gt;用户信息列表展示&lt;/h1&gt;
  &lt;div id="app"&gt;
    &lt;!-- {{ tableData }}--&gt;
    &lt;el-table :data="tableData" style="width: 100%"  stripe border &gt;
      &lt;el-table-column prop="name" label="姓名" align="center" min-width="25%"&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column prop="age" label="年龄" align="center" min-width="25%"&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column prop="address.province" label="省/市" align="center" min-width="25%"&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column prop="address.city" label="区/县" align="center" min-width="25%"&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table&gt;
  &lt;/div&gt;
&lt;/body&gt;

&lt;style&gt;
    .el-table .warning-row {
        background: oldlace;
    }
    .el-table .success-row {
        background: #f0f9eb;
    }
&lt;/style&gt;

&lt;script&gt;
    new Vue({
        el: "#app",
        data() {
            return {
                tableData: []
            }
        },
        mounted(){
            axios.get('/listUser').then(res=&gt;{
                if(res.data.code){
                    this.tableData = res.data.data;
                }
            });
        },
        methods: {}
    });
&lt;/script&gt;
&lt;/html&gt;
@doc
----
</t>
<t tx="swot.20241017145139.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.controller;

import com.tjise.pojo.Address;
import com.tjise.pojo.Result;
import com.tjise.pojo.User;
import com.tjise.utils.XmlParserUtils;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class UserController {

    @RequestMapping("/listUser")
    public Result listUser() {
        // 1 获取数据（解析 xml 文件，把数据封装到对象中）
        // 动态获取 user.xml 文件绝对路径
        String path = UserController.class.getClassLoader()
                      .getResource("user.xml").getPath();
        System.out.println("path = " + path);
        List&lt;User&gt; list = XmlParserUtils.parse(path);

        // 2 业务逻辑操作（把获取的 province 和 city 的值进行处理）
        for (User user : list) {
            Address address = user.getAddress();
            address.setProvince(address.getProvince() + " 省/市");
            address.setCity(address.getCity() + " 市/区");
        }

        // 3 把封装的数据响应给客户端
        return Result.success(list);
    }
}
@doc
----</t>
<t tx="swot.20241017171352.1">@language asciidoc
在 Mybatis 中提供的参数占位符有两种：${...}, #{...}。

1. #{...}

* 执行SQL时，会将#{…}替换为?，生成预编译SQL，会自动设置参数值。

* 使用时机：参数传递，都使用#{…}



2. ${...}

* 拼接SQL。直接将参数拼接在SQL语句中，存在SQL注入问题。

* 使用时机：在对表名、列名进行动态设置时使用。如下面例子中取表名 emp
** 正确 -&gt; [green]#delete from ${emp} where id = 17;#
** 错误 -&gt;   [red]#delete from #{emp} where id = 17;# (无法通过语法检测)

NOTE: 	在项目开发中，建议使用 #{...}，生成预编译SQL，防止SQL注入安全。
</t>
<t tx="swot.20241017172315.1">@language java
@doc
删除记录接口方法如下

[source,java,linenums]
----
@c
package com.tjise.mapper;

import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Mapper;

/* Mapper 注解
    1. 让此接口被 mybatis 框架识别
    2. Spring Boot 会自动创建此接口的实现类对象，交给 IOC 容器管理
*/

@Mapper
public interface EmpMapper {

    // @Delete("delete from emp where id = #{id}")   // &lt;1&gt;
    @Delete("delete from emp where id = ${id}")  // &lt;2&gt; 
    public abstract void deleteEmpById(Integer id);
}
@doc
----
&lt;1&gt; 使用 # 是预编译 sql，控制台打印如下:
+
....
==&gt;  Preparing: delete from emp where id = ?
==&gt; Parameters: 17(Integer)
&lt;==    Updates: 0
....

&lt;2&gt; 改成 $ 也是可以的，但为拼接 sql，不是预编译 sql，不建议使用。改成 $ 后控制台打印如下:
+
....
==&gt;  Preparing: delete from emp where id = 17
==&gt; Parameters: 
&lt;==    Updates: 0
....
</t>
<t tx="swot.20241017230959.1"></t>
<t tx="swot.20241017233030.1">@language java
@doc
删除记录接口方法如下

[source,java,linenums]
----
@c
package com.tjise.mapper;

import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Mapper;


@Mapper
public interface EmpMapper {

    // @Delete("delete from emp where id = #{id}")
    @Delete("delete from emp where id = ${id}")
    public abstract void deleteEmpById(Integer id);

    // -- new -- 新增两种情况测试代码
    @Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
    public abstract void deleteFromTableById(String tableName);
}
@doc
----

&lt;1&gt; #{} 表名不可用
+
....
### SQL: delete from ? where id = 17
### Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; 
....

&lt;2&gt; ${} 表名可用
+
....
JDBC Connection [HikariProxyConnection@2007004340 wrapping com.mysql.cj.jdbc.ConnectionImpl@333c8791] will not be managed by Spring
==&gt;  Preparing: delete from emp where id = 17
==&gt; Parameters: 
&lt;==    Updates: 0
....
</t>
<t tx="swot.20241017233039.1">@language java
@doc
接下来，我们就可以直接在单元测试类中通过 @Autowired 注解 EmpMapper 接口。
然后就可以直接调用其 deleteFromTableByIdTest 方法传递参数进行测试了。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    void deleteEmpByIdTest() {
        empMapper.deleteEmpById(17);
    }

    // -- new -- 新增测试
    @Test
    void deleteFromTableByIdTest() {
        empMapper.deleteFromTableById("emp");
    }
}
@doc
----
</t>
<t tx="swot.20241017235753.1"></t>
<t tx="swot.20241018000113.1"></t>
<t tx="swot.20241018082408.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc:
:toc: right
:toc-title: 目录
:toclevels: 4
</t>
<t tx="swot.20241018082408.10">接收前端发送的请求，对请求进行处理，并响应数据。
</t>
<t tx="swot.20241018082408.11">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.controller;

import com.tjise.pojo.Address;
import com.tjise.pojo.Result;
import com.tjise.pojo.User;
import com.tjise.service.UserServiceA;
import com.tjise.utils.XmlParserUtils;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class UserController {
    private UserServiceA userService = new UserServiceA();

    @RequestMapping("/listUser")
    public Result listUser() {
        List&lt;User&gt; list = userService.operatorUser();
        // 3 把封装的数据响应给客户端
        return Result.success(list);
    }
}
@doc
----
</t>
<t tx="swot.20241018082408.2">
++++
&lt;button id="toggleButton"&gt;目录&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20241018082408.3">在学习前面的 user.xml 解析案例时，如下面的 public class UserController 类中，所有的三个功能都写在了这一个类中。比如:

1. 获取数据（解析 xml 文件，把数据封装到对象中）

2. 业务逻辑操作（把获取的 province 和 city 的值进行处理）

3. 把封装的数据响应给客户端

当网站功能复杂时，该类中的代码会很多，不容易维护，所以需要将三种不同功能的代码拆分开。

这里我们介绍三层架构的拆分方式。
</t>
<t tx="swot.20241018082408.5">按照下面三个分层，分别创建 3 个包：

1. 在 IDEA 中创建包 dao（Data Access Object 数据访问对象），在 dao 下创建类 UserDaoA.java
    * 起名为 A 是为了后面演示多个类的情况，先记住。

2. 在 IDEA 中创建包 service，在 service 下创建类 UserServiceA.java
    * 起名为 A 是为了后面演示多个类的情况，先记住。

3. controller 包已经存在，不需要再创建。

改造完成后访问网址: http://localhost:8080/user.html 和之前一样，说明改造成功。

[.thumb]
image::img/xml_data_show.png[]
</t>
<t tx="swot.20241018082408.6">负责数据访问操作，包括数据的增、删、改、查。
</t>
<t tx="swot.20241018082408.7">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.dao;

import com.tjise.controller.UserController;
import com.tjise.pojo.User;
import com.tjise.utils.XmlParserUtils;

import java.util.List;

public class UserDaoA {
    public List&lt;User&gt; operatorUser() {
        // 1 操作数据（解析 xml 文件，把数据封装到对象中）
        // 动态获取 user.xml 文件绝对路径
        String path = UserController.class.getClassLoader()
                .getResource("user.xml").getPath();
        System.out.println("path = " + path);
        List&lt;User&gt; list = XmlParserUtils.parse(path);
        return list;
    }
}
@doc
----
</t>
<t tx="swot.20241018082408.8">处理具体的业务逻辑。</t>
<t tx="swot.20241018082408.9">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.service;

import com.tjise.dao.UserDaoA;
import com.tjise.pojo.Address;
import com.tjise.pojo.User;

import java.util.List;

public class UserServiceA {
    private UserDaoA userDao = new UserDaoA();

    public List&lt;User&gt; operatorUser() {
        // 调用 Dao 层的方法，获取数据集合
        List&lt;User&gt; list = userDao.operatorUser();

        // 2 业务逻辑操作（把获取的 province 和 city 的值进行处理）
        for (User user : list) {
            Address address = user.getAddress();
            address.setProvince(address.getProvince() + " 省/市");
            address.setCity(address.getCity() + " 市/区");
        }

        return list;
    }
}
@doc
----</t>
<t tx="swot.20241018084615.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.controller;

import com.tjise.pojo.Address;
import com.tjise.pojo.Result;
import com.tjise.pojo.User;
import com.tjise.utils.XmlParserUtils;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class UserController {

    @RequestMapping("/listUser")
    public Result listUser() {
        // 1 获取数据（解析 xml 文件，把数据封装到对象中）
        // 动态获取 user.xml 文件绝对路径
        String path = UserController.class.getClassLoader()
                      .getResource("user.xml").getPath();
        System.out.println("path = " + path);
        List&lt;User&gt; list = XmlParserUtils.parse(path);

        // 2 业务逻辑操作（把获取的 province 和 city 的值进行处理）
        for (User user : list) {
            Address address = user.getAddress();
            address.setProvince(address.getProvince() + " 省/市");
            address.setCity(address.getCity() + " 市/区");
        }

        // 3 把封装的数据响应给客户端
        return Result.success(list);
    }
}
@doc
----
</t>
<t tx="swot.20241018093655.1"></t>
<t tx="swot.20241018105726.10">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.service;

import com.tjise.dao.UserDao;
import com.tjise.dao.UserDaoA;
import com.tjise.pojo.Address;
import com.tjise.pojo.User;

import java.util.List;

public class UserServiceA {

    // private UserDaoA userDao = new UserDaoA();
    // -- new -- 使用接口 UserDao 来定义变量类型(多态)
    private UserDao userDao = new UserDaoA();

    public List&lt;User&gt; operatorUser() {
        // 调用 Dao 层的方法，获取数据集合
        List&lt;User&gt; list = userDao.operatorUser();

        // 2 业务逻辑操作（把获取的 province 和 city 的值进行处理）
        for (User user : list) {
            Address address = user.getAddress();
            address.setProvince(address.getProvince() + " 省/市");
            address.setCity(address.getCity() + " 市/区");
        }

        return list;
    }
}
@doc
----
</t>
<t tx="swot.20241018105726.11">我们需要从两个方面来进行解耦，分别是 #左边类型# 和 #右边的类实例化#。
====
private [red]#UserServiceA# userService = [red]#new UserServiceA()#;
====

左边类型使用多态来解耦。

. 定义接口 UserService
+
[source,java]
----
public interface UserService {
    public abstract List&lt;User&gt; operatorUser();
}
----

. 实现接口 UserService
+
[source,java]
----
public class UserServiceA implements UserService {
----

. 使用接口 UserService 来定义变量类型
+
[source,java]
----
private UserService userService = new UserServiceA();
----

详细看下面的代码。
</t>
<t tx="swot.20241018105726.12">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.service;

import com.tjise.pojo.User;

import java.util.List;

public interface UserService {
    public abstract List&lt;User&gt; operatorUser();
}
@doc
----
</t>
<t tx="swot.20241018105726.13">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.service;

import com.tjise.dao.UserDao;
import com.tjise.dao.UserDaoA;
import com.tjise.pojo.Address;
import com.tjise.pojo.User;

import java.util.List;

// public class UserServiceA {
// -- new -- 实现接口 UserService
public class UserServiceA implements UserService {

    // private UserDaoA userDao = new UserDaoA();
    // 使用接口 UserDao 来定义变量类型(多态)
    private UserDao userDao = new UserDaoA();

    public List&lt;User&gt; operatorUser() {
        // 调用 Dao 层的方法，获取数据集合
        List&lt;User&gt; list = userDao.operatorUser();

        // 2 业务逻辑操作（把获取的 province 和 city 的值进行处理）
        for (User user : list) {
            Address address = user.getAddress();
            address.setProvince(address.getProvince() + " 省/市");
            address.setCity(address.getCity() + " 市/区");
        }

        return list;
    }
}
@doc
----
</t>
<t tx="swot.20241018105726.14">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.controller;

import com.tjise.pojo.Address;
import com.tjise.pojo.Result;
import com.tjise.pojo.User;
import com.tjise.service.UserService;
import com.tjise.service.UserServiceA;
import com.tjise.utils.XmlParserUtils;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class UserController {

    // private UserServiceA userService = new UserServiceA();
    private UserService userService = new UserServiceA();

    @RequestMapping("/listUser")
    public Result listUser() {
        List&lt;User&gt; list = userService.operatorUser();
        // 3 把封装的数据响应给客户端
        return Result.success(list);
    }
}
@doc
----
</t>
<t tx="swot.20241018105726.15" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032342d31302d30397103752e">我们现在需要对右边的类实例化进行解耦。
====
service 层调用 Dao 层::
private UserDao userDao = [red]#new UserDaoA()#;
controller 层调用 Service 层::
private UserService userService = [red]#new UserServiceA()#;
====

右边类的实例化解耦有两步：

1. 使用 IOC 控制反转将实现类的对象放入框架的容器(称为IOC容器)。
+
[source,java]
----
@Component
public class UserDaoA implements UserDao {...}

@Component
public class UserServiceA implements UserService {...}
----

2. 使用 DI 依赖注入将IOC容器中的对象(Bean对象)赋值给接口定义的变量。
+
[source,java]
----
@Autowired  // 去 IOC 容器中找 UserDao 类型的对象进行使用
private UserDao userDao;  // service 层调用 Dao 层

@Autowired  // 去 IOC 容器中找 UserService 类型的对象进行使用
private UserService userService;  // controller 层调用 Service 层
----

详细看下面的代码。

.名词解释
****
* IOC: Inversion Of Control, 对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。

* DI: Dependecy Injection, 容器为应用程序提供运行时所依赖的资源，称为依赖注入。

* Bean对象: IOC容器中创建、管理的对象，称为 bean 对象。即由 @Component 注解的类生成的对象。
****</t>
<t tx="swot.20241018105726.16">@language java
@doc
[source,java,linenums,highlight=12]
----
@c
package com.tjise.dao;

import com.tjise.controller.UserController;
import com.tjise.pojo.User;
import com.tjise.utils.XmlParserUtils;
import org.springframework.stereotype.Component;

import java.util.List;


// -- new --
@Component
public class UserDaoA implements UserDao {

    public List&lt;User&gt; operatorUser() {
        // 1 操作数据（解析 xml 文件，把数据封装到对象中）
        // 动态获取 user.xml 文件绝对路径
        String path = UserController.class.getClassLoader()
                .getResource("user.xml").getPath();
        System.out.println("path = " + path);
        List&lt;User&gt; list = XmlParserUtils.parse(path);
        return list;
    }
}
@doc
----
</t>
<t tx="swot.20241018105726.17">@language java
@doc
[source,java,linenums,highlight=13;19]
----
@c
package com.tjise.service;

import com.tjise.dao.UserDao;
import com.tjise.dao.UserDaoA;
import com.tjise.pojo.Address;
import com.tjise.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.List;

// -- new --
@Component
public class UserServiceA implements UserService {

    // 使用接口 UserDao 来定义变量类型(多态)
    // private UserDao userDao = new UserDaoA();
    // -- new start --
    @Autowired
    private UserDao userDao;
    // -- new end --

    public List&lt;User&gt; operatorUser() {
        // 调用 Dao 层的方法，获取数据集合
        List&lt;User&gt; list = userDao.operatorUser();

        // 2 业务逻辑操作（把获取的 province 和 city 的值进行处理）
        for (User user : list) {
            Address address = user.getAddress();
            address.setProvince(address.getProvince() + " 省/市");
            address.setCity(address.getCity() + " 市/区");
        }

        return list;
    }
}
@doc
----
</t>
<t tx="swot.20241018105726.18">@language java
@doc
[source,java,linenums,highlight=20]
----
@c
package com.tjise.controller;

import com.tjise.pojo.Address;
import com.tjise.pojo.Result;
import com.tjise.pojo.User;
import com.tjise.service.UserService;
import com.tjise.service.UserServiceA;
import com.tjise.utils.XmlParserUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class UserController {

    // private UserService userService = new UserServiceA();
    // -- new start --
    @Autowired
    private UserService userService;
    // -- new end --

    @RequestMapping("/listUser")
    public Result listUser() {
        List&lt;User&gt; list = userService.operatorUser();
        // 3 把封装的数据响应给客户端
        return Result.success(list);
    }
}
@doc
----</t>
<t tx="swot.20241018105726.19">尽管社区版的 IDEA 没有 Ultimate 版的高级功能，依然可以通过代码和日志来查看 Spring IOC 容器中的对象。

下面是三种查看方式，经过测试都可以，推荐使用 Actuator 依赖来查看。
</t>
<t tx="swot.20241018105726.20">1. 在 `pom.xml` 中添加 Spring Boot Actuator 依赖，然后在浏览器中访问 `/actuator/beans` 端点来查看所有 Bean 信息。依赖如下：
+
```xml
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
```

2. 在 `application.properties` 文件中启用该端点：
+
```properties
management.endpoints.web.exposure.include=beans
```

3. 启动应用程序并访问 http://localhost:8080/actuator/beans 会看到所有 IoC 容器中的 Bean 及其依赖关系。ICO 容器中 bean 对象命名规则可参考下面内容。
+
[.thumb]
image::img/actuator_bean.png[]

</t>
<t tx="swot.20241018105726.21">1. 项目的 pom.xml 中正确引入 spring-boot-starter-logging 依赖
+
```xml
&lt;!-- 打印日志--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
&lt;/dependency&gt;
```

2. 在 `application.properties` 或 `application.yml` 中设置 Spring 的日志级别为 `DEBUG` 来查看 Bean 的加载情况：
+
```properties
logging.level.org.springframework=DEBUG
```

3. 启动应用程序时，控制台会输出 Spring IOC 容器的详细信息，包括 Bean 的加载过程和依赖注入的日志。
+
image::img/ioc_bean_log.png[]
</t>
<t tx="swot.20241018105726.22">**使用 `@SpringBootApplication` 和 `ApplicationContext`**：
你可以通过在 Spring Boot 项目中使用 `ApplicationContext` 来查看所有已注册的 Bean。以下是在项目启动类中打印出所有 Bean 的例子：

```java
@SpringBootApplication
public class MySpringBootApplication {
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(MySpringBootApplication.class, args);
        String[] beanNames = context.getBeanDefinitionNames();
        Arrays.sort(beanNames); // 排序，方便查看
        for (String beanName : beanNames) {
            System.out.println(beanName);
        }
    }
}
```

运行程序时，这会在控制台打印出 Spring IoC 容器中的所有 Bean 名称。

.有好多的 Bean
....
beanName = userController
beanName = userDaoA
beanName = userServiceA
等等......
....
</t>
<t tx="swot.20241018105726.23">@language asciidoc
前面我们使用 @Component 声明过 IOC 容器中的 bean 对象了，现在再来拓展一下相应的内容。

要把某个对象交给 IOC 容器管理，需要在对应的类上添加如下注解之一：

[cols="15%,25%,60%",options="header"]
|===
|注解            |说明                        |位置
|@Component     | 声明 bean 对象的基础注解     |一般不属于以下三类时，可用此注解，比如定义的工具类、POJO 实体类等
|@Controller    .3+.^| @Component 的衍生注解  | 标注在 controller 层的控制器类上
|@Service                                    | 标注在 service 层的业务类上，比 @Component 主义化更强
|@Repository                                 | 标注在 dao 层数据访问类上（由于与 mybatis 整合会使用 @Mapper，所以用的少）
|===

下面用相应的注解来做一些更改吧!
</t>
<t tx="swot.20241018105726.24">@language java
@doc
[source,java,linenums,highlight=13]
----
@c
package com.tjise.dao;

import com.tjise.controller.UserController;
import com.tjise.pojo.User;
import com.tjise.utils.XmlParserUtils;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Repository;

import java.util.List;


// @Component
@Repository  // -- new --
public class UserDaoA implements UserDao {

    public List&lt;User&gt; operatorUser() {
        // 1 操作数据（解析 xml 文件，把数据封装到对象中）
        // 动态获取 user.xml 文件绝对路径
        String path = UserController.class.getClassLoader()
                .getResource("user.xml").getPath();
        System.out.println("path = " + path);
        List&lt;User&gt; list = XmlParserUtils.parse(path);
        return list;
    }
}
@doc
----
</t>
<t tx="swot.20241018105726.25">@language java
@doc
[source,java,linenums,highlight=15]
----
@c
package com.tjise.service;

import com.tjise.dao.UserDao;
import com.tjise.dao.UserDaoA;
import com.tjise.pojo.Address;
import com.tjise.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

import java.util.List;


// @Component
@Service    // -- new --
public class UserServiceA implements UserService {

    // 使用接口 UserDao 来定义变量类型(多态)
    // private UserDao userDao = new UserDaoA();
    @Autowired
    private UserDao userDao;

    public List&lt;User&gt; operatorUser() {
        // 调用 Dao 层的方法，获取数据集合
        List&lt;User&gt; list = userDao.operatorUser();

        // 2 业务逻辑操作（把获取的 province 和 city 的值进行处理）
        for (User user : list) {
            Address address = user.getAddress();
            address.setProvince(address.getProvince() + " 省/市");
            address.setCity(address.getCity() + " 市/区");
        }
        return list;
    }
}
@doc
----
</t>
<t tx="swot.20241018105726.26">@language java
@doc
[source,java,linenums,highlight=15;16]
----
@c
package com.tjise.controller;

import com.tjise.pojo.Address;
import com.tjise.pojo.Result;
import com.tjise.pojo.User;
import com.tjise.service.UserService;
import com.tjise.service.UserServiceA;
import com.tjise.utils.XmlParserUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

// -- new -- 说明一下: 该注解已经包含了 @Controller
@RestController
public class UserController {

    @Autowired
    private UserService userService;

    @RequestMapping("/listUser")
    public Result listUser() {
        List&lt;User&gt; list = userService.operatorUser();
        // 3 把封装的数据响应给客户端
        return Result.success(list);
    }
}
@doc
----
</t>
<t tx="swot.20241018105726.27"></t>
<t tx="swot.20241018105726.28">@language asciidoc
1. 声明 bean 的时候，如果没有指定 value 属性，则 Bean 对象名称默认为类名首字母小写。

** 如默认的 UserController 类对应的 IOC 容器中的 bean 对象名字为 userController

** 具体查看方法请参 《查看 IOC 容器中的 Bean 对象》一节

+
.bean 名字默认为小驼峰
[.thumb]
image::img/ioc_bean_name.png[默认bean对象命名,640]


2. 声明 bean 的时候，也可以通过 value 属性指定 bean 的名称。
+
bean 名称被指定 @Service(value="userServiceAAA")，如下面截图和代码所示。
+
[.thumb]
image::img/ioc_bean_name_assigned.png[指定bean对象命名,640]
</t>
<t tx="swot.20241018105726.29">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.service;

import com.tjise.dao.UserDao;
import com.tjise.dao.UserDaoA;
import com.tjise.pojo.Address;
import com.tjise.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

import java.util.List;

// @Service
// @Service(value="userServiceAAA")
@Service("userServiceAAA")    // -- new -- 可以省略 value
public class UserServiceA implements UserService {

    @Autowired
    private UserDao userDao;

    public List&lt;User&gt; operatorUser() {
        // 调用 Dao 层的方法，获取数据集合
        List&lt;User&gt; list = userDao.operatorUser();

        // 2 业务逻辑操作（把获取的 province 和 city 的值进行处理）
        for (User user : list) {
            Address address = user.getAddress();
            address.setProvince(address.getProvince() + " 省/市");
            address.setCity(address.getCity() + " 市/区");
        }
        return list;
    }
}
@doc
----</t>
<t tx="swot.20241018105726.30">@language asciidoc
目前来说，我们使用以上四个注解都可以声明 bean，但是在集成后端 web 开发之后，声明控制器(Controller) 的 bean 只能用 @Controler。
当前的应用已经加入了起步依赖 spring-boot-starter-web，所以我们使用 @RestController 就可以了。

.为什么控制器 bean 只能用 `@Controller`？
****
虽然从 Spring IOC 容器的角度来看，`@Component` 和其他衍生注解（如 `@Controller`）在技术上都可以注册 bean，但 `@Controller` 是专门用于控制器类的注解。Spring MVC 框架会扫描所有带有 `@Controller` 注解的类，并将其视为处理 HTTP 请求的控制器。

- *`@Controller` 的作用不仅仅是声明 bean*，它还告诉 Spring 这个类是一个 Web 控制器，它应该参与处理 HTTP 请求。
- 如果你用其他注解（例如 `@Service` 或 `@Component`）来声明控制器类，Spring MVC 不会识别它为一个控制器，导致 HTTP 请求无法被正确处理。
****

NOTE: @RestController 注解已经包含了 @Controller 注释。
</t>
<t tx="swot.20241018105726.31">@language asciidoc
前面声明 bean 的四大注解，要想生效，还需要被组件扫描注解 @ComponentScan 扫描。

@ComponentScan 注解虽然没有显式配置，但是实际上已经包含在了引导类声明注解 @SpringBootApplication 中，##默认扫描的范围是引导类所在包及其子包##，按 Ctrl 点击 @SpringBootApplication 可查看包含的其他注解。

.启动类已经包含了 @ComponentScan 注解
image::img/ioc_component_scan.png[]


.查看代码目录结构
....
tree spring-boot-request-response/src/main/java
└── com
    └── tjise
        ├── RequestAndResponseSpringBootApplication.java  // 启动类
        ├── controller
        │   └── UserController.java
        ├── dao
        │   ├── UserDao.java
        │   └── UserDaoA.java
        ├── pojo
        │   ├── Address.java
        │   ├── Result.java
        │   └── User.java
        ├── service
        │   ├── UserService.java
        │   └── UserServiceA.java
        └── utils
            └── XmlParserUtils.java
....

所以只要四大注解（@Component, @Controller, @Service, @Repository）修饰的文件们超出了 tjise 目录，注解就无法生效了。您可以试试哟！
</t>
<t tx="swot.20241018105726.32">@language asciidoc
@Autowired 注解注入 bean 对象，##默认是按类的类型进行查找的##，所以如果存在多个相同类型的 bean 对象，将会报错。

新建 UserServiceB.java 后，3 个文件的关键代码如下面颜色高亮部分。

.运行项目报错如下:
....
Field userService in com.tjise.controller.UserController required a single bean, but 2 were found:
	- userServiceA: defined in file [/Users/swot/aio/java/springboot/spring-boot-request-response/target/classes/com/swot/service/UserServiceA.class]
	- userServiceB: defined in file [/Users/swot/aio/java/springboot/spring-boot-request-response/target/classes/com/swot/service/UserServiceB.class]

Action:

Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumed
....

上面给出了报错原因是 UserController 需要一个 bean 对象，但是找到了两个。
同时也给出了两种解决方案为使用注解 @Primary 或 @Qualifier。
下面分别对 @Primary 和 @Qualifier 进行测试。

NOTE: 下面还额外介绍了 java 提供的注解 @Resource 来解决这个问题。用法和 @Qualifier 类似。
</t>
<t tx="swot.20241018105726.33">@language java
@doc
.使用 @Autowired 注入 ICO 容器中的 bean 对象给变量 userService
[source,java,linenums,highlight=18;19]
----
@c
package com.tjise.controller;

import com.tjise.pojo.Address;
import com.tjise.pojo.Result;
import com.tjise.pojo.User;
import com.tjise.service.UserService;
import com.tjise.service.UserServiceA;
import com.tjise.utils.XmlParserUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class UserController {

    @Autowired  // 只要一个 UserService 类型的 IOC bean 对象
    private UserService userService;

    @RequestMapping("/listUser")
    public Result listUser() {
        List&lt;User&gt; list = userService.operatorUser();
        // 3 把封装的数据响应给客户端
        return Result.success(list);
    }
}
@doc
----
</t>
<t tx="swot.20241018105726.34">@language java
@doc
.IOC 容器中的 UserService 类型的 bean 对象为 userServiceA
[source,java,linenums,highlight=13;14;26;27]
----
@c
package com.tjise.service;

import com.tjise.dao.UserDao;
import com.tjise.dao.UserDaoA;
import com.tjise.pojo.Address;
import com.tjise.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

import java.util.List;

@Service    // --new-- IOC bean 是 UserService 类型的 userServiceA
public class UserServiceA implements UserService {

    @Autowired
    private UserDao userDao;

    public List&lt;User&gt; operatorUser() {
        // 调用 Dao 层的方法，获取数据集合
        List&lt;User&gt; list = userDao.operatorUser();

        // 2 业务逻辑操作（把获取的 province 和 city 的值进行处理）
        for (User user : list) {
            Address address = user.getAddress();
            address.setProvince(address.getProvince() + " 省/市A");
            address.setCity(address.getCity() + " 市/区A");
        }
        return list;
    }
}
@doc
----</t>
<t tx="swot.20241018105726.35">@language java
@doc
.IOC 容器中的 UserService 类型的 bean 对象为 userServiceB
[source,java,linenums,highlight=13;14;26;27]
----
@c
package com.tjise.service;

import com.tjise.dao.UserDao;
import com.tjise.dao.UserDaoA;
import com.tjise.pojo.Address;
import com.tjise.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

import java.util.List;

@Service    // --new-- IOC bean 是 UserService 类型的 userServiceB
public class UserServiceB implements UserService {

    @Autowired
    private UserDao userDao;

    public List&lt;User&gt; operatorUser() {
        // 调用 Dao 层的方法，获取数据集合
        List&lt;User&gt; list = userDao.operatorUser();

        // 2 业务逻辑操作（把获取的 province 和 city 的值进行处理）
        for (User user : list) {
            Address address = user.getAddress();
            address.setProvince(address.getProvince() + " 省/市B");
            address.setCity(address.getCity() + " 市/区B");
        }
        return list;
    }
}
@doc
----</t>
<t tx="swot.20241018105726.36">@language asciidoc
使用 @Primary 注解标注生成的 bean 对象会被优先使用。测试将 @Primary 注解加在 UserServiceA 实现类上，再启动项目会发现此时使用了 bean 对象 userServiceA。

[.thumb]
image::img/Primary.png[]

如果将 @Primary 注解加在 UserServiceB 类上，则会使用 bean 对象 userServiceB，测试省略。

</t>
<t tx="swot.20241018105726.37">@language java
@doc
.IOC 容器中的 UserService 类型的 bean 对象为 userServiceA
[source,java,linenums,highlight=15..17;29;30]
----
@c
package com.tjise.service;

import com.tjise.dao.UserDao;
import com.tjise.dao.UserDaoA;
import com.tjise.pojo.Address;
import com.tjise.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

import java.util.List;


@Service    // --new-- IOC bean 对象是 UserService 类型的 userServiceA
@Primary    // 加入新注解以解决多个 @Autowired 只要一个Bean 的问题
public class UserServiceA implements UserService {

    @Autowired
    private UserDao userDao;

    public List&lt;User&gt; operatorUser() {
        // 调用 Dao 层的方法，获取数据集合
        List&lt;User&gt; list = userDao.operatorUser();

        // 2 业务逻辑操作（把获取的 province 和 city 的值进行处理）
        for (User user : list) {
            Address address = user.getAddress();
            address.setProvince(address.getProvince() + " 省/市A");
            address.setCity(address.getCity() + " 市/区A");
        }
        return list;
    }
}
@doc
----
</t>
<t tx="swot.20241018105726.38">@language asciidoc
在使用 @Autowired 注入 bean 对象的时候，使用 @Qualifier 注解来指定使用哪个 bean 对象。
</t>
<t tx="swot.20241018105726.39">@language java
@doc
.使用 @Qualifier(bean对象名) 注入 ICO 容器中的 bean 对象给变量 userService
[source,java,linenums,highlight=19;20]
----
@c
package com.tjise.controller;

import com.tjise.pojo.Address;
import com.tjise.pojo.Result;
import com.tjise.pojo.User;
import com.tjise.service.UserService;
import com.tjise.service.UserServiceA;
import com.tjise.utils.XmlParserUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class UserController {

    @Autowired  // 只要一个 UserService 类型的 IOC bean
    // @Qualifier("userServiceA")   // 使用 userServiceA
    @Qualifier("userServiceB")      // 使用 userServiceB
    private UserService userService;

    @RequestMapping("/listUser")
    public Result listUser() {
        List&lt;User&gt; list = userService.operatorUser();
        // 3 把封装的数据响应给客户端
        return Result.success(list);
    }
}
@doc
----
</t>
<t tx="swot.20241018105726.4">软件开发原则是「高内聚低耦合」。

* 内聚：要提高软件中各个功能模块自己完成功能的能力。
* 耦合：要降低软件中各个层/模块之间的依赖、关联的程度。


.下面代码中 UserServiceA.java 类实例化了类 UserDaoA.java
[source,java]
----
private UserDaoA userDao = new UserDaoA();
----

.下面代码中 UserController.java 类实例化了类 UserServiceA.java
[source,java]
----
private UserServiceA userService = new UserServiceA();
----

这样就产生了强耦合::
    如类 UserDaoA 更改类名，则类 UserServiceA 中的代码也要更改。 +
    如类 UserServiceA 更改类名，则 UserController 中的代码也要更改。

这样不好，我们需要解决这个强耦合问题。


举个例子再解释一下，假设我们有这样的应用场景::
    UserServiceA 对应微信支付 +
    UserServiceB 对应支付宝支付 +
    UserServiceC 对应京东支付 +

那么只要我们更换支付方式，则需要更改 UserController.java 中的代码。
</t>
<t tx="swot.20241018105726.40">@language asciidoc
在使用 @Autowired 注入 bean 对象的时候，使用 @Resource 注解来指定使用哪个 bean 对象。

NOTE: @Resource 是 java 提供的注解。
</t>
<t tx="swot.20241018105726.41">@language java
@doc
.使用 @Resource 注解来指定使用哪个 bean 对象给变量 userService
[source,java,linenums,highlight=21;22]
----
@c
package com.tjise.controller;

import com.tjise.pojo.Address;
import com.tjise.pojo.Result;
import com.tjise.pojo.User;
import com.tjise.service.UserService;
import com.tjise.service.UserServiceA;
import com.tjise.utils.XmlParserUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;
import java.util.List;


@RestController
public class UserController {

    @Autowired  // 只要一个 UserService 类型的 IOC bean
    @Resource(name="userServiceA")      // 使用 userServiceA
    // @Resource(name="userServiceB")      // 使用 userServiceB
    // @Qualifier("userServiceA")       // 使用 userServiceA
    // @Qualifier("userServiceB")       // 使用 userServiceB
    private UserService userService;

    @RequestMapping("/listUser")
    public Result listUser() {
        List&lt;User&gt; list = userService.operatorUser();
        // 3 把封装的数据响应给客户端
        return Result.success(list);
    }
}
@doc
----
</t>
<t tx="swot.20241018105726.5">@language java
@doc
[source,java,linenums,highlight=10]
----
@c
package com.tjise.service;

import com.tjise.dao.UserDaoA;
import com.tjise.pojo.Address;
import com.tjise.pojo.User;

import java.util.List;

public class UserServiceA {
    private UserDaoA userDao = new UserDaoA();  // 强耦合

    public List&lt;User&gt; operatorUser() {
        // 调用 Dao 层的方法，获取数据集合
        List&lt;User&gt; list = userDao.operatorUser();

        // 2 业务逻辑操作（把获取的 province 和 city 的值进行处理）
        for (User user : list) {
            Address address = user.getAddress();
            address.setProvince(address.getProvince() + " 省/市");
            address.setCity(address.getCity() + " 市/区");
        }

        return list;
    }
}
@doc
----</t>
<t tx="swot.20241018105726.6">@language java
@doc
[source,java,linenums,highlight=15]
----
@c
package com.tjise.controller;

import com.tjise.pojo.Address;
import com.tjise.pojo.Result;
import com.tjise.pojo.User;
import com.tjise.service.UserServiceA;
import com.tjise.utils.XmlParserUtils;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class UserController {
    private UserServiceA userService = new UserServiceA();  // 强耦合

    @RequestMapping("/listUser")
    public Result listUser() {
        List&lt;User&gt; list = userService.operatorUser();
        // 3 把封装的数据响应给客户端
        return Result.success(list);
    }
}
@doc
----
</t>
<t tx="swot.20241018105726.7">我们需要从两个方面来进行解耦，分别是 #左边类型# 和 #右边的类实例化#。
====
private [red]#UserDaoA# userDao = [red]#new UserDoaA()#;
====

左边类型使用多态来解耦。

. 定义接口 UserDao
+
[source,java]
----
public interface UserDao {  // 定义接口
    public abstract List&lt;User&gt; operatorUser();  // 抽象方法
}
----

. 实现接口 UserDao
+
[source,java]
----
public class UserDaoA implements UserDao
----

. 使用接口 UserDao 来定义变量类型
+
[source,java]
----
private UserDao userDao = new UserDaoA();
----

详细看下面的代码。
</t>
<t tx="swot.20241018105726.8">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.dao;

import com.tjise.pojo.User;

import java.util.List;

// 接口
public interface UserDao {
    // 抽象方法
    public abstract List&lt;User&gt; operatorUser();
}
@doc
----
</t>
<t tx="swot.20241018105726.9">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.dao;

import com.tjise.controller.UserController;
import com.tjise.pojo.User;
import com.tjise.utils.XmlParserUtils;

import java.util.List;

// public class UserDaoA {
// -- new -- 实现接口 UserDao
public class UserDaoA implements UserDao {

    public List&lt;User&gt; operatorUser() {
        // 1 操作数据（解析 xml 文件，把数据封装到对象中）
        // 动态获取 user.xml 文件绝对路径
        String path = UserController.class.getClassLoader()
                .getResource("user.xml").getPath();
        System.out.println("path = " + path);
        List&lt;User&gt; list = XmlParserUtils.parse(path);
        return list;
    }
}
@doc
----
</t>
<t tx="swot.20241018111146.1">@language asciidoc
先确认写的 sql 语句可以新增记录。

[source,sql]
----
INSERT INTO emp 字段1，字段2 values 值1，值2;

-- id 为自增长，password 有默认值
insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)
values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now());
----

下面定义 Mapper 接口的抽象方法。
</t>
<t tx="swot.20241018111823.1">@language java
测试 Mapper 接口是否可用。
</t>
<t tx="swot.20241018111925.1">@language asciidoc
在数据库中插入数据后自动获取新增记录的 id，专业叫自增主键回填。

用途：在业务逻辑相对复杂一些的应用中，会使用该 id 来处理其他逻辑，而不用再专门去获取一遍该 id。
比如把该 id 与其他表进行关联的操作等等。

可以使用注解 @Options() 来获取自增主键的值。所以 @Options 会和 @Insert 配合一起使用。
</t>
<t tx="swot.20241018163833.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.mapper;

import com.tjise.pojo.Emp;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface EmpMapper {

    // 省略其他代码显示
    @others
    // 这条语句是写死的测试
    // @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
            //  values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now())")

    // 这条语句是接收传入的实体对象
    /* 方法的参数是一个实体类对象，取实体类对象中的属性为: #{成员变量名} */
    @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
            " values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")
    public abstract void insertEmp(Emp emp);
}
@doc
----
</t>
<t tx="swot.20241018164917.1">/* 删除记录接口方法如下 */

// @Delete("delete from emp where id = #{id}")
@Delete("delete from emp where id = ${id}")
public abstract void deleteEmpById(Integer id);

// 两种情况测试代码
@Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
public abstract void deleteFromTableById(String tableName);
</t>
<t tx="swot.20241018165656.1">@language java
@doc
接下来，我们就可以直接在单元测试类中通过 @Autowired 注解 EmpMapper 接口。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    // 省略其他代码显示
    @others

    @Test
    public void insertEmpTest(){
        // 创建实体类对象
        Emp emp = new Emp();
        emp.setUsername("yufan");
        emp.setName("叶凡");
        emp.setGender((short) 2);
        emp.setImage("2.png");
        emp.setJob((short) 2);      // 讲师
        emp.setEntrydate(LocalDate.of(2003,2,10));
        emp.setDeptId(2);   // 先随便给个数值吧
        emp.setCreateTime(LocalDateTime.now());
        emp.setUpdateTime(LocalDateTime.now());

        empMapper.insertEmp(emp);
    }
}
@doc
----

.控制台打印插入记录成功，并返回主键 id
....
==&gt;  Preparing: insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (?, ?, ?, ?, ?, ?, ?, ?, ?)
==&gt; Parameters: yufan(String), 叶凡(String), 2(Short), 2.png(String), 2(Short), 2003-02-10(LocalDate), 2(Integer), 2024-10-19T13:00:48.257(LocalDateTime), 2024-10-19T13:00:48.257(LocalDateTime)
&lt;==    Updates: 1
....
</t>
<t tx="swot.20241018170027.1">@Test
void deleteEmpByIdTest() {
    empMapper.deleteEmpById(17);
}

@Test
void deleteFromTableByIdTest() {
    empMapper.deleteFromTableById("emp");
}
</t>
<t tx="swot.20241019073624.1">@language java
@doc
[source,java,linenums,highlight=17]
----
@c
package com.tjise.mapper;

import com.tjise.pojo.Emp;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Options;

@Mapper
public interface EmpMapper {

    // 省略其他代码显示
    @others

//  @Options 需要三个参数，给两个就行 keyColumn 是数据库表字段名，keyProperty 是实体类属性
//  @Options(useGeneratedKeys = true, keyColumn = "id", keyProperty = "id")
    @Options(useGeneratedKeys = true, keyProperty = "id")  // &lt;1&gt;

//  @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
//  values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now())")  // &lt;2&gt;
    @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
            " values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")  // &lt;3&gt;
    public abstract void insertEmp(Emp emp);
}
@doc
----

&lt;1&gt; 自增主键回填
&lt;2&gt; @Insert() 方法直接插入死的数据演示
&lt;3&gt; @Insert() 方法的参数是一个实体类对象，取实体类对象中的属性为: #{成员变量名}
</t>
<t tx="swot.20241019073624.2">/* 删除记录接口方法如下 */

// @Delete("delete from emp where id = #{id}")
@Delete("delete from emp where id = ${id}")
public abstract void deleteEmpById(Integer id);

// 两种情况测试代码
@Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
public abstract void deleteFromTableById(String tableName);
</t>
<t tx="swot.20241019132212.1">@language java
@doc
接下来，我们就可以直接在单元测试类中查看自增主键 id 是否生成成功。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    // 省略其他代码显示
    @others

    @Test
    public void insertEmpTest(){
        // 创建实体类对象
        Emp emp = new Emp();
        emp.setUsername("zhouyuan");
        emp.setName("周元");
        emp.setGender((short) 2);
        emp.setImage("2.png");
        emp.setJob((short) 2);      // 讲师
        emp.setEntrydate(LocalDate.of(2003,2,10));
        emp.setDeptId(2);   // 先随便给个数值吧
        emp.setCreateTime(LocalDateTime.now());
        emp.setUpdateTime(LocalDateTime.now());

        empMapper.insertEmp(emp);
        System.out.println("emp.id: " + emp.getId());
    }
}
@doc
----

.控制台打印插入记录成功，并返回主键 id
....
==&gt;  Preparing: insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (?, ?, ?, ?, ?, ?, ?, ?, ?)
==&gt; Parameters: zhouyuan(String), 周元(String), 2(Short), 2.png(String), 2(Short), 2003-02-10(LocalDate), 2(Integer), 2024-10-19T13:00:48.257(LocalDateTime), 2024-10-19T13:00:48.257(LocalDateTime)
&lt;==    Updates: 1

emp.id: 22  -&gt; 自增主键 id 生成了
....
</t>
<t tx="swot.20241019132212.2">@Test
void deleteEmpByIdTest() {
    empMapper.deleteEmpById(17);
}

@Test
void deleteFromTableByIdTest() {
    empMapper.deleteFromTableById("emp");
}
</t>
<t tx="swot.20241019134748.1"></t>
<t tx="swot.20241019134827.1"></t>
<t tx="swot.20241019140657.1">@language asciidoc
先确认写的 sql 语句可以更新记录。

[source,sql]
----
UPDATE 表名 SET 字段名1 = 新值1, 字段名n = 新值n WHERE 条件;

UPDATE emp SET username = 'shihao', name = '石昊', gender = 1 , image = '1.jpg' , job = 2, entrydate = '2012-01-01', dept_id = 2, update_time = '2022-10-01 12:12:12' WHERE id = 18;
----

下面定义 Mapper 接口的抽象方法。
</t>
<t tx="swot.20241019141143.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.mapper;

import com.tjise.pojo.Emp;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Update;

@Mapper
public interface EmpMapper {

    // 省略其他代码显示
    @others

    // 注意 #{这儿是类的成员变量名}
    @Update("update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}")
    public abstract void updateEmp(Emp emp);
}
@doc
----
</t>
<t tx="swot.20241019141143.2">/* 删除记录接口方法如下 */

// @Delete("delete from emp where id = #{id}")
@Delete("delete from emp where id = ${id}")
public abstract void deleteEmpById(Integer id);

// 两种情况测试代码
@Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
public abstract void deleteFromTableById(String tableName);


// @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        //  values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now())")
/* 方法的参数是一个实体类对象，取实体类对象中的属性为: #{成员变量名} */
@Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        " values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")
public abstract void insertEmp(Emp emp);
</t>
<t tx="swot.20241019194520.1">@language java
@doc
接下来，我们在测试类中测试更改数据库记录。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    // 省略其他代码显示
    @others

    @Test
    public void updateEmpTest(){
        // 创建实体类对象
        Emp emp = new Emp();
        emp.setId(18);
        emp.setUsername("fanghan");
        emp.setName("方寒");
        emp.setGender((short) 2);
        emp.setImage("2.png");
        emp.setJob((short) 2);      // 讲师
        emp.setEntrydate(LocalDate.of(2003,2,10));
        emp.setDeptId(2);   // 先随便给个数值吧
        emp.setUpdateTime(LocalDateTime.now());

        empMapper.updateEmp(emp);
    }

}
@doc
----

.控制台打印更新记录成功
....
==&gt;  Preparing: update emp set username=?, name=?, gender=?, image=?, job=?, entrydate=?, dept_id=?, update_time=? where id=?
==&gt; Parameters: fanghan(String), 方寒(String), 2(Short), 2.png(String), 2(Short), 2003-02-10(LocalDate), 2(Integer), 2024-10-19T20:05:23.088(LocalDateTime), 18(Integer)
&lt;==    Updates: 1
....
</t>
<t tx="swot.20241019194520.2">@Test
void deleteEmpByIdTest() {
    empMapper.deleteEmpById(17);
}

@Test
void deleteFromTableByIdTest() {
    empMapper.deleteFromTableById("emp");
}

@Test
public void insertEmpTest(){
    // 创建实体类对象
    Emp emp = new Emp();
    emp.setUsername("zhouyuan");
    emp.setName("周元");
    emp.setGender((short) 2);
    emp.setImage("2.png");
    emp.setJob((short) 2);      // 讲师
    emp.setEntrydate(LocalDate.of(2003,2,10));
    emp.setDeptId(2);   // 先随便给个数值吧
    emp.setCreateTime(LocalDateTime.now());
    emp.setUpdateTime(LocalDateTime.now());

    empMapper.insertEmp(emp);
    System.out.println("emp.id: " + emp.getId());
}
</t>
<t tx="swot.20241019195417.1"></t>
<t tx="swot.20241019201320.1"></t>
<t tx="swot.20241019201654.1">@language asciidoc
先确认写的 sql 语句可以查询单条记录。

[source,sql]
----
SELECT * FROM 表名 WHERE 条件;

SELECT * FROM emp WHERE id = 18;
----

下面定义 Mapper 接口的抽象方法。
</t>
<t tx="swot.20241019203857.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.mapper;

import com.tjise.pojo.Emp;
import org.apache.ibatis.annotations.*;

@Mapper
public interface EmpMapper {

    // 省略其他代码显示
    @others

    @Select("select * from emp where id = #{id}")
    public abstract Emp selectEmpById(Integer id);
}
@doc
----
</t>
<t tx="swot.20241019203857.2">/* 删除记录接口方法如下 */

// @Delete("delete from emp where id = #{id}")
@Delete("delete from emp where id = ${id}")
public abstract void deleteEmpById(Integer id);

// 两种情况测试代码
@Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
public abstract void deleteFromTableById(String tableName);


// @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        //  values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now())")
/* 方法的参数是一个实体类对象，取实体类对象中的属性为: #{成员变量名} */
@Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        " values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")
public abstract void insertEmp(Emp emp);


// 注意 #{这儿是类的成员变量名}
@Update("update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}")
public abstract void updateEmp(Emp emp);
</t>
<t tx="swot.20241019212645.1"></t>
<t tx="swot.20241020074923.1">@language asciidoc
在 SQL 语句中，对不一样的列名起别名，别名和实体类属性名一样。
</t>
<t tx="swot.20241020074943.1">@language asciidoc
通过 @Results及@Result 进行手动结果映射。
</t>
<t tx="swot.20241020074953.1">@language asciidoc
开启驼峰命名(推荐): 如果字段名与属性名符合驼峰命名规则，mybatis 会自动通过驼峰命名规则映射。

NOTE: 要使用驼峰命名前提是 实体类的属性 与 数据库表中的字段名严格遵守驼峰命名。

</t>
<t tx="swot.20241020080523.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.mapper;

import com.tjise.pojo.Emp;
import org.apache.ibatis.annotations.*;

@Mapper
public interface EmpMapper {

    // 省略其他代码显示
    @others

    // @Select("select * from emp where id = #{id}")
    @Select("select id, username, password, name, gender, image, job, entrydate, " +
            "dept_id deptId, create_time createTime, update_time updateTime " +
            "from emp where id = #{id}")
    public abstract Emp selectEmpById(Integer id);
}
@doc
----

下面是起别名的语法，在 sql 语句中起别名后就可以正常将数据封装到 Emp 对象了::
    "dept_id deptId, create_time createTime, update_time updateTime "

运行测试类后，控制台打印 emp 数据全了::
    deptId=2, createTime=2024-10-18T15:29:47, updateTime=2024-10-19T20:05:23

....
==&gt;  Preparing: select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime from emp where id = ?
==&gt; Parameters: 18(Integer)
&lt;==    Columns: id, username, password, name, gender, image, job, entrydate, deptId, createTime, updateTime
&lt;==        Row: 18, fanghan, 123456, 方寒, 2, 2.png, 2, 2003-02-10, 2, 2024-10-18 15:29:47, 2024-10-19 20:05:23
&lt;==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@70e889e9]
Emp(id=18, username=fanghan, password=123456, name=方寒, gender=2, image=2.png, job=2, entrydate=2003-02-10, deptId=2, createTime=2024-10-18T15:29:47, updateTime=2024-10-19T20:05:23)
....
</t>
<t tx="swot.20241020080523.2">/* 删除记录接口方法如下 */

// @Delete("delete from emp where id = #{id}")
@Delete("delete from emp where id = ${id}")
public abstract void deleteEmpById(Integer id);

// 两种情况测试代码
@Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
public abstract void deleteFromTableById(String tableName);


// @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        //  values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now())")
/* 方法的参数是一个实体类对象，取实体类对象中的属性为: #{成员变量名} */
@Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        " values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")
public abstract void insertEmp(Emp emp);


// 注意 #{这儿是类的成员变量名}
@Update("update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}")
public abstract void updateEmp(Emp emp);
</t>
<t tx="swot.20241020084506.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.mapper;

import com.tjise.pojo.Emp;
import org.apache.ibatis.annotations.*;

@Mapper
public interface EmpMapper {

    // 省略其他代码显示
    @others

    @Select("select * from emp where id = #{id}")
    // @Select("select id, username, password, name, gender, image, job, entrydate, " +
            // "dept_id deptId, create_time createTime, update_time updateTime " +
            // "from emp where id = #{id}")
    @Results({
        @Result(column = "dept_id",     property = "deptId"),
        @Result(column = "create_time", property = "createTime"),
        @Result(column = "update_time", property = "updateTime")
    })
    public abstract Emp selectEmpById(Integer id);
}
@doc
----

通过 @Results 手动映射，运行测试类后，控制台打印 emp 数据全了::
    deptId=2, createTime=2024-10-18T15:29:47, updateTime=2024-10-19T20:05:23

....
==&gt;  Preparing: select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime from emp where id = ?
==&gt; Parameters: 18(Integer)
&lt;==    Columns: id, username, password, name, gender, image, job, entrydate, deptId, createTime, updateTime
&lt;==        Row: 18, fanghan, 123456, 方寒, 2, 2.png, 2, 2003-02-10, 2, 2024-10-18 15:29:47, 2024-10-19 20:05:23
&lt;==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@70e889e9]
Emp(id=18, username=fanghan, password=123456, name=方寒, gender=2, image=2.png, job=2, entrydate=2003-02-10, deptId=2, createTime=2024-10-18T15:29:47, updateTime=2024-10-19T20:05:23)
....
</t>
<t tx="swot.20241020084506.2">/* 删除记录接口方法如下 */

// @Delete("delete from emp where id = #{id}")
@Delete("delete from emp where id = ${id}")
public abstract void deleteEmpById(Integer id);

// 两种情况测试代码
@Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
public abstract void deleteFromTableById(String tableName);


// @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        //  values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now())")
/* 方法的参数是一个实体类对象，取实体类对象中的属性为: #{成员变量名} */
@Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        " values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")
public abstract void insertEmp(Emp emp);


// 注意 #{这儿是类的成员变量名}
@Update("update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}")
public abstract void updateEmp(Emp emp);
</t>
<t tx="swot.20241020090529.1">@language python
@doc
[source,properties,linenums,highlight=16;17]
----
@c
# 配置文件行最后不能有空格
spring.application.name=mybatis_quickstart-crud

# 驱动类名称
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
# 数据库连接的 url
spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_db
# 连接数据库的用户名
spring.datasource.username=root
# 连接数据库的密码
spring.datasource.password=root

# 指定mybatis输出日志的位置, 输出控制台
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

#开启驼峰命名自动映射，即从经典数据库列名 a_column 映射到经典 Java 属性 名 aColumn。
mybatis.configuration.map-underscore-to-camel-case=true

@doc
----</t>
<t tx="swot.20241020091051.1">@language java
@doc
使用 mybatis.configuration.map-underscore-to-camel-case=true 无需再写其它代码，将 @Results 代码注释。

[source,java,linenums,highlight=16..20]
----
@c
package com.tjise.mapper;

import com.tjise.pojo.Emp;
import org.apache.ibatis.annotations.*;

@Mapper
public interface EmpMapper {

    // 省略其他代码显示
    @others

    @Select("select * from emp where id = #{id}")
    // @Select("select id, username, password, name, gender, image, job, entrydate, " +
            // "dept_id deptId, create_time createTime, update_time updateTime " +
            // "from emp where id = #{id}")
    // @Results({
        // @Result(column = "dept_id",     property = "deptId"),
        // @Result(column = "create_time", property = "createTime"),
        // @Result(column = "update_time", property = "updateTime")
    // })
    public abstract Emp selectEmpById(Integer id);
}
@doc
----

使用 mybatis.configuration.map-underscore-to-camel-case=true 无需再写其它代码，运行测试类后，控制台打印 emp 数据全了::
    deptId=2, createTime=2024-10-18T15:29:47, updateTime=2024-10-19T20:05:23

....
==&gt;  Preparing: select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime from emp where id = ?
==&gt; Parameters: 18(Integer)
&lt;==    Columns: id, username, password, name, gender, image, job, entrydate, deptId, createTime, updateTime
&lt;==        Row: 18, fanghan, 123456, 方寒, 2, 2.png, 2, 2003-02-10, 2, 2024-10-18 15:29:47, 2024-10-19 20:05:23
&lt;==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@70e889e9]
Emp(id=18, username=fanghan, password=123456, name=方寒, gender=2, image=2.png, job=2, entrydate=2003-02-10, deptId=2, createTime=2024-10-18T15:29:47, updateTime=2024-10-19T20:05:23)
....
</t>
<t tx="swot.20241020091051.2">/* 删除记录接口方法如下 */

// @Delete("delete from emp where id = #{id}")
@Delete("delete from emp where id = ${id}")
public abstract void deleteEmpById(Integer id);

// 两种情况测试代码
@Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
public abstract void deleteFromTableById(String tableName);


// @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        //  values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now())")
/* 方法的参数是一个实体类对象，取实体类对象中的属性为: #{成员变量名} */
@Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        " values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")
public abstract void insertEmp(Emp emp);


// 注意 #{这儿是类的成员变量名}
@Update("update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}")
public abstract void updateEmp(Emp emp);
</t>
<t tx="swot.20241020093531.1">@language asciidoc
比如在开发员工管理的列表页面时，我们需要根据条件查询员工信息，查询条件包括：姓名、性别、入职时间。

- 姓名：要求支持模糊匹配
- 性别：要求精确匹配
- 入职时间：要求进行范围查询
- 并且要求根据最后修改时间 update_time 字段进行倒序排序

sql 语句为::
    SELECT * FROM emp WHERE name LIKE '%张%' AND gender = 1 AND entrydate BETWEEN '2000-01-01' AND '2020-01-01' ORDER BY update_time DESC;
</t>
<t tx="swot.20241020100949.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.mapper;

import com.tjise.pojo.Emp;
import org.apache.ibatis.annotations.*;

import java.time.LocalDate;
import java.util.List;

@Mapper
public interface EmpMapper {

    // 省略其他代码显示
    @others

    // 这是一个演示报错的例子
    // '%#{name}%' 生成的 '%?%' 不是占位符，所以此处用 '%#{name}%' 不行
    @Select("select * from emp where name like '%#{name}%' " +
                                "and gender = #{gender} " +
                                "and entrydate between #{begin} and #{end} " +
                                "order by update_time desc")
    // 也因此传入 4 个参数就多了
    public List&lt;Emp&gt; listEmp(
        String name,
        Short gender,
        LocalDate begin,
        LocalDate end
    );
}
@doc
----
</t>
<t tx="swot.20241020100949.2">/* 删除记录接口方法如下 */

// @Delete("delete from emp where id = #{id}")
@Delete("delete from emp where id = ${id}")
public abstract void deleteEmpById(Integer id);

// 两种情况测试代码
@Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
public abstract void deleteFromTableById(String tableName);


// @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        //  values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now())")
/* 方法的参数是一个实体类对象，取实体类对象中的属性为: #{成员变量名} */
@Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        " values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")
public abstract void insertEmp(Emp emp);


// 注意 #{这儿是类的成员变量名}
@Update("update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}")
public abstract void updateEmp(Emp emp);


@Select("select * from emp where id = #{id}")
public abstract Emp selectEmpById(Integer id);

</t>
<t tx="swot.20241020102249.1">@language java
@doc
接下来，我们在测试类中测试多条件查询数据库记录。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    // 省略其他代码显示
    @others

    @Test
    public void listEmpTest() {
        List&lt;Emp&gt; listEmp = empMapper.listEmp(
            "张",
            (short) 1,
            LocalDate.of(2000, 1, 1),
            LocalDate.of(2020, 1, 1)
        );
        for(Emp emp : listEmp){
            System.out.println(emp);
        }
    }

}
@doc
----

运行该测试，将会报上面描述的错误。
</t>
<t tx="swot.20241020102249.2">@Test
void deleteEmpByIdTest() {
    empMapper.deleteEmpById(17);
}

@Test
void deleteFromTableByIdTest() {
    empMapper.deleteFromTableById("emp");
}

@Test
public void insertEmpTest(){
    // 创建实体类对象
    Emp emp = new Emp();
    emp.setUsername("zhouyuan");
    emp.setName("周元");
    emp.setGender((short) 2);
    emp.setImage("2.png");
    emp.setJob((short) 2);      // 讲师
    emp.setEntrydate(LocalDate.of(2003,2,10));
    emp.setDeptId(2);   // 先随便给个数值吧
    emp.setCreateTime(LocalDateTime.now());
    emp.setUpdateTime(LocalDateTime.now());

    empMapper.insertEmp(emp);
    System.out.println("emp.id: " + emp.getId());
}

@Test
public void updateEmpTest(){
    // 创建实体类对象
    Emp emp = new Emp();
    emp.setId(18);
    emp.setUsername("fanghan");
    emp.setName("方寒");
    emp.setGender((short) 2);
    emp.setImage("2.png");
    emp.setJob((short) 2);      // 讲师
    emp.setEntrydate(LocalDate.of(2003,2,10));
    emp.setDeptId(2);   // 先随便给个数值吧
    emp.setUpdateTime(LocalDateTime.now());

    empMapper.updateEmp(emp);
}

@Test
public void selectEmpByIdTest() {
    Emp emp = empMapper.selectEmpById(18);
    System.out.println(emp);  // 有的字段封装失败
}
</t>
<t tx="swot.20241020122951.1">@language asciidoc
如 EmpMapper.java 代码所示，写成 '%#{name}%' 会报参数个数不匹配，报错如下:
....
Caused by: java.sql.SQLException: Parameter index out of range (4 &gt; number of parameters, which is 3)
....

控制台打印生成的 sql 为
....
==&gt;  Preparing: select * from emp where name like '%?%' and gender = ? and entrydate between ? and ? order by update_time desc
....

原因是 '%?%' 不是占位符，只是一个普通字符串。所以传入 4 个参数就多了一个。占位符只能是一个单独的问号 ?

</t>
<t tx="swot.20241020144239.1">@language asciidoc
使用 '%${name}%' 进行字符串拼接，这种方式由于是字符串拼接，并不是预编译的形式，所以效率不高、且存在 SQL 注入风险。但是确实能用。
</t>
<t tx="swot.20241020144239.2">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.mapper;

import com.tjise.pojo.Emp;
import org.apache.ibatis.annotations.*;

import java.time.LocalDate;
import java.util.List;

@Mapper
public interface EmpMapper {

    // 省略其他代码显示
    @others

    // 使用 '%${name}%' 进行字符串拼接，这种方式由于是字符串拼接，并不是预编译的形式，所以效率不高、且存在 SQL 注入风险。但是确实能用。
    @Select("select * from emp where name like '%${name}%' " +
                                "and gender = #{gender} " +
                                "and entrydate between #{begin} and #{end} " +
                                "order by update_time desc")
    public List&lt;Emp&gt; listEmp(
        String name,
        Short gender,
        LocalDate begin,
        LocalDate end
    );
}
@doc
----

.%张% 为字符串拼接
....
==&gt;  Preparing: select * from emp where name like '%张%' and gender = ? and entrydate between ? and ? order by update_time desc
==&gt; Parameters: 1(Short), 2000-01-01(LocalDate), 2020-01-01(LocalDate)
&lt;==    Columns: id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time
&lt;==        Row: 2, zhangwuji, 123456, 张无忌, 1, 2.jpg, 2, 2015-01-01, 2, 2024-10-15 16:48:57, 2024-10-15 16:48:57
&lt;==        Row: 14, zhangsanfeng, 123456, 张三丰, 1, 14.jpg, 2, 2002-08-01, 2, 2024-10-15 16:48:57, 2024-10-15 16:48:57
&lt;==      Total: 2

--- 封装后的对象 ---:
Emp(id=2, username=zhangwuji, password=123456, name=张无忌, gender=1, image=2.jpg, job=2, entrydate=2015-01-01, deptId=2, createTime=2024-10-15T16:48:57, updateTime=2024-10-15T16:48:57)
Emp(id=14, username=zhangsanfeng, password=123456, name=张三丰, gender=1, image=14.jpg, job=2, entrydate=2002-08-01, deptId=2, createTime=2024-10-15T16:48:57, updateTime=2024-10-15T16:48:57)
....</t>
<t tx="swot.20241020144239.3">/* 删除记录接口方法如下 */

// @Delete("delete from emp where id = #{id}")
@Delete("delete from emp where id = ${id}")
public abstract void deleteEmpById(Integer id);

// 两种情况测试代码
@Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
public abstract void deleteFromTableById(String tableName);


// @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        //  values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now())")
/* 方法的参数是一个实体类对象，取实体类对象中的属性为: #{成员变量名} */
@Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        " values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")
public abstract void insertEmp(Emp emp);


// 注意 #{这儿是类的成员变量名}
@Update("update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}")
public abstract void updateEmp(Emp emp);


@Select("select * from emp where id = #{id}")
public abstract Emp selectEmpById(Integer id);

</t>
<t tx="swot.20241020150709.1">@language asciidoc
SQL 语句 `select concat('%', '张', '%');` 执行后得到字符串 "%张%"，所以可以应用在生产的代码中。

这种方式，生成的 SQL 都是预编译的 SQL 语句。性能高、安全。 推荐使用。
</t>
<t tx="swot.20241020154020.1">@language java
@doc
@language asciidoc
[source,java,linenums]
----
@c
package com.tjise.mapper;

import com.tjise.pojo.Emp;
import org.apache.ibatis.annotations.*;

import java.time.LocalDate;
import java.util.List;

@Mapper
public interface EmpMapper {

    // 省略其他代码显示
    @others

    // 使用 sql 中的函数 concat() 替换 '%${name}%'
    @Select("select * from emp where name like concat('%', #{name}, '%') " +
                                "and gender = #{gender} " +
                                "and entrydate between #{begin} and #{end} " +
                                "order by update_time desc")
    public List&lt;Emp&gt; listEmp(
        String name,
        Short gender,
        LocalDate begin,
        LocalDate end
    );
}
@doc
----

.concat('%', ?, '%') 有 SQL 预编译如下所示
....
==&gt;  Preparing: select * from emp where name like concat('%', ?, '%') and gender = ? and entrydate between ? and ? order by update_time desc
==&gt; Parameters: 张(String), 1(Short), 2000-01-01(LocalDate), 2020-01-01(LocalDate)
&lt;==    Columns: id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time
&lt;==        Row: 2, zhangwuji, 123456, 张无忌, 1, 2.jpg, 2, 2015-01-01, 2, 2024-10-15 16:48:57, 2024-10-15 16:48:57
&lt;==        Row: 14, zhangsanfeng, 123456, 张三丰, 1, 14.jpg, 2, 2002-08-01, 2, 2024-10-15 16:48:57, 2024-10-15 16:48:57
&lt;==      Total: 2

--- 封装后的对象 ---:
Emp(id=2, username=zhangwuji, password=123456, name=张无忌, gender=1, image=2.jpg, job=2, entrydate=2015-01-01, deptId=2, createTime=2024-10-15T16:48:57, updateTime=2024-10-15T16:48:57)
Emp(id=14, username=zhangsanfeng, password=123456, name=张三丰, gender=1, image=14.jpg, job=2, entrydate=2002-08-01, deptId=2, createTime=2024-10-15T16:48:57, updateTime=2024-10-15T16:48:57)
....</t>
<t tx="swot.20241020154020.2">/* 删除记录接口方法如下 */

// @Delete("delete from emp where id = #{id}")
@Delete("delete from emp where id = ${id}")
public abstract void deleteEmpById(Integer id);

// 两种情况测试代码
@Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
public abstract void deleteFromTableById(String tableName);


// @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        //  values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now())")
/* 方法的参数是一个实体类对象，取实体类对象中的属性为: #{成员变量名} */
@Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        " values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")
public abstract void insertEmp(Emp emp);


// 注意 #{这儿是类的成员变量名}
@Update("update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}")
public abstract void updateEmp(Emp emp);


@Select("select * from emp where id = #{id}")
public abstract Emp selectEmpById(Integer id);

</t>
<t tx="swot.20241020175210.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:toc:
:toc: right
:toc-title: 目录
:toclevels: 3
</t>
<t tx="swot.20241020191402.1">@language asciidoc
SQL 映射配置文件的需要符合一定规范的:

1. XML 映射文件的名称与 Mapper 接口名称一致，并且将 XML 映射文件和 Mapper 接口放置在相同包下(同包同名)，但是 XML 映射文件要放在 resources 目录下。
* xml 文件内容模板在官网有 https://mybatis.org/mybatis-3/zh_CN/getting-started.html#%E6%8E%A2%E7%A9%B6%E5%B7%B2%E6%98%A0%E5%B0%84%E7%9A%84-sql-%E8%AF%AD%E5%8F%A5[探究已映射的-sql-语句]
* 此例 xml 文件名为: src/main/resources/com/tjise/mapper/EmpMapper.xml
* XML 文件的 文档类型定义（Document Type Definition，DTD）声明部分

+
.src/main/resources/com/tjise/mapper/EmpMapper.xml
[source,xml,linenum]
----
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
----

2. XML映射文件的 namespace 属性与 Mapper 接口全限定名一致。
+
.src/main/resources/com/tjise/mapper/EmpMapper.xml
[source,java,linenums,highlight=5]
----
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;mapper namespace="com.tjise.mapper.EmpMapper"&gt;
&lt;/mapper&gt;
----

3. XML映射文件中 sql 语句的 id 与 Mapper 接口中的方法名一致，并保持参数类型和返回值类型一致。
+
.src/main/resources/com/tjise/mapper/EmpMapper.xml
[source,xml,linenums,highlight=15..20]
....
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;mapper namespace="com.tjise.mapper.EmpMapper"&gt;

  &lt;!-- 
    属性 id 必须与接口中的某个方法绑定, 如方法 listEmp
    属性 resultType 的值是方法的返回值类型，具体参下面注意事项：
        1. 如果方法返回值类型属于 List 集合, 则 resultType 的值是此集合的泛型全限定名, 如下所示。集合的泛型这里指集合中存储的元素的类型。
        2. 返回单条记录也是这样写 com.tjise.pojo.Emp
        3. insert / update / delete 不用写 resultType 属性，因为没有返回值。
  --&gt;

  &lt;select id="listEmp" resultType="com.tjise.pojo.Emp"&gt;
    select * from emp where name like concat('%', #{name}, '%')
             and gender = #{gender}
             and entrydate between #{begin} and #{end}
             order by update_time desc
  &lt;/select&gt;
&lt;/mapper&gt;
....

下面是完整的文件示例，运行看下效果和之前是一样的。
</t>
<t tx="swot.20241021103443.1"></t>
<t tx="swot.20241021103711.1">@first &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
@language xml
@doc
.&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
```xml
@c
&lt;!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;

&lt;mapper namespace="com.tjise.mapper.EmpMapper"&gt;

  &lt;select id="listEmpXml" resultType="com.tjise.pojo.Emp"&gt;
    select * from emp where name like concat('%', #{name}, '%')
                                 and gender = #{gender}
                                 and entrydate between #{begin} and #{end}
                                 order by update_time desc
  &lt;/select&gt;

&lt;/mapper&gt;
@doc
```
</t>
<t tx="swot.20241021111600.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.mapper;

import com.tjise.pojo.Emp;
import org.apache.ibatis.annotations.*;

import java.time.LocalDate;
import java.util.List;

@Mapper
public interface EmpMapper {

    // 省略其他代码显示
    @others

    public List&lt;Emp&gt; listEmpXml(
        String name,
        Short gender,
        LocalDate begin,
        LocalDate end
    );
}
@doc
----</t>
<t tx="swot.20241021111600.2">/* 删除记录接口方法如下 */

// @Delete("delete from emp where id = #{id}")
@Delete("delete from emp where id = ${id}")
public abstract void deleteEmpById(Integer id);

// 两种情况测试代码
@Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
public abstract void deleteFromTableById(String tableName);


// @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        //  values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now())")
/* 方法的参数是一个实体类对象，取实体类对象中的属性为: #{成员变量名} */
@Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        " values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")
public abstract void insertEmp(Emp emp);


// 注意 #{这儿是类的成员变量名}
@Update("update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}")
public abstract void updateEmp(Emp emp);


@Select("select * from emp where id = #{id}")
public abstract Emp selectEmpById(Integer id);


// 使用 sql 中的函数 concat()
@Select("select * from emp where name like concat('%', #{name}, '%') " +
                            "and gender = #{gender} " +
                            "and entrydate between #{begin} and #{end} " +
                            "order by update_time desc")
public List&lt;Emp&gt; listEmp(
    String name,
    Short gender,
    LocalDate begin,
    LocalDate end
);

</t>
<t tx="swot.20241021155916.1">@language asciidoc
if 标签用于判断条件是否成立，使用 test 属性进行条件判断，如果条件为 true，则拼接 SQL。

</t>
<t tx="swot.20241021162613.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    // 省略其他代码显示
    @others

    @Test
    public void listEmpXmlTest() {
        List&lt;Emp&gt; listEmpXml = empMapper.listEmpXml(
            "张",
            (short) 1,
            LocalDate.of(2000, 1, 1),
            LocalDate.of(2020, 1, 1)
        );
        for(Emp emp : listEmpXml){
            System.out.println(emp);
        }
    }

}
@doc
----
.运行该测试代码，在控制台打印查询记录成功
....
==&gt;  Preparing: select * from emp where name like concat('%', ?, '%') and gender = ? and entrydate between ? and ? order by update_time desc
==&gt; Parameters: 张(String), 1(Short), 2000-01-01(LocalDate), 2020-01-01(LocalDate)
&lt;==    Columns: id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time
&lt;==        Row: 2, zhangwuji, 123456, 张无忌, 1, 2.jpg, 2, 2015-01-01, 2, 2024-10-15 16:48:57, 2024-10-15 16:48:57
&lt;==        Row: 14, zhangsanfeng, 123456, 张三丰, 1, 14.jpg, 2, 2002-08-01, 2, 2024-10-15 16:48:57, 2024-10-15 16:48:57
&lt;==      Total: 2
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@573284a5]
Emp(id=2, username=zhangwuji, password=123456, name=张无忌, gender=1, image=2.jpg, job=2, entrydate=2015-01-01, deptId=2, createTime=2024-10-15T16:48:57, updateTime=2024-10-15T16:48:57)
Emp(id=14, username=zhangsanfeng, password=123456, name=张三丰, gender=1, image=14.jpg, job=2, entrydate=2002-08-01, deptId=2, createTime=2024-10-15T16:48:57, updateTime=2024-10-15T16:48:57)
....</t>
<t tx="swot.20241021162613.2">@Test
void deleteEmpByIdTest() {
    empMapper.deleteEmpById(17);
}

@Test
void deleteFromTableByIdTest() {
    empMapper.deleteFromTableById("emp");
}

@Test
public void insertEmpTest(){
    // 创建实体类对象
    Emp emp = new Emp();
    emp.setUsername("zhouyuan");
    emp.setName("周元");
    emp.setGender((short) 2);
    emp.setImage("2.png");
    emp.setJob((short) 2);      // 讲师
    emp.setEntrydate(LocalDate.of(2003,2,10));
    emp.setDeptId(2);   // 先随便给个数值吧
    emp.setCreateTime(LocalDateTime.now());
    emp.setUpdateTime(LocalDateTime.now());

    empMapper.insertEmp(emp);
    System.out.println("emp.id: " + emp.getId());
}

@Test
public void updateEmpTest(){
    // 创建实体类对象
    Emp emp = new Emp();
    emp.setId(18);
    emp.setUsername("fanghan");
    emp.setName("方寒");
    emp.setGender((short) 2);
    emp.setImage("2.png");
    emp.setJob((short) 2);      // 讲师
    emp.setEntrydate(LocalDate.of(2003,2,10));
    emp.setDeptId(2);   // 先随便给个数值吧
    emp.setUpdateTime(LocalDateTime.now());

    empMapper.updateEmp(emp);
}

@Test
public void selectEmpByIdTest() {
    Emp emp = empMapper.selectEmpById(18);
    System.out.println(emp);  // 有的字段封装失败
}

@Test
public void listEmpTest() {
    List&lt;Emp&gt; listEmp = empMapper.listEmp(
        "张",
        (short) 1,
        LocalDate.of(2000, 1, 1),
        LocalDate.of(2020, 1, 1)
    );
    for(Emp emp : listEmp){
        System.out.println(emp);
    }
}</t>
<t tx="swot.20241021164304.1">@first &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
@language xml
@doc
.&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
```xml
@c
&lt;!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;

&lt;mapper namespace="com.tjise.mapper.EmpMapper"&gt;

    &lt;!-- 省略其他代码显示 --&gt;
    @others

    &lt;!-- if 标签 --&gt;
    &lt;!-- 因为 select 有返回值，所以需要写 resultType --&gt;
    &lt;select id="listEmpXmlIf" resultType="com.tjise.pojo.Emp"&gt;
        select * from emp where

        &lt;if test="name != null"&gt;
            name like concat('%', #{name}, '%')
        &lt;/if&gt;

        &lt;if test="gender != null"&gt;
            and gender = #{gender}
        &lt;/if&gt;

        &lt;if test="begin != null and end != null"&gt;
            and entrydate between #{begin} and #{end}
        &lt;/if&gt;

        order by update_time desc
    &lt;/select&gt;

&lt;/mapper&gt;
@doc
```
</t>
<t tx="swot.20241021164309.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise.mapper;

import com.tjise.pojo.Emp;
import org.apache.ibatis.annotations.*;

import java.time.LocalDate;
import java.util.List;

@Mapper
public interface EmpMapper {

    // 省略其他代码显示
    @others

    public List&lt;Emp&gt; listEmpXmlIf(
        String name,
        Short gender,
        LocalDate begin,
        LocalDate end
    );
}
@doc
----</t>
<t tx="swot.20241021164309.2">/* 删除记录接口方法如下 */

// @Delete("delete from emp where id = #{id}")
@Delete("delete from emp where id = ${id}")
public abstract void deleteEmpById(Integer id);

// 两种情况测试代码
@Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
public abstract void deleteFromTableById(String tableName);


// @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        //  values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now())")
/* 方法的参数是一个实体类对象，取实体类对象中的属性为: #{成员变量名} */
@Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        " values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")
public abstract void insertEmp(Emp emp);


// 注意 #{这儿是类的成员变量名}
@Update("update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}")
public abstract void updateEmp(Emp emp);


@Select("select * from emp where id = #{id}")
public abstract Emp selectEmpById(Integer id);


// 使用 sql 中的函数 concat()
@Select("select * from emp where name like concat('%', #{name}, '%') " +
                            "and gender = #{gender} " +
                            "and entrydate between #{begin} and #{end} " +
                            "order by update_time desc")
public List&lt;Emp&gt; listEmp(
    String name,
    Short gender,
    LocalDate begin,
    LocalDate end
);

public List&lt;Emp&gt; listEmpXml(
    String name,
    Short gender,
    LocalDate begin,
    LocalDate end
);
</t>
<t tx="swot.20241021164313.1" annotate="7d71002858080000007072696f7269747971014b01580a000000707269736574646174657102580a000000323032342d31302d32317103752e" icons="5d71007d7101285804000000747970657102580400000066696c657103680358320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269312e706e677104580700000072656c506174687105580d000000636c656f2f707269312e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d5808000000636c656f49636f6e710e580100000031710f75612e">@language java
@doc
全部参数都给正常值的情况。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    public void listEmpXmlIfTest() {  // &lt;1&gt;
        List&lt;Emp&gt; listEmpXmlIf = empMapper.listEmpXmlIf(
            "张",
            (short) 1,
            LocalDate.of(2000, 1, 1),
            LocalDate.of(2020, 1, 1)
        );
        for(Emp emp : listEmpXmlIf){
            System.out.println(emp);
        }
    }

}
@doc
----
&lt;1&gt; 测试通过，4 个参数都给了，所以 sql 语句正确为

    `select * from emp where name like concat('%', ?, '%') and gender = ? and entrydate between ? and ? order by update_time desc`
+
....
==&gt;  Preparing: select * from emp where name like concat('%', ?, '%') and gender = ? and entrydate between ? and ? order by update_time desc
==&gt; Parameters: 张(String), 1(Short), 2000-01-01(LocalDate), 2020-01-01(LocalDate)
&lt;==    Columns: id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time
&lt;==        Row: 2, zhangwuji, 123456, 张无忌, 1, 2.jpg, 2, 2015-01-01, 2, 2024-10-15 16:48:57, 2024-10-15 16:48:57
&lt;==        Row: 14, zhangsanfeng, 123456, 张三丰, 1, 14.jpg, 2, 2002-08-01, 2, 2024-10-15 16:48:57, 2024-10-15 16:48:57
&lt;==      Total: 2
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@87b5b49]
Emp(id=2, username=zhangwuji, password=123456, name=张无忌, gender=1, image=2.jpg, job=2, entrydate=2015-01-01, deptId=2, createTime=2024-10-15T16:48:57, updateTime=2024-10-15T16:48:57)
Emp(id=14, username=zhangsanfeng, password=123456, name=张三丰, gender=1, image=14.jpg, job=2, entrydate=2002-08-01, deptId=2, createTime=2024-10-15T16:48:57, updateTime=2024-10-15T16:48:57)
....</t>
<t tx="swot.20241021165158.1">&lt;select id="listEmpXml" resultType="com.tjise.pojo.Emp"&gt;
  select * from emp where name like concat('%', #{name}, '%')
                               and gender = #{gender}
                               and entrydate between #{begin} and #{end}
                               order by update_time desc
&lt;/select&gt;

</t>
<t tx="swot.20241021173757.1"></t>
<t tx="swot.20241021173920.1" annotate="7d71002858080000007072696f7269747971014b02580a000000707269736574646174657102580a000000323032342d31302d32317103752e" icons="5d71007d7101285804000000747970657102580400000066696c657103680358320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269322e706e677104580700000072656c506174687105580d000000636c656f2f707269322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d5808000000636c656f49636f6e710e580100000031710f75612e">@language java
@doc
时间范围参数都给 null 的情况。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    public void listEmpXmlIfTest() {
        List&lt;Emp&gt; listEmpXmlIf = empMapper.listEmpXmlIf(
            "张",
            (short) 1,
            null,   // 不给值看下生成的 sql
            null
        );
        for(Emp emp : listEmpXmlIf){
            System.out.println(emp);
        }
    }
}
@doc
----

测试通过，从下面控制台打印的结果可以看出 sql 语句有变化了（因为数据库的记录只有2个人姓张，所以取出来的还是那两条记录）。这个 sql 语句是正确的。

    `select * from emp where name like concat('%', ?, '%') and gender = ? order by update_time desc`
+
.控制台打印查询记录成功
....
==&gt;  Preparing: select * from emp where name like concat('%', ?, '%') and gender = ? order by update_time desc
==&gt; Parameters: 张(String), 1(Short)
&lt;==    Columns: id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time
&lt;==        Row: 2, zhangwuji, 123456, 张无忌, 1, 2.jpg, 2, 2015-01-01, 2, 2024-10-15 16:48:57, 2024-10-15 16:48:57
&lt;==        Row: 14, zhangsanfeng, 123456, 张三丰, 1, 14.jpg, 2, 2002-08-01, 2, 2024-10-15 16:48:57, 2024-10-15 16:48:57
&lt;==      Total: 2
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@87b5b49]
Emp(id=2, username=zhangwuji, password=123456, name=张无忌, gender=1, image=2.jpg, job=2, entrydate=2015-01-01, deptId=2, createTime=2024-10-15T16:48:57, updateTime=2024-10-15T16:48:57)
Emp(id=14, username=zhangsanfeng, password=123456, name=张三丰, gender=1, image=14.jpg, job=2, entrydate=2002-08-01, deptId=2, createTime=2024-10-15T16:48:57, updateTime=2024-10-15T16:48:57)
....</t>
<t tx="swot.20241021202253.1" annotate="7d71002858080000007072696f7269747971014b03580a000000707269736574646174657102580a000000323032342d31302d32317103752e" icons="5d71007d7101285804000000747970657102580400000066696c657103680358320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269332e706e677104580700000072656c506174687105580d000000636c656f2f707269332e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d5808000000636c656f49636f6e710e580100000031710f75612e">@language java
@doc
全部参数都给 null 的情况。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    public void listEmpXmlIfTest() {
        List&lt;Emp&gt; listEmpXmlIf = empMapper.listEmpXmlIf(
            null,
            null,
            null,
            null
        );
        for(Emp emp : listEmpXmlIf){
            System.out.println(emp);
        }
    }
}
@doc
----

测试报错，从控制台打印结果可以看出所有参数都给 null，sql 语句多了一个 where 关键字，语法不对导致报错。

....
==&gt;  Preparing: select * from emp where       order by update_time desc
==&gt; Parameters: 
org.springframework.jdbc.BadSqlGrammarException
....</t>
<t tx="swot.20241021203300.1" annotate="7d71002858080000007072696f7269747971014b04580a000000707269736574646174657102580a000000323032342d31302d32317103752e" icons="5d71007d7101285804000000747970657102580400000066696c657103680358320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269342e706e677104580700000072656c506174687105580d000000636c656f2f707269342e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d5808000000636c656f49636f6e710e580100000031710f75612e">@language java
@doc
只有性别的情况。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    public void listEmpXmlIfTest() {
        List&lt;Emp&gt; listEmpXmlIf = empMapper.listEmpXmlIf(
            null,
            (short) 1,
            null,
            null
        );
        for(Emp emp : listEmpXmlIf){
            System.out.println(emp);
        }
    }
}
@doc
----

测试报错，从控制台打印结果可以看出 sql 语句多了 where and 两个关键字，语法不对导致报错。

....
==&gt;  Preparing: select * from emp where and gender = ? order by update_time desc
==&gt; Parameters: 1(Short)
org.springframework.jdbc.BadSqlGrammarException: 
....</t>
<t tx="swot.20241021204112.1">@language asciidoc
where 元素只会在子元素有内容的情况下才插入 where 子句。而且会自动去除子句的开头的 AND 或 OR。
</t>
<t tx="swot.20241021204202.1">@first &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
@language xml
@doc
使用 &lt;where&gt;&lt;/where&gt; 标签后，再测试上面的几种情况，发现都正常了。

.&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
```xml
@c
&lt;!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;

&lt;mapper namespace="com.tjise.mapper.EmpMapper"&gt;

    &lt;!-- 省略其他代码显示 --&gt;
    @others

    &lt;!-- if 标签 --&gt;
    &lt;select id="listEmpXmlIf" resultType="com.tjise.pojo.Emp"&gt;
        select * from emp
        &lt;where&gt;
            &lt;if test="name != null"&gt;
                name like concat('%', #{name}, '%')
            &lt;/if&gt;

            &lt;if test="gender != null"&gt;
                and gender = #{gender}
            &lt;/if&gt;

            &lt;if test="begin != null and end != null"&gt;
                and entrydate between #{begin} and #{end}
            &lt;/if&gt;
        &lt;/where&gt;
        order by update_time desc
    &lt;/select&gt;

&lt;/mapper&gt;
@doc
```
</t>
<t tx="swot.20241021204202.2">&lt;select id="listEmpXml" resultType="com.tjise.pojo.Emp"&gt;
  select * from emp where name like concat('%', #{name}, '%')
                               and gender = #{gender}
                               and entrydate between #{begin} and #{end}
                               order by update_time desc
&lt;/select&gt;

</t>
<t tx="swot.20241021204736.1" annotate="7d71002858080000007072696f7269747971014b01580a000000707269736574646174657102580a000000323032342d31302d32317103752e" icons="5d71007d7101285804000000747970657102580400000066696c657103680358320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269312e706e677104580700000072656c506174687105580d000000636c656f2f707269312e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d5808000000636c656f49636f6e710e580100000031710f75612e">@language java
@doc
全部参数都给正常值的情况。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    public void listEmpXmlIfTest() {
        List&lt;Emp&gt; listEmpXmlIf = empMapper.listEmpXmlIf(
            "张",
            (short) 1,
            LocalDate.of(2000, 1, 1),
            LocalDate.of(2020, 1, 1)
        );
        for(Emp emp : listEmpXmlIf){
            System.out.println(emp);
        }
    }

}
@doc
----
.测试通过，4 个参数都给了，sql 语句正确。
....
select * from emp WHERE name like concat('%', ?, '%') and gender = ? and entrydate between ? and ? order by update_time desc
....</t>
<t tx="swot.20241021205103.1" annotate="7d71002858080000007072696f7269747971014b02580a000000707269736574646174657102580a000000323032342d31302d32317103752e" icons="5d71007d7101285804000000747970657102580400000066696c657103680358320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269322e706e677104580700000072656c506174687105580d000000636c656f2f707269322e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d5808000000636c656f49636f6e710e580100000031710f75612e">@language java
@doc
时间范围参数都给 null 的情况。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    public void listEmpXmlIfTest() {
        List&lt;Emp&gt; listEmpXmlIf = empMapper.listEmpXmlIf(
            "张",
            (short) 1,
            null,   // 不给值看下生成的 sql
            null
        );
        for(Emp emp : listEmpXmlIf){
            System.out.println(emp);
        }
    }
}
@doc
----

.测试通过，控制台打印生成的 sql 语句正确。
....
select * from emp WHERE name like concat('%', ?, '%') and gender = ? order by update_time desc
....</t>
<t tx="swot.20241021205410.1" annotate="7d71002858080000007072696f7269747971014b03580a000000707269736574646174657102580a000000323032342d31302d32317103752e" icons="5d71007d7101285804000000747970657102580400000066696c657103680358320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269332e706e677104580700000072656c506174687105580d000000636c656f2f707269332e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d5808000000636c656f49636f6e710e580100000031710f75612e">@language java
@doc
全部参数都给 null 的情况。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    public void listEmpXmlIfTest() {
        List&lt;Emp&gt; listEmpXmlIf = empMapper.listEmpXmlIf(
            null,
            null,
            null,
            null
        );
        for(Emp emp : listEmpXmlIf){
            System.out.println(emp);
        }
    }
}
@doc
----

.测试通过，控制台打印生成的 sql 语句正确。
....
select * from emp order by update_time desc
....</t>
<t tx="swot.20241021205922.1" annotate="7d71002858080000007072696f7269747971014b04580a000000707269736574646174657102580a000000323032342d31302d32317103752e" icons="5d71007d7101285804000000747970657102580400000066696c657103680358320000002f55736572732f73776f742f6170702f6c656f2d656469746f722f6c656f2f49636f6e732f636c656f2f707269342e706e677104580700000072656c506174687105580d000000636c656f2f707269342e706e677106580500000077686572657107580e0000006265666f7265486561646c696e6571085807000000796f666673657471094b005807000000786f6666736574710a4b02580400000078706164710b4b0158020000006f6e710c5805000000766e6f6465710d5808000000636c656f49636f6e710e580100000031710f75612e">@language java
@doc
只有性别的情况。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    public void listEmpXmlIfTest() {
        List&lt;Emp&gt; listEmpXmlIf = empMapper.listEmpXmlIf(
            null,
            (short) 1,
            null,
            null
        );
        for(Emp emp : listEmpXmlIf){
            System.out.println(emp);
        }
    }
}
@doc
----

.测试通过，控制台打印生成的 sql 语句正确。
....
select * from emp WHERE gender = ? order by update_time desc
....</t>
<t tx="swot.20241022122122.1">@language asciidoc
完善更新员工功能，修改为动态更新员工数据信息。

* 如果字段有值，则更新
* 如果字段无值，则不更新

解决方案：动态 SQL

先来看下面之前的解决方案，如 EmpMapper.java 中的 @update 语句。

[source,java]
----
@Update("update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}")
public abstract void updateEmp(Emp emp);
----

[WARNING]
====
存在问题：只要一个字段改变，这个语句会设置所有的字段。比如只更新 username 字段，emp 对象传入的属性除了 username 有值外，其他属性都是 null，则这条语句将数据库中的其他字段都给设置成 null 了。这就出现 bug 了。
====

我们可以使用 &lt;if&gt; 标签配合 &lt;set&gt; 标签来解决该问题。过程分析如下所示。

NOTE: &lt;set&gt; 标签可以动态地在行首插入 SET 关键字，并会删掉额外的逗号。(用在 update 语句中)
</t>
<t tx="swot.20241022130715.1">@language java
@doc
.使用 xml 后的 EmpMapper
[source,java,linenums]
----
@c
package com.tjise.mapper;

import com.tjise.pojo.Emp;
import org.apache.ibatis.annotations.*;

import java.time.LocalDate;
import java.util.List;

@Mapper
public interface EmpMapper {

    // 省略其他代码显示
    @others

    public abstract void updateEmpXml(Emp emp);
}
@doc
----</t>
<t tx="swot.20241022130715.2">/* 删除记录接口方法如下 */

// @Delete("delete from emp where id = #{id}")
@Delete("delete from emp where id = ${id}")
public abstract void deleteEmpById(Integer id);

// 两种情况测试代码
@Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
public abstract void deleteFromTableById(String tableName);


// @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        //  values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now())")
/* 方法的参数是一个实体类对象，取实体类对象中的属性为: #{成员变量名} */
@Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        " values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")
public abstract void insertEmp(Emp emp);


// 注意 #{这儿是类的成员变量名}
@Update("update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}")
public abstract void updateEmp(Emp emp);


@Select("select * from emp where id = #{id}")
public abstract Emp selectEmpById(Integer id);


// 使用 sql 中的函数 concat()
@Select("select * from emp where name like concat('%', #{name}, '%') " +
                            "and gender = #{gender} " +
                            "and entrydate between #{begin} and #{end} " +
                            "order by update_time desc")
public List&lt;Emp&gt; listEmp(
    String name,
    Short gender,
    LocalDate begin,
    LocalDate end
);

public List&lt;Emp&gt; listEmpXml(
    String name,
    Short gender,
    LocalDate begin,
    LocalDate end
);

public List&lt;Emp&gt; listEmpXmlIf(
    String name,
    Short gender,
    LocalDate begin,
    LocalDate end
);
</t>
<t tx="swot.20241022131317.1">@first &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
@language xml
@doc
增加 &lt;if&gt; 标签后

.&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
```xml
@c
&lt;!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;

&lt;mapper namespace="com.tjise.mapper.EmpMapper"&gt;

    &lt;!-- 省略其他代码显示 --&gt;
    @others

    &lt;update id="updateEmpXml"&gt;
        update emp set
            &lt;if test="username   != null"&gt; username    = #{username},   &lt;/if&gt;
            &lt;if test="name       != null"&gt; name        = #{name},       &lt;/if&gt;
            &lt;if test="gender     != null"&gt; gender      = #{gender},     &lt;/if&gt;
            &lt;if test="image      != null"&gt; image       = #{image},      &lt;/if&gt;
            &lt;if test="job        != null"&gt; job         = #{job},        &lt;/if&gt;
            &lt;if test="entrydate  != null"&gt; entrydate   = #{entrydate},  &lt;/if&gt;
            &lt;if test="deptId     != null"&gt; dept_id     = #{deptId},     &lt;/if&gt;
            &lt;if test="updateTime != null"&gt; update_time = #{updateTime}  &lt;/if&gt;
        where id = #{id}
    &lt;/update&gt;

&lt;/mapper&gt;
@doc
```
</t>
<t tx="swot.20241022131317.2">&lt;select id="listEmpXml" resultType="com.tjise.pojo.Emp"&gt;
  select * from emp where name like concat('%', #{name}, '%')
                               and gender = #{gender}
                               and entrydate between #{begin} and #{end}
                               order by update_time desc
&lt;/select&gt;


&lt;!-- if 标签 --&gt;
&lt;select id="listEmpXmlIf" resultType="com.tjise.pojo.Emp"&gt;
    select * from emp
    &lt;where&gt;
        &lt;if test="name != null"&gt;
            name like concat('%', #{name}, '%')
        &lt;/if&gt;

        &lt;if test="gender != null"&gt;
            and gender = #{gender}
        &lt;/if&gt;

        &lt;if test="begin != null and end != null"&gt;
            and entrydate between #{begin} and #{end}
        &lt;/if&gt;
    &lt;/where&gt;
    order by update_time desc
&lt;/select&gt;

</t>
<t tx="swot.20241022135842.1">@language java
@doc
所有参数给全的情况，是正常。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    public void updateEmpXmlTest() {
        // 创建实体类对象
        Emp emp = new Emp();
        emp.setId(18);
        emp.setUsername("shihao");
        emp.setName("石昊");
        emp.setGender((short) 2);
        emp.setImage("2.png");
        emp.setJob((short) 2);      // 讲师
        emp.setEntrydate(LocalDate.of(2003,2,10));
        emp.setDeptId(2);   // 先随便给个数值吧
        emp.setUpdateTime(LocalDateTime.now());
        empMapper.updateEmpXml(emp);
    }
}
@doc
----

.测试通过，控制台打印生成的 sql 语句正确。
....
==&gt;  Preparing: update emp SET username = ?, name = ?, gender = ?, image = ?, job = ?, entrydate = ?, dept_id = ?, update_time = ? where id = ?
==&gt; Parameters: shihao(String), 石昊(String), 2(Short), 2.png(String), 2(Short), 2003-02-10(LocalDate), 2(Integer), 2024-10-22T16:18:16.480(LocalDateTime), 18(Integer)
&lt;==    Updates: 1
....
</t>
<t tx="swot.20241022162213.1">@language asciidoc
先看一次删除多条记录，sql 语句为

```sql
DELETE FROM emp WHERE id IN (1,2,3);
```

TIP: 实际上删除一条或者多条记录都可以使用该语句。

要想能够灵活地删除多条记录，可以使用动态 SQL，如下面代码所示。
</t>
<t tx="swot.20241022162857.1">@first &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
@language xml
@doc
增加 &lt;set&gt; 标签后

.&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
```xml
@c
&lt;!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;

&lt;mapper namespace="com.tjise.mapper.EmpMapper"&gt;

    &lt;!-- 省略其他代码显示 --&gt;
    @others

    &lt;update id="updateEmpXml"&gt;
        update emp
        &lt;set&gt;
            &lt;if test="username   != null"&gt; username    = #{username},   &lt;/if&gt;
            &lt;if test="name       != null"&gt; name        = #{name},       &lt;/if&gt;
            &lt;if test="gender     != null"&gt; gender      = #{gender},     &lt;/if&gt;
            &lt;if test="image      != null"&gt; image       = #{image},      &lt;/if&gt;
            &lt;if test="job        != null"&gt; job         = #{job},        &lt;/if&gt;
            &lt;if test="entrydate  != null"&gt; entrydate   = #{entrydate},  &lt;/if&gt;
            &lt;if test="deptId     != null"&gt; dept_id     = #{deptId},     &lt;/if&gt;
            &lt;if test="updateTime != null"&gt; update_time = #{updateTime}, &lt;/if&gt;
        &lt;/set&gt;
        where id = #{id}
    &lt;/update&gt;

&lt;/mapper&gt;
@doc
```</t>
<t tx="swot.20241022162857.2">&lt;select id="listEmpXml" resultType="com.tjise.pojo.Emp"&gt;
  select * from emp where name like concat('%', #{name}, '%')
                               and gender = #{gender}
                               and entrydate between #{begin} and #{end}
                               order by update_time desc
&lt;/select&gt;


&lt;!-- if 标签 --&gt;
&lt;select id="listEmpXmlIf" resultType="com.tjise.pojo.Emp"&gt;
    select * from emp
    &lt;where&gt;
        &lt;if test="name != null"&gt;
            name like concat('%', #{name}, '%')
        &lt;/if&gt;

        &lt;if test="gender != null"&gt;
            and gender = #{gender}
        &lt;/if&gt;

        &lt;if test="begin != null and end != null"&gt;
            and entrydate between #{begin} and #{end}
        &lt;/if&gt;
    &lt;/where&gt;
    order by update_time desc
&lt;/select&gt;

</t>
<t tx="swot.20241022163517.1"></t>
<t tx="swot.20241022163550.1"></t>
<t tx="swot.20241022163613.1"></t>
<t tx="swot.20241022163949.1"></t>
<t tx="swot.20241022164047.1"></t>
<t tx="swot.20241022164110.1">@language java
@doc
只给了两个字段的值，报错了。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    public void updateEmpXmlTest() {
        // 创建实体类对象
        Emp emp = new Emp();
        emp.setId(18);
        emp.setUsername("wanglin");
        emp.setName("王林");
        empMapper.updateEmpXml(emp);
    }
}
@doc
----

.测试通过，控制台打印生成的 sql 语句错误，多逗号了 `name = ?,`。
....
==&gt;  Preparing: update emp set username = ?, name = ?, where id = ?
==&gt; Parameters: wanglin(String), 王林(String), 18(Integer)
....
</t>
<t tx="swot.20241022164652.1"></t>
<t tx="swot.20241022164758.1"></t>
<t tx="swot.20241022164758.2">@language java
@doc
只给了两个字段的值。

[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    public void updateEmpXmlTest() {
        // 创建实体类对象
        Emp emp = new Emp();
        emp.setId(18);
        emp.setUsername("wanglin");
        emp.setName("王林");
        empMapper.updateEmpXml(emp);
    }
}
@doc
----

.测试通过，控制台打印生成的 sql 语句正确`。
....
==&gt;  Preparing: update emp SET username = ?, name = ? where id = ?
==&gt; Parameters: wanglin(String), 王林(String), 18(Integer)
&lt;==    Updates: 1
....</t>
<t tx="swot.20241022170331.1">@language asciidoc
在 xml 映射文件中配置的 SQL，有时可能会存在很多重复的片段，此时就会存在很多冗余的代码。所以可以：

1. 使用 &lt;sql&gt; 定义共用代码
+
[source,xml]
----
&lt;sql id="deleteIds"&gt;
    DELETE FROM emp WHERE id IN
&lt;/sql&gt;
----

2. 使用 &lt;include&gt; 引用共用代码的
+
[source,sql]
----
&lt;include refid="deleteIds" /&gt;
----
</t>
<t tx="swot.20241022173912.1">@language java
@doc
.使用 xml 后的 EmpMapper
[source,java,linenums]
----
@c
package com.tjise.mapper;

import com.tjise.pojo.Emp;
import org.apache.ibatis.annotations.*;

import java.time.LocalDate;
import java.util.List;

@Mapper
public interface EmpMapper {

    // 省略其他代码显示
    @others

    public abstract void deleteEmpByIdsXml(List&lt;Integer&gt; ids);
}
@doc
----</t>
<t tx="swot.20241022173912.2">/* 删除记录接口方法如下 */

// @Delete("delete from emp where id = #{id}")
@Delete("delete from emp where id = ${id}")
public abstract void deleteEmpById(Integer id);

// 两种情况测试代码
@Delete("delete from #{tableName} where id = 17")  // &lt;1&gt;
//  @Delete("delete from ${tableName} where id = 17")  // &lt;2&gt;
public abstract void deleteFromTableById(String tableName);


// @Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        //  values ('wanglin', '王林', 1, '1.png', 2, '2003-02-10', 2, now(), now())")
/* 方法的参数是一个实体类对象，取实体类对象中的属性为: #{成员变量名} */
@Insert("insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
        " values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})")
public abstract void insertEmp(Emp emp);


// 注意 #{这儿是类的成员变量名}
@Update("update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}")
public abstract void updateEmp(Emp emp);


@Select("select * from emp where id = #{id}")
public abstract Emp selectEmpById(Integer id);


// 使用 sql 中的函数 concat()
@Select("select * from emp where name like concat('%', #{name}, '%') " +
                            "and gender = #{gender} " +
                            "and entrydate between #{begin} and #{end} " +
                            "order by update_time desc")
public List&lt;Emp&gt; listEmp(
    String name,
    Short gender,
    LocalDate begin,
    LocalDate end
);

public List&lt;Emp&gt; listEmpXml(
    String name,
    Short gender,
    LocalDate begin,
    LocalDate end
);

public List&lt;Emp&gt; listEmpXmlIf(
    String name,
    Short gender,
    LocalDate begin,
    LocalDate end
);

public abstract void updateEmpXml(Emp emp);
</t>
<t tx="swot.20241022174234.1">@first &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
@language xml
@doc
增加 &lt;foreach&gt; 标签后

foreach 属性介绍

* collection: 集合名称，传入 mapper 对应方法的参数
* item:       集合遍历出来的元素/项，自己起名字
* separator:  每一次遍历使用的分隔符
* open:       遍历开始前拼接的片段
* close:      遍历结束后拼接的片段

.&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
```xml
@c
&lt;!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;

&lt;mapper namespace="com.tjise.mapper.EmpMapper"&gt;

    &lt;!-- 省略其他代码显示 --&gt;
    @others

    &lt;!-- 参考 sql --&gt;
    &lt;!-- DELETE FROM emp WHERE id IN (1,2,3); --&gt;
    &lt;!-- 需求: 需要使用 foreach 标签将集合 List ids 中的 id 拼接成 (1, 2, 3) --&gt;

    &lt;delete id="deleteEmpByIdsXml"&gt;
        DELETE FROM emp WHERE id IN
        &lt;foreach collection="ids" item="id" open="(" close=")" separator=","&gt;
            #{id}
        &lt;/foreach&gt;
    &lt;/delete&gt;

&lt;/mapper&gt;
@doc
```</t>
<t tx="swot.20241022174234.2">&lt;select id="listEmpXml" resultType="com.tjise.pojo.Emp"&gt;
  select * from emp where name like concat('%', #{name}, '%')
                               and gender = #{gender}
                               and entrydate between #{begin} and #{end}
                               order by update_time desc
&lt;/select&gt;


&lt;!-- if 标签 --&gt;
&lt;select id="listEmpXmlIf" resultType="com.tjise.pojo.Emp"&gt;
    select * from emp
    &lt;where&gt;
        &lt;if test="name != null"&gt;
            name like concat('%', #{name}, '%')
        &lt;/if&gt;

        &lt;if test="gender != null"&gt;
            and gender = #{gender}
        &lt;/if&gt;

        &lt;if test="begin != null and end != null"&gt;
            and entrydate between #{begin} and #{end}
        &lt;/if&gt;
    &lt;/where&gt;
    order by update_time desc
&lt;/select&gt;


&lt;update id="updateEmpXml"&gt;
    update emp
    &lt;set&gt;
        &lt;if test="username   != null"&gt; username    = #{username},   &lt;/if&gt;
        &lt;if test="name       != null"&gt; name        = #{name},       &lt;/if&gt;
        &lt;if test="gender     != null"&gt; gender      = #{gender},     &lt;/if&gt;
        &lt;if test="image      != null"&gt; image       = #{image},      &lt;/if&gt;
        &lt;if test="job        != null"&gt; job         = #{job},        &lt;/if&gt;
        &lt;if test="entrydate  != null"&gt; entrydate   = #{entrydate},  &lt;/if&gt;
        &lt;if test="deptId     != null"&gt; dept_id     = #{deptId},     &lt;/if&gt;
        &lt;if test="updateTime != null"&gt; update_time = #{updateTime}, &lt;/if&gt;
    &lt;/set&gt;
    where id = #{id}
&lt;/update&gt;
</t>
<t tx="swot.20241022222115.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    @Test
    public void deleteEmpByIdsXmlTest() {
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        Collections.addAll(list, 18, 19, 22);
        empMapper.deleteEmpByIdsXml(list);
    }
}
@doc
----

.测试通过，控制台打印生成的 sql 语句正确`。
....
==&gt;  Preparing: DELETE FROM emp WHERE id IN ( ? , ? , ? )
==&gt; Parameters: 18(Integer), 19(Integer), 22(Integer)
&lt;==    Updates: 3
....
</t>
<t tx="swot.20241022231327.1">@first &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
@language xml
@doc
测试一下 &lt;sql&gt; 和 &lt;include&gt; 标签的配合使用。这里只是为了测试该语法，我们的例子里并没有重复的抽取内容。请知晓！

.&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
```xml
@c
&lt;!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;

&lt;mapper namespace="com.tjise.mapper.EmpMapper"&gt;

    &lt;!-- 省略其他代码显示 --&gt;
    @others

    &lt;sql id="deleteIds"&gt;
        DELETE FROM emp WHERE id IN
    &lt;/sql&gt;

    &lt;delete id="deleteEmpByIdsXml"&gt;

        &lt;!-- DELETE FROM emp WHERE id IN --&gt;
        &lt;include refid="deleteIds" /&gt;

        &lt;foreach collection="ids" item="id" open="(" close=")" separator=","&gt;
            #{id}
        &lt;/foreach&gt;
    &lt;/delete&gt;

&lt;/mapper&gt;
@doc
```

执行上面的测试，依然是成功的。

....
==&gt;  Preparing: DELETE FROM emp WHERE id IN ( ? , ? , ? )
==&gt; Parameters: 18(Integer), 19(Integer), 22(Integer)
&lt;==    Updates: 0
....
</t>
<t tx="swot.20241022231327.2">&lt;select id="listEmpXml" resultType="com.tjise.pojo.Emp"&gt;
  select * from emp where name like concat('%', #{name}, '%')
                               and gender = #{gender}
                               and entrydate between #{begin} and #{end}
                               order by update_time desc
&lt;/select&gt;


&lt;!-- if 标签 --&gt;
&lt;select id="listEmpXmlIf" resultType="com.tjise.pojo.Emp"&gt;
    select * from emp
    &lt;where&gt;
        &lt;if test="name != null"&gt;
            name like concat('%', #{name}, '%')
        &lt;/if&gt;

        &lt;if test="gender != null"&gt;
            and gender = #{gender}
        &lt;/if&gt;

        &lt;if test="begin != null and end != null"&gt;
            and entrydate between #{begin} and #{end}
        &lt;/if&gt;
    &lt;/where&gt;
    order by update_time desc
&lt;/select&gt;


&lt;update id="updateEmpXml"&gt;
    update emp
    &lt;set&gt;
        &lt;if test="username   != null"&gt; username    = #{username},   &lt;/if&gt;
        &lt;if test="name       != null"&gt; name        = #{name},       &lt;/if&gt;
        &lt;if test="gender     != null"&gt; gender      = #{gender},     &lt;/if&gt;
        &lt;if test="image      != null"&gt; image       = #{image},      &lt;/if&gt;
        &lt;if test="job        != null"&gt; job         = #{job},        &lt;/if&gt;
        &lt;if test="entrydate  != null"&gt; entrydate   = #{entrydate},  &lt;/if&gt;
        &lt;if test="deptId     != null"&gt; dept_id     = #{deptId},     &lt;/if&gt;
        &lt;if test="updateTime != null"&gt; update_time = #{updateTime}, &lt;/if&gt;
    &lt;/set&gt;
    where id = #{id}
&lt;/update&gt;
</t>
<t tx="swot.20241028143347.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3
</t>
<t tx="swot.20241028143347.10"></t>
<t tx="swot.20241028143347.11">@language java
@doc
.服务端路由 /hello，返回字符串 "Hello World!"
[source,java,linenums]
----
@c
package com.tjise;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @RequestMapping("/hello")
    public String hello(){
        System.out.println("Hello World");
        return "Hello World";
    }
}
@doc
----
</t>
<t tx="swot.20241028143347.12">@language asciidoc
找到引导类: src/main/java/&lt;group&gt;/HelloWorldApplication.java

右键选择运行该引导类

在浏览器中输入地址进行测试: http://localhost:8080/hello

可以看见页面中显示 "Hello World!" 字样。
</t>
<t tx="swot.20241028143347.13"></t>
<t tx="swot.20241028143347.14">@language asciidoc
HTTP 协议：超文本传输协议 Hyper Text Transfer Protocol，规定了浏览器和服务器之间数据传输的规则。


HTTP 协议特点：

1. 基于 TCP 协议: 面向连接，安全。
2. 基于请求--响应模型: 一次请求对应一次响应
3. HTTP 协议是无状态协议: 对于事务处理没有记忆能力。每次请求--响应都是独立的。理解：下一次请求不会携带上一次数据。
  * 缺点：多次请求间不能共享数据。
  * 优点：速度快。


TCP/IP 四层模型:

* 网络接口层 - 管理硬件和本地网络之间的数据通信。
* 网络层 - 处理数据包的路由与传输。
* 传输层 - 提供端到端的可靠或不可靠数据传输。
* 应用层 - 为用户提供网络服务和应用接口。


三者关系:

* IP   协议 在网络层负责将数据从源设备传送到目标设备。
* TCP  协议 在传输层基于IP协议，确保数据传输的可靠性和完整性。
* HTTP 协议 在应用层，使用TCP协议传输HTTP请求和响应，从而实现网页内容的传输。

</t>
<t tx="swot.20241028143347.15">@language asciidoc
您可以在浏览器中打开一个网址，查看 GET 发送的内容。

.GET 请求数据格式
====
.请求行
....
GET /hello HTTP/1.1
....

.请求头 (与请求行之间无空行)
....
Host: localhost:8080
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:131.0) Gecko/20100101 Firefox/131.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate, br, zstd
Connection: keep-alive
Cookie: _ga_E3C3GCQVBN=GS1.1.1727626100.1.1.1727626112.0.0.0; _ga=GA1.1.1602099806.1727626101
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
Sec-Fetch-User: ?1
Priority: u=0, i
....
====

NOTE: GET 请求一般在规范中无请求体，实际上也可以带请求体，只要服务端 api 能处理就行。
</t>
<t tx="swot.20241028143347.16">@language asciidoc
Firefox 浏览器开发者模式支持发 POST 请求，您可以在 Firefox 浏览器中打开一个网址，查看 POST 发送的内容。

.POST 请求数据格式
====
.请求行
....
POST /hello HTTP/1.1
....

.请求头 (与请求行之间无空行)
....
Host: localhost:8080
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:131.0) Gecko/20100101 Firefox/131.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate, br, zstd
Connection: keep-alive
Cookie: _ga_E3C3GCQVBN=GS1.1.1727626100.1.1.1727626112.0.0.0; _ga=GA1.1.1602099806.1727626101
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: no-cors
Sec-Fetch-Site: same-origin
Sec-Fetch-User: ?1
Content-Length: 16
Origin: http://localhost:8080
Priority: u=0, i
Pragma: no-cache
Cache-Control: no-cache
....

.请求体 (与请求头之间有一个空行)，此例发送的是 JSON 数据
....
{"name": "Swot"}
....
====

.firefox 发送 post 请求
[.thumb]
image::img/firefox_post.png[]
</t>
<t tx="swot.20241028143347.17">@language asciidoc
.响应行
....
HTTP/1.1 200
....


.响应头 (与响应行之间无空行)
....
Content-Type: text/html;charset=UTF-8
Content-Length: 11
Date: Wed, 02 Oct 2024 07:17:33 GMT
Keep-Alive: timeout=60
Connection: keep-alive
....


.响应体 (与响应头之间有一个空行)
....
Hello World
....
</t>
<t tx="swot.20241028143347.18">@language asciidoc
参考网址:
https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status

常见响应码:

* 200: 响应成功
* 301/302: 重定向，比如访问 http://www.baidu.com 会被服务器重定向到 https://www.baidu.com，firefox 调试 302 时需要清除缓存并重启浏览器。
* 404: 找不到 url 资源，客户端请求了不存在的资源地址
* 500: 服务器错误
</t>
<t tx="swot.20241028143347.19">@language asciidoc
对请求行、请求头、请求体进行解析。
主要是为了了解解析原理的，自己不会写 web 服务器的代码。我们直接使用 Tomcat 服务器。

使用下面的例子对原理进行了解。
</t>
<t tx="swot.20241028143347.2">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20241028143347.20">@language asciidoc
1. File -&gt; Project Structure 对话框，选择 Modules

2. 点击 + 号，选择 New Module

3. 选择 Java，再填写必要的信息后创建模块，如 simple-http-server

NOTE: 该例子会将请求中的「请求行」、「请求头」、「请求体」都打印出来。

</t>
<t tx="swot.20241028143347.21">@language java
@doc
[source,java,linenums]
----
@c
import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.HashMap;
import java.util.Map;

public class SimpleHttpServer {

    public static void main(String[] args) {
        try (ServerSocket serverSocket = new ServerSocket(8081)) {
            System.out.println("Server started on port 8081...");

            while (true) {
                // serverSocket.accept() 阻塞等待新的客户端连接，一旦有客户端连接，它返回一个 Socket 对象，表示与该客户端之间的通信。
                try (Socket clientSocket = serverSocket.accept()) {
                    handleClient(clientSocket);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void handleClient(Socket clientSocket) throws IOException {
        // 获取输入流读取请求数据
        InputStream input = clientSocket.getInputStream();
        BufferedReader reader = new BufferedReader(new InputStreamReader(input));

        // 解析请求行
        String requestLine = reader.readLine();
        System.out.println("Request Line: " + requestLine);

        // 解析请求头
        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();
        String headerLine;
        while (!(headerLine = reader.readLine()).isEmpty()) {
            String[] header = headerLine.split(": ");
            headers.put(header[0], header[1]);
        }

        System.out.println("\nRequest Headers:");
        for (Map.Entry&lt;String, String&gt; entry : headers.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }

        // 读取请求体 (仅处理 POST 请求)
        if (requestLine.startsWith("POST")) {
            int contentLength = Integer.parseInt(headers.getOrDefault("Content-Length", "0"));
            char[] body = new char[contentLength];
            reader.read(body, 0, contentLength);
            System.out.println("\nRequest Body: ");
            System.out.println(new String(body));
        }

        // 发送响应
        OutputStream output = clientSocket.getOutputStream();
        PrintWriter writer = new PrintWriter(output, true);
        writer.println("HTTP/1.1 200 OK");
        writer.println("Content-Type: text/plain");
        // 正确设置 Content-Length
        String responseBody = "Hello from SimpleHttpServer";
        writer.println("Content-Length: " + responseBody.length());
        writer.println();
        writer.println("Hello from SimpleHttpServer");
    }
}
@doc
----</t>
<t tx="swot.20241028143347.22">@language asciidoc
Web 服务器::
* Web 服务器是一个应用程序（软件），对 HTTP 协议的操作进行封装，使得程序员不必直接对协议进行操作，让 Web 开发更加便捷。
* 主要功能是对请求数据解析，响应数据封装。

Tomcat::
* https://tomcat.apache.org
* Tomcat 是 Apache 软件基金会一个核心项目，是一个开源免费的轻量级 Web 服务器，支持 Servlet/JSP 少量 JavaEE 规范。
* Tomcat 也被称为 Web 容器、Servlet 容器。JavaWeb 的 .war 包需要放在 Tomcat 下才能运行。

.Spring Boot 已经内置了 Tomcat 服务器
[IMPORTANT]
====
* 开发时直接在 IDEA 中运行启动类即可
* 部署时直接运行 java -j xxx.jar 包即可
====

JavaEE::
* Java Enterprise Edition, Java 企业版。指 Java 企业级开发的技术规范总和。
* 包含 13 项技术规范 JDBC, JNDI, EJB, RMI, JSP, Servlet, XML, JMS, Java IDL, JTS, JTA, JavaMail, JAF。

.新技术老规范(了解)
****
有些规范已经老了，有新的基于这些规范的技术出现了。比如

关于Java Enterprise Edition（Java企业版）所包含的13项技术规范，虽然它们是Java企业级开发的基础，但随着时间的推移，确实有一些新的技术基于这些规范发展起来。以下是对这些新技术或相关发展的一些概述：

1. **JDBC（Java Database Connectivity）**：
   - **新技术**：虽然JDBC本身是一个老规范，但基于JDBC的持久层框架如MyBatis和Hibernate等，为Java开发者提供了更高级别的数据库访问抽象，简化了数据库操作并提高了开发效率。
2. **JNDI（Java Naming and Directory Interface）**：
   - **新技术**：随着云计算和微服务架构的兴起，JNDI的使用逐渐减少，因为它更多地与传统的企业级应用服务器（如Tomcat、JBoss等）紧密相关。然而，在微服务架构中，服务发现和配置管理通常通过更现代的工具（如Spring Cloud Config、Consul等）来实现。
3. **EJB（Enterprise JavaBeans）**：
   - **新技术**：EJB曾经是企业级Java应用中的核心组件，但随着Spring框架的兴起，EJB的使用逐渐减少。Spring提供了更轻量级、更灵活的依赖注入和面向切面编程支持，逐渐取代了EJB在Java企业级开发中的地位。
4. **RMI（Remote Method Invocation）**：
   - **新技术**：RMI虽然提供了远程方法调用的能力，但在现代分布式系统中，更常用的技术是RESTful Web服务和基于消息的通信（如使用JMS或Kafka等）。这些技术提供了更灵活、更松散的耦合方式，使得服务之间的交互更加简单和高效。
5. **JSP（JavaServer Pages）和Servlet**：
   - **新技术**：虽然JSP和Servlet仍然是Java Web开发的基础，但随着前端技术的不断发展（如React、Vue等），越来越多的Java Web应用开始采用前后端分离的架构。在这种架构中，JSP和Servlet更多地用于处理后端逻辑和API接口，而前端则使用更现代的框架和库来构建用户界面。
6. **XML（Extensible Markup Language）**：
   - **新技术**：XML虽然仍然是一种重要的数据交换格式，但在现代Web开发中，JSON（JavaScript Object Notation）由于其轻量级和易于解析的特性，逐渐取代了XML的地位。许多现代的Web API和微服务都使用JSON作为数据交换格式。
7. **JMS（Java Message Service）**：
   - **新技术**：JMS提供了基于消息的异步通信机制，但在现代分布式系统中，更常用的消息队列技术包括Kafka、RabbitMQ等。这些技术提供了更高级别的消息处理能力（如持久化、分区、复制等），使得消息传递更加可靠和高效。
8. **Java IDL/CORBA**：
   - **新技术**：随着Web服务和RESTful API的兴起，Java IDL/CORBA的使用逐渐减少。现代分布式系统更倾向于使用轻量级的通信协议（如HTTP/HTTPS）和基于JSON/XML的数据格式来实现服务之间的交互。
9. **JTA（Java Transaction API）和JTS（Java Transaction Service）**：
   - **新技术**：虽然JTA和JTS仍然提供了分布式事务处理的能力，但在现代微服务架构中，事务的边界通常更加清晰和有限。此外，随着数据库技术的发展（如NoSQL数据库的兴起），一些应用开始采用最终一致性而不是强一致性来保证数据的完整性。
10. **JavaMail**：
    - **新技术**：虽然JavaMail仍然是一个用于发送和接收电子邮件的API，但随着云计算和SaaS服务的兴起，越来越多的应用开始使用第三方邮件服务（如SendGrid、Mailgun等）来发送电子邮件。这些服务提供了更可靠、更灵活的邮件发送能力，并且支持多种邮件格式和跟踪功能。
11. **JAF（JavaBeans Activation Framework）**：
    - **新技术**：JAF虽然仍然是一个用于处理MIME类型和数据源的框架，但在现代Web开发中，其使用逐渐减少。许多现代的Web应用都使用更高级别的库和框架来处理文件上传和下载等功能。

需要注意的是，虽然上述技术可能被视为基于Java EE老规范的新发展，但它们并不是完全取代老规范，而是在不同的场景和需求下提供了更灵活、更高效的解决方案。此外，随着技术的不断发展，未来还可能会有更多的新技术出现来进一步丰富和拓展Java企业级开发的生态系统。
****
</t>
<t tx="swot.20241028143347.23">@language asciidoc
Download: https://tomcat.apache.org/download-90.cgi

[NOTE]
====
Tomcat 9 need JDK8，我们使用了 JDK8，所以下载 Tomcat9。

Tomcat 10 need JDK11
====

INSTALL:: 绿色版，直接解压即可

UNINSTALL::  直接删除目录即可

START::
* 双击 bin\startup.bat 或 bin/startup.sh

STOP::
* 强制关闭: 直接 x 掉运行容器
* 正常关闭: bin\shutdown.bat 或 bin/shutdown.sh
* 正常关闭: ctrl+c


PORT::
* 修改 conf/server.xml
+
[source,xml,]
----
&lt;Connector port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443"
           maxParameterCount="1000"
           /&gt;
----
+
* HTTP 协议默认端口号为 80，如果将 Tomcat 端口号改为 80，则将来访问 Tomcat 时，将不用输入端口号。
* 系统进程有可能占用 80 端口，所以还是自己指定一个唯一的端口比较好，以实际需求为准。

</t>
<t tx="swot.20241028143347.24">@language asciidoc
1. 端口号冲突：找到对应程序，将其关闭掉。或者更改 Tomcat 的端口号。
+
....
Caused by: java.net.BindException: Address already in use: bind
....

2. Windows 下启动窗口一闪而过：检查 `JAVA_HOME` 环境变量是否配置正确
* 可以在控制台下执行启动 Tomcat 的命令 statup.bat，查看到报错原因。

3. Windows 控制台中文乱码：修改 conf/logging.properties
+
`java.util.logging.ConsoleHandler.encoding =` [red]`UTF-8 -&gt; GBK`

* 因为 Windows 控制台默认是 GBK 编码

</t>
<t tx="swot.20241028143347.3">@language asciidoc
官网介绍 https://spring.io/

项目介绍 https://spring.io/projects

Spring Boot: https://spring.io/projects/spring-boot
// 应该学习官网的例子

Spring Boot 可以帮助我们非常快速的构建应用程序、简化开发、提高效率。

如果 IDEA 是社区版本，可以使用下面的网页方式来创建 Spring Boot 项目

* 创建 Spring Boot 项目 3 版本 https://start.spring.io/
* 创建 Spring Boot 项目 2 版本 https://start.aliyun.com/

** Project: Maven
** Language: java
** SpringBoot: 2.7.18 https://github.com/spring-projects/spring-boot/releases?q=v2.7&amp;expanded=true
** Group: com.xxx 自己命名
** 打包方式: jar
** java版本: 8
** Dependencies: mysql Driver、Spring Web、lombok（方便创建实体类）
</t>
<t tx="swot.20241028143347.4">@language asciidoc
// New version
// https://bell-sw.com/pages/downloads/#jdk-21-lts

建议下载 jdk-8-lts:
https://bell-sw.com/pages/downloads/#jdk-8-lts

安装文档:
https://docs.bell-sw.com/liberica-jdk/8u422b6/general/install-guide/#microsoft-windows


NOTE: 上面文档是 OpenJDK 的安装方式，实际上我使用的是 Oracle JDK，捂脸ing...


验证安装:
`java -version`

.实际上我的是 Oracle JDK
....
java version "1.8.0_301"
Java(TM) SE Runtime Environment (build 1.8.0_301-b09)
Java HotSpot(TM) 64-Bit Server VM (build 25.301-b09, mixed mode)
....

</t>
<t tx="swot.20241028143347.5">@language asciidoc
创建一个空的工程后，我们可以在该工程中创建或导入多个模块，这样方便不同的功能模块放在一起。

. 运行开发工具 IDEA

. New Project -&gt; Empty Project -&gt; (指空项目名称，如) spring-boot-ketang

. 删除 .iml 文件，因为我们会使用 maven 来管理项目(不使用 idea 来管理项目)。

. 进入 File -&gt; Project Structure 对话框，选择 Modules，删除默认创建的模块(后面我们都是自己来创建模块，在上面删除了 .iml 文件后，默认创建的模块可能会被自动删除)。

[.thumb]
image::img/create_new_project.png[create_new_project,800]

[.thumb]
image::img/create_new_project_check_java_version.png[create_new_project_check_java_version,800]
</t>
<t tx="swot.20241028143347.6">@language asciidoc
需求：使用 Spring Boot 开发一个 web 应用，浏览器发起请求 /hello 后，给浏览器返回字符串 "Hello World!"。

.请求地址
====
http://localhost:8080/hello
====

</t>
<t tx="swot.20241028143347.7">@language asciidoc
https://start.spring.io/

举例创建名称为: hello-spring-boot

1. 填写参数
2. 选择起步依赖

[.thumb]
image::img/spring_initializr.png[]


[WARNING]
====
1. 无法创建 2 系列版本的了
2. 只能创建 3 版本以上的项目了
3. 要求 Java 17 以上

#如果要创建 2 系列版本的项目，可以先创建 3 系列版本的项目，然后再更改 pom.xml 文件。
更改方式参后面导入模块内容#
====


.起步依赖
****
https://docs.spring.io/spring-boot/docs/2.7.18/reference/html/using.html#using.build-systems.starters

起步依赖命名规则

* 官方起步依赖: spring-boot-starter-*
* 第三方起步依赖: 第三方项目名称-spring-boot-starter
****
</t>
<t tx="swot.20241028143347.8">@language asciidoc
https://start.aliyun.com

可以创建 Spring Boot2 的项目，可以直接使用，不用再更改依赖的版本。
</t>
<t tx="swot.20241028143347.9">@language asciidoc
1. 解压下载的 Spring Boot 代码，如 hello-spring-boot.zip，可以发现就是一个 Maven 模块的目录结构。
+
image::img/hello-spring-boot-unzip.png[,640]
+
将解压后 hello-spring-boot 放入自己指定的目录。

2. 使用 IDEA 导入 hello-spring-boot 模块

* 进入 File -&gt; Project Structure 对话框，选择 Modules
* 点击 `+` 号，选择要导入的模块目录，如 hello-spring-boot
+
image::img/import_module_0.png[,400]

3. 在导入时有两个选项：

* Create module from existing sources（从现有源创建模块）用于导入没有使用构建工具如 maven 的项目
* Import module from external model（从外部模型导入模块）用于导入使用构建工具如 maven 创建的项目。因为我们是用 maven 来管理代码的，所以选择 `Import module from external model`
+
[.thumb]
image::img/import_module_1.png[,640]

4. 然后会看见 IDEA 自动安装了依赖。

5. 更改 hello-spring-boot 中的 pom.xml 文件中的 Spring Boot 和 JDK 版本号。
+
[source,xml,linenums,highlight=4;8]
----
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.7.18&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
&lt;properties&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
&lt;/properties&gt;
----</t>
<t tx="swot.20241028160046.1">@language asciidoc
:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3</t>
<t tx="swot.20241028160207.1">
++++
&lt;button id="toggleButton"&gt;Table of Contents&lt;/button&gt;
&lt;script&gt;
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () =&gt; {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
&lt;/script&gt;
++++
</t>
<t tx="swot.20241028160248.1"></t>
<t tx="swot.20250910075822.1">@language asciidoc
**HTTPie**（读作 _aitch-tee-tee-pie_）是一个现代、用户友好的命令行 HTTP 客户端。其目标是让与 Web 服务的交互尽可能简单直观，使 API 测试和调试变得轻而易举。

**设计哲学**：简洁、直观的语法，支持 JSON 等格式高亮显示。
</t>
<t tx="swot.20250910141800.1">HTTPie 通过直观的语法、漂亮的输出和强大的功能，极大地简化了在命令行中与 HTTP API 的交互，是开发者必备的工具之一。
```

您可以将此内容保存为 `.adoc` 文件，然后使用 Asciidoctor 进行编译：

```bash
asciidoctor httpie-guide.adoc
```

这将生成一个格式美观的 HTML 文档，非常适合作为课件使用。
</t>
<t tx="swot.20250910141808.1">
[source,bash]
----
# 1. 获取所有用户
http GET https://jsonplaceholder.typicode.com/users

# 2. 为用户 (ID 1) 创建一篇新帖子
http POST https://jsonplaceholder.typicode.com/posts \
  userId:=1 \
  title="My New Post" \
  body="This post was created using HTTPie. It's awesome!"

# 3. 更新刚创建的帖子 (假设 ID 为 101)
http PATCH https://jsonplaceholder.typicode.com/posts/101 \
  title="Updated Title via HTTPie"

# 4. 删除该帖子
http DELETE https://jsonplaceholder.typicode.com/posts/101
----
</t>
<t tx="swot.20250910141816.1">使用会话保持状态（如 Cookie）。

[source,bash]
----
# 登录并保存会话到文件 `session.json`
http --session=./session.json POST https://example.com/login \
  username="admin" \
  password="password"

# 使用已保存的会话发送请求
http --session=./session.json GET https://example.com/dashboard
----
</t>
<t tx="swot.20250910141823.1">控制响应的显示内容。

[source,bash]
----
# 只打印响应头
http --headers GET https://httpbin.org/json

# 只打印响应体 (默认行为)
http --body GET https://httpbin.org/json

# 将输出保存到文件
http GET https://httpbin.org/json &gt; output.json

# 忽略 SSL 证书验证 (仅用于测试环境!)
http --verify=no GET https://self-signed.badssl.com/
----

</t>
<t tx="swot.20250910141835.1">直接在 URL 后使用 `==` 添加查询字符串。

[source,bash]
----
# 添加查询参数 ?q=httpie&amp;sort=desc
http GET https://httpbin.org/get \
  q=="httpie" \
  sort=="desc"
----
</t>
<t tx="swot.20250910141841.1">使用 `@` 符号。

[source,bash]
----
# 上传单个文件
http POST https://httpbin.org/post \
  file@/path/to/file.jpg

# 上传多个文件及其他字段
http -f POST https://httpbin.org/post \
  name="John" \
  avatar@/path/to/avatar.jpg \
  document@/path/to/report.pdf
----


</t>
<t tx="swot.20250910141846.1">使用 `--form` 或 `-f` 选项发送 `application/x-www-form-urlencoded` 数据。

[source,bash]
----
http --form POST https://httpbin.org/post \
  username="johndoe" \
  password="secret"
----

</t>
<t tx="swot.20250910141915.1">使用 `Header:Value` 的格式。

[source,bash]
----
# 添加自定义请求头
http GET https://api.example.com/endpoint \
  Authorization:"Bearer YOUR_TOKEN" \
  X-Custom-Header:"MyValue"
----
</t>
<t tx="swot.20250910141920.1">删除资源。

[source,bash]
----
http DELETE https://jsonplaceholder.typicode.com/posts/1
----

</t>
<t tx="swot.20250910141928.1">更新资源（PUT 通常替换整个资源，PATCH 部分更新）。

[source,bash]
----
# 使用 PUT 完全更新帖子 (ID 为 1)
http PUT https://jsonplaceholder.typicode.com/posts/1 \
  userId:=1 \
  title="Updated Title" \
  body="Updated body content."

# 使用 PATCH 部分更新帖子标题
http PATCH https://jsonplaceholder.typicode.com/posts/1 \
  title="Partially Updated Title"
----
</t>
<t tx="swot.20250910141937.1">创建新资源。

[source,bash]
----
# 创建一篇新帖子 (自动设置 Content-Type: application/json)
http POST https://jsonplaceholder.typicode.com/posts \
  userId:=1 \
  title="Hello HTTPie" \
  body="This is the body of my post."

# 从文件读取 JSON 数据
http POST https://jsonplaceholder.typicode.com/posts &lt; data.json
----

[NOTE]
====
**语法说明**：
* `field=value`：字符串值（默认）
* `field:=value`：非字符串值（数字、布尔值、数组、对象）
====

.使用 = 和 := 的情况
****
* 字符串 → 用 =
* 数字、布尔、数组、对象 → 用 :=
****
</t>
<t tx="swot.20250910141943.1">获取资源信息（默认为 GET 方法，可省略）。

[source,bash]
----
# 获取所有帖子
http GET https://jsonplaceholder.typicode.com/posts

# 简写形式 (GET 可省略)
http https://jsonplaceholder.typicode.com/posts

# 获取特定帖子 (ID 为 1)
http https://jsonplaceholder.typicode.com/posts/1
----

</t>
<t tx="swot.20250910141955.1">[source,bash]
----
# 在 macOS 上使用 Homebrew 安装
brew install httpie

# 在 Ubuntu/Debian 上使用 apt 安装
sudo apt install httpie

# 使用 Python 的 pip 包管理器安装 (通用)
pip install --upgrade httpie
----

**验证安装**：
[source,bash]
----
http --version
----

.基本语法结构
[source,bash]
----
http [选项] &lt;请求方法&gt; URL [请求项...]
----
</t>
<t tx="swot.20250911104818.1">@language java
@doc
.使用 Result 改造后的代码
[source,java,linenums]
----
@c
package com.tjise.controller;

import com.tjise.pojo.Result;
import com.tjise.pojo.User;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.List;

// 已经包含 @ResponseBody 注解
@RestController
public class ResponseController {
    // 此处用 @others 表示还有很多代码
    @others
}
@doc
----
</t>
<t tx="swot.20250911104818.2">@doc
.使用 Result 封装响应数据
[source,java,linenums]
----
@language java
@c
@RequestMapping("/hello")
public Result hello(){
    System.out.println("Hello World!");
    Result result = new Result(1, "success", "Hello World!");
    return result;
}
@doc
----

.访问 http://localhost:8080/hello
....
{
    "code": 1,
    "msg": "success",
    "data": "Hello World!"
}
....
</t>
<t tx="swot.20250911104818.3">@doc
.使用 Result 封装响应数据
[source,java,linenums]
----
@language java
@c
@RequestMapping("/getUser")
public Result getUser(){

    // User user = new User("王林", 400, null);
    User user = new User();
    user.setName("王林");
    user.setAge(400);

    System.out.println(user);
    return new Result(1, "success", user);
}
@doc
----

.访问 http://localhost:8080/getUser
....
{
    "code": 1,
    "msg": "success",
    "data": {
        "name": "王林",
        "age": 400,
        "address": null
    }
}
....
</t>
<t tx="swot.20250911104818.4">@doc
.使用 Result 封装响应数据
[source,java,linenums]
----
@language java
@c
@RequestMapping("/getList")
public Result getList(){
    User user = new User();
    user.setName("王林");
    user.setAge(400);

    List&lt;User&gt; list = new ArrayList&lt;&gt;();
    list.add(user);

    System.out.println(list);
    return new Result(1, "success", list);
}
@doc
----

.访问 http://localhost:8080/getList
....
{
    "code": 1,
    "msg": "susscess",
    "data": [
        {
            "name": "王林",
            "age": 400,
            "address": null
        }
    ]
}
....
</t>
<t tx="swot.20250912080734.1"></t>
<t tx="swot.20250914220406.1">@language asciidoc
MyBatis 是一款优秀的 [red]#持久层框架#，用于简化 JDBC 的开发。

之前学的三层架构

* controller 控制层

* service 业务层

* dao 持久层


MyBatis 本是 Apache 的一个开源项目 iBatis，2010 年这个项目由 apache 迁移到了 google code，并且改名为 MyBatis, 2013 年 11 月迁移到 Github。

官网: https://mybatis.org/mybatis-3/

中文: https://mybatis.org/mybatis-3/zh_CN/index.html
</t>
<t tx="swot.20250914230425.1">如前面的多条件查询 sql 语句为：

```sql
SELECT * FROM emp WHERE name LIKE '%张%' 
         AND gender = 1 
         AND entrydate BETWEEN '2000-01-01' AND '2020-01-01' 
         ORDER BY update_time DESC;
```

* 姓名：要求支持模糊匹配
* 性别：要求精确匹配
* 入职时间：要求进行范围查询
* 并且要求根据最后修改时间 update_time 字段进行倒序排序

上面的 SQL 语句是一次性写死的，但是在实际的项目中 SQL 语句会随着用户的输入或外部条件的变化而变化，并不是所有的条件都会被同时输入，所以就需要使用 *动态 SQL*。

.XML 映射语句的必要性
****
之前使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。

上面描述出处: https://mybatis.org/mybatis-3/zh_CN/getting-started.html#%E6%8E%A2%E7%A9%B6%E5%B7%B2%E6%98%A0%E5%B0%84%E7%9A%84-sql-%E8%AF%AD%E5%8F%A5[探究已映射的-sql-语句]
****
</t>
<t tx="swot.20250915162444.1">@language java
@doc
[source,java,linenums]
----
@c
package com.tjise;

import com.tjise.mapper.EmpMapper;
import com.tjise.pojo.Emp;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.time.LocalDateTime;


@SpringBootTest
class MybatisQuickstartCrudApplicationTests {

    @Autowired
    private EmpMapper empMapper;

    // 省略其他代码显示
    @others

    @Test
    public void selectEmpByIdTest() {
        Emp emp = empMapper.selectEmpById(13);
        System.out.println(emp);  // 有的字段封装失败
    }

}
@doc
----

.控制台打印更新记录成功
....
==&gt;  Preparing: update emp set username=?, name=?, gender=?, image=?, job=?, entrydate=?, dept_id=?, update_time=? where id=?
==&gt; Parameters: fanghan(String), 方寒(String), 2(Short), 2.png(String), 2(Short), 2003-02-10(LocalDate), 2(Integer), 2024-10-19T20:05:23.088(LocalDateTime), 13(Integer)
&lt;==    Updates: 1
....
</t>
<t tx="swot.20250915162516.1">@Test
void deleteEmpByIdTest() {
    empMapper.deleteEmpById(17);
}

@Test
void deleteFromTableByIdTest() {
    empMapper.deleteFromTableById("emp");
}
</t>
<t tx="swot.20250915162835.1">@Test
public void insertEmpTest(){
    // 创建实体类对象
    Emp emp = new Emp();
    emp.setUsername("zhouyuan");
    emp.setName("周元");
    emp.setGender((short) 2);
    emp.setImage("2.png");
    emp.setJob((short) 2);      // 讲师
    emp.setEntrydate(LocalDate.of(2003,2,10));
    emp.setDeptId(2);   // 先随便给个数值吧
    emp.setCreateTime(LocalDateTime.now());
    emp.setUpdateTime(LocalDateTime.now());

    empMapper.insertEmp(emp);
    System.out.println("emp.id: " + emp.getId());
}
</t>
<t tx="swot.20250915162847.1">@Test
public void updateEmpTest(){
    // 创建实体类对象
    Emp emp = new Emp();
    emp.setId(13);
    emp.setUsername("fanghan");
    emp.setName("方寒");
    emp.setGender((short) 2);
    emp.setImage("2.png");
    emp.setJob((short) 2);      // 讲师
    emp.setEntrydate(LocalDate.of(2003,2,10));
    emp.setDeptId(2);   // 先随便给个数值吧
    emp.setUpdateTime(LocalDateTime.now());

    empMapper.updateEmp(emp);
}
</t>
</tnodes>
</leo_file>
