:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:toc:
:toc: right
:toc-title: 目录
:toclevels: 3

= Spring Cloud 微服务

++++
<button id="toggleButton">目录开关</button>
<script>
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () => {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
</script>
++++

== 1. Spring Cloud 微服务介绍


=== 1.1 什么是微服务？
1. 单体架构的困境
+
在传统单体架构（Monolithic Architecture）中，所有功能模块（如用户管理、订单管理、支付管理等）都被打包在一个大的应用程序中，并部署在一个应用服务器上。

* *优点*：开发、测试、部署简单。
* *缺点*：
  ** 复杂性高：代码庞大，耦合度高，维护困难。
  ** 技术栈僵化：难以引入新的技术或框架。比如多种语言开发。
  ** 扩展性差：无法针对特定模块进行扩展，必须扩展整个应用。
  ** 部署不灵活：一个小修改就需要重新部署整个应用，风险高。
  ** 可靠性低：一个微小的问题可能导致整个应用崩溃。


2. 微服务架构的解决方案
+
微服务架构（Microservices Architecture）是一种将单个应用程序拆分为 #一组小而自治的服务# 的架构风格。

* *核心思想*：*拆分* 与 *解耦*。
* *每个服务*：
  ** 围绕 *业务能力* 构建。
  ** 拥有独立的 *数据库* 和 *数据模型*。
  ** 可以独立 *开发*、*部署*、*扩展* 和 *重启*。
  ** 通过轻量级的通信机制（如 HTTP/REST、gRPC）进行协作。

+
比喻：

* *单体应用* 像一个 *大商场* ：所有部门（服装、餐饮、超市）在一个大楼里，共享水电消防。一损俱损。
* *微服务* 像一个 *商业街* ：每个店铺（服务）独立经营，有自己的特色和库存，通过公共街道（网络）连接。一店装修，不影响其他店。

=== 1.2 微服务带来的新挑战
拆分成多个服务后，也引入了新的复杂性：

. 服务发现：服务实例动态变化，消费者如何找到提供者？
. 配置管理：如何统一管理所有服务的配置，并实现动态更新？
. 负载均衡：如何将请求合理地分发到多个服务实例上？
. 容错与熔断：如何防止一个服务故障导致整个系统雪崩？
. API 网关：如何为外部客户端提供一个统一的入口，并处理跨切面问题（认证、限流、路由）？
. 分布式事务：如何保证跨多个服务的数据一致性？
. 监控与链路追踪：如何跟踪一个请求穿越多个服务的全过程，以便排查问题？

=== 1.3 Spring Cloud？
1. 定义
+
Spring Cloud 是一套基于 Spring Boot 的 #微服务生态工具集#。它提供了一系列 #标准化的工具和组件#，用于快速解决微服务架构中的常见问题（如上述挑战），让我们能更专注于业务逻辑的开发。
+
*简单来说*：Spring Boot 让开发单个微服务变得简单，而 Spring Cloud 让 #管理和协调# 这些微服务变得简单。


2. 核心定位
+
Spring Cloud 通过封装 *Netflix*、*Alibaba* 等公司成熟的微服务解决方案，提供了 *开箱即用* 的分布式系统开发体验。

=== 1.4 Cloud 的核心组件/子项目
Spring Cloud 是一个“全家桶”，包含众多组件，以下是其中最核心的几个：

[cols="1,3,2", options="header"]
|===
| 组件名称
| 功能
| 比喻

| *Eureka（国外） / Nacos（国内）*
| *服务发现与注册*：服务提供者启动后向注册中心注册自己的地址，消费者从注册中心拉取服务列表。
| *电话簿*：服务在这里注册和查找彼此的地址。

| *Ribbon（弃用） / LoadBalancer*
| *客户端负载均衡*：从服务列表中选择一个实例，将请求分发过去。
| *导游*：在多个相同的服务实例中，选择一个带你去。

| *Feign（停止维护）/ OpenFeign*
| *声明式HTTP客户端*：基于接口和注解的方式调用远程服务，像调用本地方法一样简单。
| *翻译官*：帮你自动完成HTTP请求的组装和发送。

| *Hystrix（停止维护）/ Sentinel*
| *熔断器*：当服务调用失败率达到阈值时，快速失败（熔断），防止雪崩效应，并提供服务降级。
| *保险丝*：电流过大（故障太多）自动熔断，保护整个电路（系统）。

| *Zuul(停止/未开源) / Gateway*
| *API网关*：所有外部请求的统一入口，负责路由、过滤、认证、限流、监控等。
| *前台/门卫*：所有访客必须经过这里，由它决定谁可以进、去哪里。

| *Config / Nacos*
| *分布式配置中心*：集中管理所有环境的配置文件，支持动态刷新。
| *公告板*：所有服务从这里获取最新配置，无需重启即可生效。

| *Sleuth / Zipkin*
| *分布式链路追踪*：跟踪一个请求从开始到结束的完整路径，用于性能分析和故障排查。
| *快递追踪*：可以查看你的包裹（请求）经过了哪些中转站（服务）。
|===

=== 1.5 Cloud 的流派
目前主要有两大主流体系：

. *Netflix系*：Spring Cloud Netflix（如 Eureka, Hystrix, Zuul）是早期标准，目前已部分进入维护模式。

. *Alibaba系*：*Spring Cloud Alibaba* 是目前国内最主流的方案，它提供了一站式的微服务解决方案（如 Nacos, Sentinel, Seata），与 Spring Cloud 生态无缝集成，功能强大且活跃度高。

*建议*：新项目首选 *Spring Cloud Alibaba*。

=== 1.6 总结
* 微服务架构通过拆分和解耦，解决了单体应用的痛点，但也带来了分布式系统的复杂性。

* *Spring Cloud* 不是一门新技术，而是一个 *工具箱*，它提供了 *一整套标准化的解决方案* 来轻松应对这些复杂性。

* 使用 *Spring Boot + Spring Cloud*，可以快速构建和治理一套完整、健壮的分布式微服务系统。

== 2. 创建一个空的工程 micro-service

image::img/create_empty_project.png[,800]

== 3. 创建商品微服务模块 service-item
写完下面的代码后，使用 httpie 测试一下

http :8081/item/1

=== file -> service-item/pom.xml
[source,scss]
....
<?xml version="1.0" encoding="UTF-8"?>
....

[source,scss]
....
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.18</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.tjise</groupId>
    <artifactId>service-item</artifactId>
    <version>1.0-SNAPSHOT</version>
    <name>service-item</name>
    <description>service-item</description>
    <properties>
        <java.version>1.8</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
....

=== file -> service-item/src/main/java/com/tjise/serviceitem/pojo/Item.java
.创建商品实体类
[source,java]
----
package com.tjise.serviceitem.pojo;

import lombok.Data;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Item {
    private Long id;
    private String title;
    private String pic;
    private String desc;
    private Long price;
}
----

=== file -> service-item/src/main/java/com/tjise/serviceitem/service/ItemService.java
[source,java]
----
package com.tjise.serviceitem.service;

import com.tjise.serviceitem.pojo.Item;
import org.springframework.stereotype.Service;
import java.util.HashMap;
import java.util.Map;

@Service
public class ItemService {

    private static final Map<Long, Item> ITEM_MAP = new HashMap<Long, Item>();

    static {// 准备一些静态数据，模拟数据库，只是为了简单而已，这样就不用 mapper 层了。
        ITEM_MAP.put(1L, new Item(1L, "商品1", "http://图片1", "商品描述1", 1000L));
        ITEM_MAP.put(2L, new Item(2L, "商品2", "http://图片2", "商品描述2", 2000L));
        ITEM_MAP.put(3L, new Item(3L, "商品3", "http://图片3", "商品描述3", 3000L));
        ITEM_MAP.put(4L, new Item(4L, "商品4", "http://图片4", "商品描述4", 4000L));
        ITEM_MAP.put(5L, new Item(5L, "商品5", "http://图片5", "商品描述5", 5000L));
        ITEM_MAP.put(6L, new Item(6L, "商品6", "http://图片6", "商品描述6", 6000L));
        ITEM_MAP.put(7L, new Item(7L, "商品7", "http://图片7", "商品描述7", 7000L));
        ITEM_MAP.put(8L, new Item(8L, "商品8", "http://图片8", "商品描述8", 8000L));
        ITEM_MAP.put(9L, new Item(9L, "商品9", "http://图片9", "商品描述9", 9000L));
        ITEM_MAP.put(10L, new Item(10L, "商品10", "http://图片10", "商品描述10", 10000L));
    }

    /**
     * 模拟实现商品查询，可供 Controller 层调用
     *
     * @param id
     * @return
     */
    public Item queryItemById(Long id) {
        return ITEM_MAP.get(id);
    }

}
----

=== file -> service-item/src/main/java/com/tjise/serviceitem/controller/ItemController.java
[source,java]
----
package com.tjise.serviceitem.controller;

import com.tjise.serviceitem.pojo.Item;
import com.tjise.serviceitem.service.ItemService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ItemController {

    @Autowired
    private ItemService itemService;

    /**
     * 对外提供接口服务，查询商品信息
     *
     * @param id
     * @return
     */
    @GetMapping(value = "item/{id}")
    public Item queryItemById(@PathVariable("id") Long id) {
        return this.itemService.queryItemById(id);
    }
}
----

=== file -> service-item/src/main/java/com/tjise/serviceitem/ServiceItemApplication.java
.启动类
[source,java]
----
package com.tjise.serviceitem;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ServiceItemApplication {

    public static void main(String[] args) {
        SpringApplication.run(ServiceItemApplication.class, args);
    }
}
----

=== file -> service-item/src/main/resources/application.yml
.配置文件
[source,yaml]
----
server:
    port: 8081
----

== 4. 创建订单微服务模块 service-order
httpie 测试:
http :8091/order/201810300001

=== file -> service-order/pom.xml
[source,scss]
....
<?xml version="1.0" encoding="UTF-8"?>
....

[source,scss]
....
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.18</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.tjise</groupId>
    <artifactId>service-order</artifactId>
    <version>1.0-SNAPSHOT</version>
    <name>service-order</name>
    <description>service-order</description>
    <properties>
        <java.version>1.8</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
....

=== file -> service-order/src/main/java/com/tjise/serviceorder/pojo/Order.java
.订单实体类 Order
[source,java]
----
package com.tjise.serviceorder.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.Date;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    private String orderId;
    private Long userId;
    private Date createDate;
    private Date updateDate;
    private List<OrderDetail> orderDetails;  // 包含多个商品
}
----

=== file -> service-order/src/main/java/com/tjise/serviceorder/pojo/OrderDetail.java
.订单中单个商品详情
[source,java]
----
package com.tjise.serviceorder.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderDetail {
    private String orderId;
    private Item item;
}
----

=== file -> service-order/src/main/java/com/tjise/serviceorder/pojo/Item.java
.商品实体类 Item（与商品模块中的 Item 相同）
[source,java]
----
package com.tjise.serviceorder.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Item {
    private Long id;
    private String title;
    private String pic;
    private String desc;
    private Long price;
}
----

=== file -> service-order/src/main/java/com/tjise/serviceorder/controller/OrderController.java
[source,java]
----
package com.tjise.serviceorder.controller;

import com.tjise.serviceorder.pojo.Order;
import com.tjise.serviceorder.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

/**
 * 订单控制器
 * 处理订单相关的HTTP请求
 */
@RestController
public class OrderController {
    
    // 注入订单服务
    @Autowired
    private OrderService orderService;

    /**
     * 根据订单ID查询订单信息
     * 
     * @param orderId 订单ID
     * @return Order 订单信息
     */
    @GetMapping(value = "order/{orderId}")
    public Order queryOrderById(@PathVariable("orderId") String orderId) throws IOException {
        return orderService.queryOrderById(orderId);
    }
}
----

=== file -> service-order/src/main/java/com/tjise/serviceorder/service/OrderService.java


==== class OrderService
[source,java]
----
/**
 * 订单服务类
 * 提供订单查询功能，并通过调用商品服务获取商品详细信息
 */
@Service
public class OrderService {
    @others
}
----

===== ORDER_DATA 模拟数据
[source,java]
----
// 使用静态Map模拟数据库存储订单数据
private static final Map<String, Order> ORDER_DATA = new HashMap<String, Order>();
// 初始化订单数据
static {
    // 模拟数据库，构造测试数据
    @others
}

----

====== 订单 order
[source,java]
----
Order order = new Order();
order.setOrderId("201810300001");
order.setCreateDate(new Date());
order.setUpdateDate(order.getCreateDate());  // 真会偷懒呀
order.setUserId(1L);
List<OrderDetail> orderDetails = new ArrayList<OrderDetail>();

// 创建第一个商品详情（仅保存商品ID，需要调用商品微服务获取详细信息）
Item item = new Item();
item.setId(1L);
orderDetails.add(new OrderDetail(order.getOrderId(), item));

// 创建第二个商品详情
item = new Item();
item.setId(2L);
orderDetails.add(new OrderDetail(order.getOrderId(), item));

order.setOrderDetails(orderDetails);

ORDER_DATA.put(order.getOrderId(), order);

----

===== queryOrderById
[source,java]
----
// 注入商品服务，用于查询商品详细信息
@Autowired
// NOTE: 本模块的 ItemService，不是 service-item 中的 ItemService
private ItemService itemService;
/**
 * 根据订单ID查询订单数据
 * 
 * @param orderId 订单ID
 * @return Order 订单信息，包含完整的商品详情
 */
public Order queryOrderById(String orderId) throws IOException {
    // 从模拟数据库中查询订单
    Order order = ORDER_DATA.get(orderId);
    if (null == order) {
        return null;
    }
    // 获取订单详情列表
    List<OrderDetail> orderDetails = order.getOrderDetails();

    // 遍历订单详情，通过商品微服务查询商品详细数据
    for (OrderDetail orderDetail : orderDetails) {
        // 通过商品微服务查询商品详细数据(itemService是本模块自己的)
        Item item = itemService.queryItemById(orderDetail.getItem().getId());  // 传入商品 Item id
        if (null == item) {
            continue;
        }
        // 将查询到的商品详细信息设置到订单详情中
        orderDetail.setItem(item);
    }
    return order;
}

----

=== file -> service-order/src/main/java/com/tjise/serviceorder/service/ItemService.java
[source,java]
----
package com.tjise.serviceorder.service;

import com.tjise.serviceorder.pojo.Item;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

/**
 * 商品服务类
 * 通过 REST 方式调用商品微服务获取商品信息
 */
@Service
public class ItemService {

    // Spring 框架对 RESTful 方式的 http 请求做了封装，来简化操作
    @Autowired
    private RestTemplate restTemplate;

    /**
     * 根据商品 ID 查询商品信息
     * 通过 REST 调用商品微服务获取商品详细数据
     * 
     * @param id 商品ID
     * @return Item 商品信息
     */
    public Item queryItemById(Long id) {
        return restTemplate.getForObject("http://127.0.0.1:8081/item/"
                + id, Item.class);
    }
}
----

=== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java
[source,java]
----
package com.tjise.serviceorder;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

/**
 * 订单服务启动类
 * Spring Boot 应用程序入口点
 */
@SpringBootApplication
public class ServiceOrderApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceOrderApplication.class, args);
    }

    /**
     * 创建RestTemplate实例
     * 用于调用其他微服务
     * 
     * @return RestTemplate
     */
    @Bean
    public RestTemplate restTemplate() {
        // 可以在这里添加拦截器来统一处理URL前缀
        return new RestTemplate();
    }
}
----

=== file -> service-order/src/main/resources/application.yml
.配置文件
[source,yaml]
----
server:
    port: 8091
----

== 5. HTTP 客户端


=== 5.1 RestTemplate -- Spring 提供的传统同步 HTTP 客户端
前面演示的是 方式一：字段注入（需要 @Autowired），
下面演示一下使用 方式二单个构造函数注入的例子。

httpie 测试:
http :8091/order/201810300001

==== file -> service-order/src/main/java/com/tjise/serviceorder/service/ItemService.java


===== class ItemService
/**
 * 商品服务类
 * 通过 REST 方式调用商品微服务获取商品信息
 */
@Service
public class ItemService {
    @others
}

====== 方式二 单个构造函数注入
[source,java]
----
private final RestTemplate restTemplate;
public ItemService(RestTemplate restTemplate) {
    // this.resttemplate 是上面定义的属性
    this.restTemplate = restTemplate;
}
----

=== 5.2 RestTemplate + OkHttp 可以兼容老代码
为了兼容老的 RestTemplate 代码，也可以在 RestTemplate 中配置 OkHttp。

httpie 测试:
http :8091/order/201810300001

==== file -> service-order/pom.xml


===== okhttp 依赖
[source,scss]
....
<!-- 使用 Spring Boot 管理的版本 -->
<dependency>
    <groupId>com.squareup.okhttp3</groupId>
    <artifactId>okhttp</artifactId>
</dependency>
....

==== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java


===== RestTemplate restTemplate
[source,java]
----
/**
 * 创建RestTemplate实例
 * 用于调用其他微服务
 * 
 * @return RestTemplate
 */
@Bean
public RestTemplate restTemplate() {
    // 可以在这里添加拦截器来统一处理URL前缀
    // return new RestTemplate();  // 未使用 OkHttp
    return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
}
----

==== file -> service-order/src/main/java/com/tjise/serviceorder/service/ItemService.java


===== 方式二 单个构造函数注入 -- 增加了查看是否成功使用了 OkHttp 打印
[source,java]
----
private final RestTemplate restTemplate;
public ItemService(RestTemplate restTemplate) {  // 单个构造函数
    this.restTemplate = restTemplate;
    // 检查请求工厂类型
    System.out.println("Request Factory: " + restTemplate.getRequestFactory().getClass().getName());
    // 成功使用 OkHttp 会打印
    // Request Factory: org.springframework.http.client.OkHttp3ClientHttpRequestFactory
}
----

=== 5.3 OkHttp -- 单独使用 Square 开源的高性能 HTTP 客户端
OkHttp 的异步 API 在应用程序层面实现了与 Node.js 类似的高并发编程模型：通过非阻塞 I/O 和回调机制，最大化利用少量线程来处理海量网络连接，从而高效地处理高并发 HTTP 请求。

httpie 测试:
http :8091/order/201810300001

==== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java


===== OkHttpClient okHttpClient
[source,java]
----
@Bean
public OkHttpClient okHttpClient() {
    return new OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .build();
}
----

==== file -> service-order/src/main/java/com/tjise/serviceorder/service/ItemService.java
[source,java]
----
package com.tjise.serviceorder.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tjise.serviceorder.pojo.Item;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import org.springframework.stereotype.Service;

import java.io.IOException;

@Service
public class ItemService {
    // 下面这两种方式是等价的，看自己的使用方式而定
    // 方式一：字段注入（需要 @Autowired）
    // @Autowired
    // private OkHttpClient client;

    // 方式二 单个构造函数注入
    private final OkHttpClient client;  // 单个构造函数注入（不需要 @Autowired
    private final ObjectMapper objectMapper;  // 可支持 json 序列化
    public ItemService(OkHttpClient client, ObjectMapper objectMapper) {
        this.client = client;
        this.objectMapper = objectMapper;
        // 检查请求工厂类型
        System.out.println("Using OkHttpClient: " + client.getClass().getName());
        // 打印：Using OkHttpClient: okhttp3.OkHttpClient
    }

    public Item queryItemById(Long id) throws IOException {
        Request request = new Request.Builder()
                .url("http://127.0.0.1:8081/item/" + id)
                .build();
        try (Response response = client.newCall(request).execute()) {
            // 读取响应体
            String json = response.body().string();
            // 使用注入的 objectMapper 反序列化成 JSON 字符串
            return objectMapper.readValue(json, Item.class);
        }  // 这里会自动调用资源的 close() 方法
    }
}
----

=== 5.4 WebClient  -- Spring WebFlux 提供的响应式 HTTP 客户端
WebClient 简介

**WebClient** 是 Spring WebFlux 库提供的**非阻塞、响应式 HTTP 客户端**，用于构建反应式应用程序。它是传统 `RestTemplate` 的现代替代品，专为函数式编程、流畅的 API 设计和异步处理而设计。

核心特点

1. **响应式与非阻塞**：
  基于 Project Reactor，它使用 `Mono` 和 `Flux` 作为返回类型，允许您以声明式方式组合异步操作，而不会阻塞线程。这极大地提高了应用程序的并发能力和资源利用率。
  
2. **流畅的接口**：
  其 API 设计流畅易用，允许您通过方法链轻松地构建请求、设置头部、指定正文和处理响应。
  
3. **支持同步与异步**：
  虽然本质上是异步的，但它也提供了阻塞当前线程以等待结果的方法（不推荐在响应式链中使用），使其在需要时也能适应同步场景。
  
4. **与 Spring 生态无缝集成**：
  可以轻松地与 Spring Security、WebFlux 服务器端以及其他 Spring 组件集成。
  
总结

简而言之，**WebClient 是现代 Spring 应用中进行 HTTP 通信的首选工具**。尤其当您构建基于 Spring WebFlux 的响应式微服务时，它是实现服务间高效、非阻塞通信的关键组件。

***

httpie 测试:
http :8091/order/201810300001

==== file -> service-order/pom.xml


===== WebClient
[source,scss]
....
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
....

==== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java


===== WebClient
[source,java]
----
@Bean
public WebClient webClient() {
    return WebClient.builder()
          .baseUrl("http://127.0.0.1:8081/item")
          .build();
}
----

==== file -> service-order/src/main/java/com/tjise/serviceorder/service/ItemService.java
[source,java]
----
package com.tjise.serviceorder.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tjise.serviceorder.pojo.Item;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;

import java.io.IOException;

@Service
public class ItemService {
    // 下面这两种方式是等价的，看自己的使用方式而定
    // 方式一：字段注入（需要 @Autowired）
    // @Autowired
    // private WebClient webClient;

    // 方式二 单个构造函数注入
    private final WebClient webClient;
    public ItemService(WebClient webClient) {
        this.webClient = webClient;
    }

    public Item queryItemById(Long id) {
        return webClient.get()
            .uri("/{id}", id)
            .retrieve()
            .bodyToMono(Item.class)
            .block(); // 同步调用，如需要异步可去掉block()
    }
}
----

=== 5.5  RestClient -- Spring 6.1 才支持（目前的 Spring Boot 2.7.18 使用的是 Spring 5.3.x）
RestClient 的主要价值在于它提供了一个现代化但又不失简单的 API，结合了 RestTemplate 的易用性和 WebClient 的功能强大，是未来 Spring 应用HTTP 客户端调用的推荐选择。

== 6. service-order url 硬编码问题（在后面引入 Eureka 后不用url，直接用名字了）


=== 6.1 解决 service-order url 硬编码问题：以 WebClient 为例使用 @Value
通过以上的测试发现，在订单系统中要调用商品微服务中的查询接口来获取数据，在订单微服务中将 url 硬编码到代码中，这样显然不好，因为，运行环境一旦发生变化这个 url 地址将不可用。

如何解决呢？

解决方案：将 url 地址写入到 yml 配置文件中。

==== file -> service-order/src/main/resources/application.yml
[source,python]
----
server:
  port: 8091

# 新增 url 配置，名字自己决定。
myspcloud:
  item:
    url: http://127.0.0.1:8081/item/

----

==== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java


===== class ServiceOrderApplication
/**
 * 订单服务启动类
 * Spring Boot 应用程序入口点
 */
@SpringBootApplication
public class ServiceOrderApplication {

    // 新增使用 @Value 注解获取配置的 url
    @Value("${myspcloud.item.url}")
    private String itemUrl;

    public static void main(String[] args) {
        SpringApplication.run(ServiceOrderApplication.class, args);
    }
    @others
}

====== WebClient
[source,java]
----
@Bean
public WebClient webClient() {
    return WebClient.builder()
        .baseUrl(itemUrl)   // 使用注入的 Url
        .build();
}
----

=== 6.2 解决 service-order url 硬编码问题：使用 @ConfigurationProperties


==== file -> service-order/src/main/java/com/tjise/serviceorder/utils/ItemProperties.java
[source,java]
----
package com.tjise.serviceorder.utils;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;


@Data
@Component
@ConfigurationProperties(prefix = "myspcloud.item")
public class ItemProperties {
    // 下面属性值的内容会从配置文件中被自动获取到
    private String url;
}
----

==== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java


===== class ServiceOrderApplication
/**
 * 订单服务启动类
 * Spring Boot 应用程序入口点
 */
@SpringBootApplication
public class ServiceOrderApplication {
    @others
}

====== DI itemProperties -- New Added
[source,java]
----
// 成员注入的方式
// @Autowired
// private ItemProperties itemProperties;

private final ItemProperties itemProperties;
// 单构造器注入，不用 @Autowired
public ServiceOrderApplication(ItemProperties itemProperties) {
    this.itemProperties = itemProperties;
}
----

====== public static void main
[source,java]
----
public static void main(String[] args) {
    SpringApplication.run(ServiceOrderApplication.class, args);
}
----

====== @Bean WebClient -- New Added
[source,java]
----
// 方法参数注入（直接从 Spring 容器里获取 ItemProperties）
@Bean
public WebClient webClient(ItemProperties properties) {
    return WebClient.builder()
            .baseUrl(properties.getUrl())
            // .baseUrl(this.itemProperties.getUrl())
            .build();
}
----

== 7. 引入微服务注册、发现机制
* 问题：商品微服务 ip 发生变更则需要更改订单微服务的配置文件，如果商品微服务有多个，订单微服务该链接哪个？

从而引入微服务注册、发现机制，如下。

image::img/service_register.png[,640]

1. 服务提供者将服务注册到注册中心
2. 服务消费者通过注册中心查找服务
3. 查找到服务后进行调用（这里就是无需硬编码 url 的解决方案，取服务名即可）
4. 服务的消费者与服务注册中心保持心跳连接，一旦服务提供者的地址发生变更时，注册中心会通知服务消费者

=== 7.1 Eureka 介绍
Eureka 是 Netfix 开源的服务发现组件，本身是一个基于 REST 的服务。它包含 Server 和 Client 两部分。SpringCloud 将它集成在子项目 SpringCloud Netfix 中，从而实现微服务的注册与发现。

* Eureka Server 提供服务注册服务，各个节点启动后，会在 Eureka Server 中进行注册，这样 EurekaServer 中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。

* Eureka Client 是一个 java 客户端，用于简化与 Eureka Server 的交互，客户端同时也有一个内置的、使用轮询(round-robin)负载算法的负载均衡器。

* 在应用启动后，将会向 Eureka Server 发送心跳，默认周期为 30 秒，如果 Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，Eureka Server 将会从服务注册表中把这个服务节点移除(默认90秒)。

* 多个 Eureka Server 之间通过复制的方式完成数据的同步，Eureka 还提供了客户端缓存机制，即使所有的 Eureka Server 都挂掉，客户端依然可以利用缓存中的信息消费其他服务的 API。

综上，Eureka 通过心跳检查、客户端缓存等机制，确保了系统的高可用性、灵活性和可伸缩性。

=== 7.2 Eureka Server 的创建
创建一个 maven 的项目，命名为 eureka。

image::img/create_eureka_module.png[,800]

==== file -> eureka/pom.xml
[source,scss]
....
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.tjise</groupId>
    <artifactId>eureka</artifactId>
    <version>1.0-SNAPSHOT</version>
    <!-- 加入下面各项内容 -->
    @others
</project>
....

===== 1 properties 配置项目属性：Java 版本、Spring Boot 和 Spring Cloud 版本
[source,scss]
....
<properties>
    <maven.compiler.source>8</maven.compiler.source>
    <maven.compiler.target>8</maven.compiler.target>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <!-- 这两个版本要匹配才行 -->
    <spring.boot.version>2.7.18</spring.boot.version>
    <spring.cloud.version>2021.0.8</spring.cloud.version>
</properties>
....

===== 2 dependencyManagement 依赖管理：导入 Spring Boot 和 Spring Cloud 的依赖管理
[source,scss]
....
<dependencyManagement>
    <dependencies>
        <!-- Spring Boot 依赖管理 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>${spring.boot.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <!-- Spring Cloud 依赖管理 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring.cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
....

===== 3 dependencies 项目依赖：添加 Eureka Server 依赖
[source,scss]
....
<dependencies>
    <!-- Eureka Server核心依赖 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>
</dependencies>
....

===== 4 plugins 构建配置：添加 Spring Boot Maven 插件
[source,scss]
....
<build>
    <plugins>
        <!-- Spring Boot Maven插件，用于打包可执行jar -->
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <version>${spring.boot.version}</version>
        </plugin>
    </plugins>
</build>
....

==== file -> eureka/src/main/java/com/tjise/eureka/EurekaApplication.java
[source,java]
----
package com.tjise.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/**
 * Eureka Server启动类
 * 
 * @EnableEurekaServer 注解启用 Eureka Server 功能
 */
@SpringBootApplication
@EnableEurekaServer
public class EurekaApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
----

==== file -> eureka/src/main/resources/application.yml
[source,yaml]
....
server:
  port: 8761  # 1. Eureka Server 端口设置为 8761（默认端口）

eureka:
  instance:
    hostname: localhost  # 2. 设置主机名为 localhost
  client:
    register-with-eureka: false  # 3. Eureka Server 不向自己注册
    fetch-registry: false        # 4. Eureka 自己不需要获取服务注册信息
    service-url:
      # 5. 设置 Eureka Server 的访问地址
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
      
  server:
    enable-self-preservation: false  # 6. 关闭自我保护机制（开发环境建议关闭，但是会有红色警告提示，属于正常）
                                     # 设置成 false 后保证服务不可用时及时剔除相应的微服务，易测试。
....

==== 启动 Eureka Server 并测试网页管理端
现在可以通过以下命令启动 Eureka Server：

. 进入eureka项目目录
* cd /Users/swot/swot-learning/java/SpringCloud/eureka

. 使用 IDEA 启动应用
* mvn spring-boot:run

. 或者先打包再运行
* mvn clean package
* java -jar target/eureka-1.0-SNAPSHOT.jar

. #可以直接在 IDEA 中运行启动类#

启动后访问 http://localhost:8761 即可看到 Eureka Server 的管理界面。

image::img/eureka_admin_no_instance.png[]

=== 7.3 Eureka Server 注册商品微服务
成功注册 service-item 到 eureka 是这样的，如下图

image::img/eureka_admin_with_service-item.png[]

==== file -> service-item/pom.xml


===== properties Add cloud Version 2021.0.8
[source,scss]
....
<properties>
    <java.version>1.8</java.version>
    <spring-cloud.version>2021.0.8</spring-cloud.version>
</properties>
....

===== dependencyManagement Add cloud dependency
[source,scss]
....
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
....

===== spring-cloud-starter-netflix-eureka-client
[source,scss]
....
<!-- 添加 Eureka 客户端依赖, 用于将服务注册到 Eureka -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
....

==== file -> service-item/src/main/resources/application.yml
[source,python]
----
### 服务端口号(本身是一个web项目)
server:
    port: 8081

### 起个名字作为服务名称(该服务注册到eureka注册中心的名称，比如商品服务)
spring:
    application:
        name: app-item

### 服务注册到 eureka 注册中心的地址
eureka:
    client:
        service-url:
            defaultZone: http://127.0.0.1:8761/eureka/
        ### 因为该应用为服务提供者，是 eureka 的一个客户端，需要注册到注册中心
        register-with-eureka: true
        ### 是否需要从 eureka 上检索服务
        fetch-registry: true
    instance:
        # 使用 IP 地址注册而不是主机名
        prefer-ip-address: true
        # 客户端在注册时使用自己的IP，而不是主机名，是生产环境的最佳实践。避免主机名 DNS 解析问题
        ip-address: 127.0.0.1
----

****
name 和 instance 两者都有重要作用，缺一不可：

- spring.application.name：服务的逻辑名称，用于服务发现和负载均衡
- eureka.instance 配置：实例的网络地址，用于实际通信

即使使用IP注册，仍然需要服务名称来进行服务发现和调用。
****

==== file -> service-item/src/main/java/com/tjise/serviceitem/ServiceItemApplication.java
[source,java]
----
package com.tjise.serviceitem;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient  // <1>
public class ServiceItemApplication {

    public static void main(String[] args) {
        SpringApplication.run(ServiceItemApplication.class, args);
    }
}
----

<1> 启用 uereka 客户端注解

==== 启动多个 service-item 商品微服务实例
先启动刚刚配置的 service-item，查看是否运行正常。如运行正常，继续下面操作。

重复操作下面步骤 2 次，一共启动 3 个 service-item 实例。

.复制 service-item 配置
image::img/serviceItem_copy_config.png[]

.编辑 service-item 配置启动新端口
image::img/serviceItem_copy_config_edit_8082.png[,520]

启动 3 个实例，如下图所示：

.在 Eureka 中发现有 3 个 service-item 实例已经注册成功
image::img/three_serviceItem_in_eureka.png[]

=== 7.4 Eureka 中发现商品微服务 app-item
之前我们在订单系统中是将商品微服务的地址进行了硬编码，现在，由于已经将商品服务注册到 Eureka 中，所以，只需要从 Eureka 中发现服务即可。

想要从 Eureka 中发现服务，需要先将 service-order 成功注册到 eureka，如下图是成功注册后的截图。

image::img/eureka_admin_with_service-order.png[]

httpie 测试注册 service-order 到 Eureka 后，也是可以正常运行的:
[source,console]
----
http :8091/order/201810300001
----

==== file -> service-order/pom.xml


===== properties version
[source,scss]
....
<properties>
    <java.version>1.8</java.version>
    <spring-cloud.version>2021.0.8</spring-cloud.version>
</properties>
....

===== Add cloud dependency
[source,scss]
....
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
....

===== eureka-client 依赖
[source,scss]
....
<!-- 添加 Eureka 客户端依赖, 用于将服务注册到 Eureka -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
....

==== file -> service-order/src/main/resources/application.yml


===== port
[source,yaml]
----
server:
    port: 8091
----

===== name
[source, yaml]
----
# 起个名字作为服务名称(该服务注册到 eureka 注册中心的名称，比如订单服务)
spring:
    application:
        name: app-order
----

===== eureka
[source,yaml]
----
# 服务注册到 eureka 注册中心的地址
eureka:
    client:
        service-url:
            defaultZone: http://127.0.0.1:8761/eureka
        register-with-eureka: true  # 因为该应用为服务提供者，是 eureka 的一个客户端，需要注册到注册中心
        fetch-registry: true        # 是否需要从 eureka 上检索服务
    instance:
        prefer-ip-address: true     # 使用 IP地址 注册而不是主机名
        ip-address: 127.0.0.1       # 客户端在注册时使用自己的 IP，而不是主机名
                                    # 这是生产环境的最佳实践。避免主机名解析问题
----

==== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java


===== class ServiceOrderApplication -> NOTE:下面的三个客户端任选一个即可
[source,java]
----
/**
 * 订单服务启动类，Spring Boot 应用程序入口点。
 */
@SpringBootApplication
@EnableEurekaClient  // new -> 启用 Eureka 客户端功能
public class ServiceOrderApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceOrderApplication.class, args);
    }
    // 包含其他代码
    @others
}
----

.负载均衡使用拦截器原理：
****
1. 拦截请求URL
2. 识别服务名
3. 通过服务发现获取实际地址
4. 替换URL并发起请求
****

====== RestTemplate
[source,java]
----
/**
 * 创建 RestTemplate 实例，用于调用其他微服务。
 * @return RestTemplate
 */
@Bean
@LoadBalanced // new -> 使用负载均衡
public RestTemplate restTemplate() {
    // 可以在这里添加拦截器来统一处理URL前缀
    // return new RestTemplate();  // not use OkHttp
    return new RestTemplate(
           new OkHttp3ClientHttpRequestFactory());  // use OkHttp
}
----

====== OkHttpClient 不支持 @LoadBalanced
[source,java]
----
@Bean
// @LoadBalanced  // OkHttpClient 不支持负载均衡，在这儿写该注解没用。
public OkHttpClient okHttpClient() {
    return new OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .build();
}
----

====== WebClient
[source,java]
----
// 配置负载均衡的 WebClient.Builder，注意这里要改成 Builder 的形式才可以
@Bean
@LoadBalanced // new -> 使用负载均衡
public WebClient.Builder loadBalancedWebClientBuilder() {
    return WebClient.builder();
}

// 使用 Builder 创建 WebClient
@Bean
public WebClient webClient(WebClient.Builder builder) {
    return builder
        .baseUrl("http://app-item/item")  // 使用 eureka 注册中心调用(去注册中心查找服务 app-item，这种方式必须先开启负载均衡 @LoadBalanced)
        .build();
}

----

.总结
****
WebClient 也需要使用 @LoadBalanced 注解，但需要注解在 WebClient.Builder 上，而不是 WebClient 实例上。
这与 WebClient 的设计有关：

- WebClient 是不可变的（immutable）
- WebClient.Builder 是可变的，用于构建 WebClient 实例
- Spring Cloud 需要在 Builder 层面注入负载均衡能力

这样设计是为了与 WebClient 的不可变性设计保持一致，同时也提供了更灵活的配置方式。
****

==== file -> service-order/src/main/java/com/tjise/serviceorder/service/ItemService.java


===== import
package com.tjise.serviceorder.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tjise.serviceorder.pojo.Item;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.loadbalancer.LoadBalancerClient;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.reactive.function.client.WebClient;

import java.io.IOException;

===== class ItemService
[source,java]
----
// 根据商品 ID 查询商品信息：通过 REST 调用商品微服务获取商品详细数据
@Service
public class ItemService {  // 商品服务类
    @Autowired
    private RestTemplate restTemplate;

    private final WebClient webClient;
    private final OkHttpClient okHttpClient;
    private final ObjectMapper objectMapper;  // 可支持 json 序列化

    // 单个构造方法注入
    public ItemService(
            WebClient webClient,
            @Autowired(required = false) OkHttpClient okHttpClient,
            @Autowired(required = false) ObjectMapper objectMapper) {
        this.webClient = webClient;
        this.okHttpClient = okHttpClient;
        this.objectMapper = objectMapper;
    }
    // 包含其他代码
    @others
}
----

====== 方式一: RestTemplate -> queryItemById
[source,java]
----
public Item queryItemById(Long id) {
    return restTemplate.getForObject(
            "http://app-item/item/" + id, Item.class);  // <1>
}
----

<1> app-item 是 service-item 在 Eureka 中注册的服务名。

====== 方式二: OkHttpClient -> queryItemByIdWithOkHttpClient -> OkHttpClient 本身不支持服务发现功能，需要自己实现
[source,java]
----
@Autowired
private LoadBalancerClient loadBalancerClient;

public Item queryItemByIdWithOkHttpClient(Long id) throws IOException {
    // 使用 LoadBalancerClient 获取负载均衡的实例
    ServiceInstance instance = loadBalancerClient.choose("app-item");
    String actualUrl = "http://" + instance.getHost() + ":" + instance.getPort() + "/item/" + id;
    Request request = new Request.Builder().url(actualUrl).build();
    try (Response response = okHttpClient.newCall(request).execute()) {  // 执行 OkHttpClient 调用
        String json = response.body().string();  // 读取响应体
        // 使用注入的 objectMapper 反序列化成 JSON 字符串
        return objectMapper.readValue(json, Item.class);
    }
}
----

====== 方式三: WebClient    -> queryItemByIdWithWebClient
[source,java]
----
public Item queryItemByIdWithWebClient(Long id) {
    return webClient.get()
                    .uri("/{id}", id)
                    .retrieve()
                    .bodyToMono(Item.class)
                    .block();
}
----

==== file -> service-order/src/main/java/com/tjise/serviceorder/service/OrderService.java


===== Order queryOrderById
[source,java]
----
// 注入商品服务，用于查询商品详细信息
@Autowired
private ItemService itemService;
/**
 * 根据订单ID查询订单数据
 * @param orderId 订单ID
 * @return Order 订单信息，包含完整的商品详情
 */
public Order queryOrderById(String orderId) throws IOException {
    // 从模拟数据库中查询订单
    Order order = ORDER_DATA.get(orderId);
    if (null == order) {
        return null;
    }
    // 获取订单详情列表
    List<OrderDetail> orderDetails = order.getOrderDetails();
    // 遍历订单详情，通过商品微服务查询商品详细数据
    for (OrderDetail orderDetail : orderDetails) {
        // 通过商品微服务查询商品详细数据
        Item item = itemService.queryItemById(orderDetail.getItem().getId());  // <1>
        // Item item = itemService.queryItemByIdWithOkHttpClient(orderDetail.getItem().getId());  // <2>
        // Item item = itemService.queryItemByIdWithWebClient(orderDetail.getItem().getId());  // <3>
        if (null == item) {
            continue;
        }
        orderDetail.setItem(item);  // 将查询到的商品详细信息设置到订单详情中
    }
    return order;
}
----
<1> 使用 RestTemplate
<2> 使用 OkHttpClient
<3> 使用 WebClient

=== 7.5 测试 service-item 被负载均衡分配的结果
下面代码会使用 `@Value("${server.port}")` 可以获取到运行时的实际端口号，即使是在通过 Edit Configuration 传递 --server.port=8082 或 8083
参数启动多个实例的情况下也可以。
这是 Spring Boot 的一个强大功能，它会自动解析运行时的实际配置值。

如下面修改 ItemController，在每次请求时会打印当前处理请求的端口号。以下是简单的负载均衡测试方法：

负载均衡测试步骤：

1. 确认所有服务都已启动：
  - Eureka Server (端口 8761)
  - 3 个 service-item 实例 (端口 8081, 8082, 8083)
  - service-order (端口 8091)

2. 在 3 个 service-item 实例的控制台分别观察日志输出。

3. 通过 service-order 发起请求：

   # 重复执行以下命令，观察哪个实例在处理请求
   http :8091/order/201810300001

4. 每次执行上述命令时，观察 3 个 service-item 实例的控制台，应该会看到类似下面的日志，显示哪个端口在处理请求：

   Processing request on port: 8081 for item ID: 1
   Processing request on port: 8083 for item ID: 2
   Processing request on port: 8082 for item ID: 1

这样就能清楚地看到负载均衡在工作，请求被分发到不同的 service-item 实例上。

==== 7.5.1 只在 service-item 的不同实例中打印端口调用信息


===== file -> service-item/src/main/java/com/tjise/serviceitem/controller/ItemController.java
[source,java]
----
package com.tjise.serviceitem.controller;

import com.tjise.serviceitem.pojo.Item;
import com.tjise.serviceitem.service.ItemService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import java.util.logging.Logger;

@RestController
public class ItemController {

    @Autowired
    private ItemService itemService;
    
    // --New Added--
    @Value("${server.port}")
    private int serverPort;

    private static final Logger logger = Logger.getLogger(ItemController.class.getName());

    /**
     * 对外提供接口服务，查询商品信息
     *
     * @param id
     * @return
     */
    @GetMapping(value = "item/{id}")
    public Item queryItemById(@PathVariable("id") Long id) {
        // 增加了日志打印功能，方便查看是哪个 service-item 提供的服务。
        // logger.info("Handling request on port: " + serverPort + " for item ID: " + id);
        System.out.println("Processing request on port: " + serverPort + " for item ID: " + id);
        return this.itemService.queryItemById(id);
    }
}
----

==== 7.5.2 在 service-order 中集中打印负载均衡端口调用信息


===== file -> service-order/src/main/java/com/tjise/serviceorder/service/ItemService.java


====== 方式一: RestTemplate -> queryItemById
[source,java]
----
public Item queryItemById(Long id) {
    // NOTE: service-order/src/main/java/com/tjise/serviceorder/service/OrderService.java 里面调用的是本方法才行。
    // 获取实际被选择的实例，这里只是打印一下。实际上 restTemplate 会自动使用负载均衡获取实例的。
    ServiceInstance serviceInstance = loadBalancerClient.choose("app-item");
    if (serviceInstance != null) {
        // String targetUrl = serviceInstance.getUri().toString() + "/item/" + id;
        // logger.info("Load Balancer: Requesting instance at " +
                // serviceInstance.getHost() + ":" + serviceInstance.getPort() +
                // " for item ID: " + id);
        System.out.println("负载均衡选择了端口: " + serviceInstance.getPort());
    }

    // restTemplate 会自动应用负载均衡，上面的实例选取只是为了能演示出负载均衡的策略。
    Item item = restTemplate.getForObject(
            "http://app-item/item/" + id, Item.class);  // <1>

    // logger.info("Load Balancer: Got response fro item ID: " + id +
                // ", result: " + (item != null ? "SUCCESS" : "FAILED"));
    return item;
}
----

<1> app-item 是 service-item 在 Eureka 中注册的服务名。

=== 7.6 Eureka 添加用户认证
在前面的示例中，我们可以看到不需要登录即可访问到 Eureka 服务，这样其实是不安全的。
所以需要为 Eureka 添加用户认证功能。

.加入用户认证功能后需要登录界面
image::img/eureka_login.png[,800]

.加入用户认证功能后依然可以注册成功
image::img/eureka_admin_with_user_and_pass.png[]

==== file -> eureka/pom.xml


===== security 安全认证依赖
[source,scss]
....
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
....

==== file -> eureka/src/main/resources/application.yml


===== server
[source,yaml]
----
server:
  port: 8761  # 1. Eureka Server端口设置为8761（默认端口）
----

===== spring -> new added
[source,yaml]
----
spring:
  application:
    name: app-eureka-center
  security:
    basic:
      enable: true  # 开启基于 HTTP basic 的认证
    user:  # 配置用户的账号信息
      name: root
      password: root
----

===== eureka -> new changed
[source,yaml]
----
eureka:
  instance:
    hostname: localhost  # 2. 设置主机名为localhost
  client:
    register-with-eureka: false  # 3. Eureka Server不向自己注册
    fetch-registry: false        # 4. Eureka 自己不需要获取服务注册信息
    service-url:
      # 5. 设置 Eureka Server 的访问地址
      # defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
      # 改成需要账号和密码的形式
      defaultZone: http://${spring.security.user.name}:${spring.security.user.password}@${eureka.instance.hostname}:${server.port}/eureka/
  server:
    enable-self-preservation: true  # 6. 关闭自我保护机制（开发环境建议关闭）
----

==== file -> eureka/src/main/java/com/tjise/eureka/conf/WebSecurityConfig.java


===== WebSecurityConfig 新建安全配置类
[source,java]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.NEVER)
            .and()
            .csrf().disable()
            .authorizeHttpRequests(authz -> authz
                    .anyRequest().authenticated()
            )
            .httpBasic(Customizer.withDefaults());
        return http.build();
    }
}
----

==== file -> service-item/src/main/resources/application.yml
****
name 和 instance 两者都有重要作用，缺一不可：

- spring.application.name：服务的逻辑名称，用于服务发现和负载均衡
- eureka.instance 配置：实例的网络地址，用于实际通信

即使使用 IP 注册，仍然需要服务名称来进行服务发现和调用。
****

===== port
[source,yaml]
----
### 服务端口号(本身是一个web项目)
server:
    port: 8081
----

===== name
[source,yaml]
----
### 起个名字作为服务名称(该服务注册到eureka注册中心的名称，比如商品服务)
spring:
    application:
        name: app-item
----

===== eureka
[source,yaml]
----
### 服务注册到eureka注册中心的地址
eureka:
    client:
        service-url:
            # defaultZone: http://127.0.0.1:8761/eureka/
            # 更改：加入用户名和密码
            defaultZone: http://root:root@127.0.0.1:8761/eureka/

        ### 因为该应用为服务提供者，是 eureka 的一个客户端，需要注册到注册中心
        register-with-eureka: true
        ### 是否需要从 eureka 上检索服务
        fetch-registry: true
    instance:
        prefer-ip-address: true  # 使用IP地址注册而不是主机名
        ip-address: 127.0.0.1    # 客户端在注册时使用自己的IP，而不是主机名。
                                 # 这是生产环境的最佳实践，避免主机名解析问题。
----

==== file -> service-order/src/main/resources/application.yml


===== port
[source,yaml]
----
server:
    port: 8082
----

===== name
[source, yaml]
----
# 起个名字作为服务名称(该服务注册到 eureka 注册中心的名称，比如订单服务)
spring:
    application:
        name: app-order
----

===== eureka
[source,yaml]
----
# 服务注册到 eureka 注册中心的地址
eureka:
    client:
        service-url:
            # defaultZone: http://127.0.0.1:8761/eureka/
            # 更改：加入用户名和密码
            defaultZone: http://root:root@127.0.0.1:8761/eureka/
        register-with-eureka: true  # 因为该应用为服务提供者，是 eureka 的一个客户端，需要注册到注册中心
        fetch-registry: true        # 是否需要从 eureka 上检索服务
    instance:
        prefer-ip-address: true     # 使用 IP地址 注册而不是主机名
        ip-address: 127.0.0.1       # 客户端在注册时使用自己的 IP，而不是主机名
                                    # 这是生产环境的最佳实践。避免主机名解析问题
----

=== 7.7 Eureka 集群（高可用性）
TIP: Eureka 集群自身的高可用是通过节点间对等复制实现的，而基于 Eureka 的应用服务负载均衡是由客户端组件（如 Ribbon/LoadBalancer）实现的。


前面的测试发现，Eureka 服务是一个单点服务，在生产环境就会出现单点故障，为了确保 Eureka 服务的高可用，需要搭建 Eureka 服务的集群。

1. sudo vim /etc/hosts 增加 3 个主机名
+
.Windows、Linux、MacOS 都需要更改 hosts
[source,shell]
----
127.0.0.1 eureka1
127.0.0.1 eureka2
127.0.0.1 eureka3
----
2. 在 eureka 中创建 3 个配置文件: application-peer[1,2,3].yml
* defaultZone 配置多个地址在 Eureka 集群中的作用：
  ** 相互注册: 每个 Eureka Server 实例都需要知道集群中其他实例的地址，以便它们能够互相注册和同步服务注册信息。
    *** application-peer1.yml 中的这个配置告诉 eureka1 实例，它需要向 eureka2 和 eureka3 进行注册，并从它们那里获取服务注册信息。
    *** 同理，application-peer2.yml 会配置 eureka1 和 eureka3 的地址，application-peer3.yml 会配置 eureka1 和 eureka2 的地址。
  ** 高可用性: 通过相互注册，整个 Eureka 集群形成了一个去中心化的结构。即使其中一个 Eureka Server 实例宕机，其他实例仍然可以提供服务注册与发现功能，保证了服务的持续可用性。
  ** 信息同步: Eureka Server 实例之间会定期同步服务注册信息，确保所有实例上的服务列表保持一致。
  
3. 按下图在开发机器上配置 3 个 Eureka 服务的集群。
+
image::img/eureka_multi.png[]

4. 访问三个 eureka 管理端网址，查看注册情况。
+
http://localhost:8761/ | http://localhost:8762/ | http://localhost:8763/
+
.三个网址内容类似
image::img/eureka_multi_admin.png[]

TIP: 用户名: root 密码: root

5. 为了实现高可用性，service-item 和 service-order 应该像 Eureka Server 之间相互注册那样，将所有 Eureka Server 的地址都配置上。这样做可以确保即使其中一个 Eureka Server 实例宕机，服务仍然能够成功注册和发现其他服务，从而提高整个系统的可用性。
+
[source,yaml]
----
eureka:
    client:
        service-url:
            defaultZone: http://root:root@eureka1:8761/eureka/,http://root:root@eureka2:8762/eureka/,http://root:root@eureka3:8763/eureka/
        register-with-eureka: true
        fetch-registry: true
    instance:
        prefer-ip-address: true
        ip-address: 127.0.0.1
----

==== 配置 Eureka


===== file -> eureka/src/main/resources/application-peer1.yml
[source,yaml]
----
server:
  port: 8761

spring:
  application:
    name: eureka-server-clustered
  security:
    basic:
      enable: true
    user:
      name: root
      password: root

eureka:
  instance:
    hostname: eureka1
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://root:root@eureka2:8762/eureka/,http://root:root@eureka3:8763/eureka/
  server:
    enable-self-preservation: false
    # Eureka Server 的核心配置参数，用于控制服务失效实例的清理频率 10s。
    eviction-interval-timer-in-ms: 10000
----

===== file -> eureka/src/main/resources/application-peer2.yml
[source,yaml]
----
server:
  port: 8762

spring:
  application:
    name: eureka-server-clustered
  security:
    basic:
      enable: true
    user:
      name: root
      password: root

eureka:
  instance:
    hostname: eureka2
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://root:root@eureka1:8761/eureka/,http://root:root@eureka3:8763/eureka/
  server:
    enable-self-preservation: false
    # Eureka Server 的核心配置参数，用于控制服务失效实例的清理频率 10s。
    eviction-interval-timer-in-ms: 10000
----

===== file -> eureka/src/main/resources/application-peer3.yml
[source,yaml]
----
server:
  port: 8763

spring:
  application:
    name: eureka-server-clustered
  security:
    basic:
      enable: true
    user:
      name: root
      password: root

eureka:
  instance:
    hostname: eureka3
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://root:root@eureka1:8761/eureka/,http://root:root@eureka2:8762/eureka/
  server:
    enable-self-preservation: false
    # Eureka Server 的核心配置参数，用于控制服务失效实例的清理频率 10s。
    eviction-interval-timer-in-ms: 10000
----

===== 反例: 创建 nginx 容器实现访问 Eureka 3 台服务器集群的负载均衡（会引入 nginx 单点故障问题），网关集群可以这样配置！！！
.创建 nginx 容器
[source,console]
----
docker run -d --name nginx \
-p 80:80 \
-p 8760:8760 \
-v ./eureka.conf:/etc/nginx/conf.d/eureka.conf \
nginx
----

NOTE: 使用命令行可以同时映射多个端口。docker desktop GUI 客户端无法映射多个端口。

***

WARNING: nginx 出现单点故障，则整个 Eureka 集群无法访问。所以这种方式用的很少。


.好好理解一下
****
- **Eureka 自己带了客户端负载均衡思想**

  - 客户端直接配置多台 `Eureka Server`，会自动轮询、重试。
  - 集群节点之间数据同步，不需要额外中间层。

- **Nginx 放在这里反而引入了单点**

  - Eureka 是 peer-to-peer 对等架构，本来就没有“主从”问题。
  - 加个 Nginx 只会让本来不需要的层变成潜在风险点。

- **现在更清楚 Nginx 的定位**

  - 它更适合放在 **网关层**（对外入口），做统一访问、鉴权、流量控制。
  - 不适合放在 **注册中心层**。
****

====== file -> eureka/src/main/resources/eureka.conf
[source,python]
----
upstream eureka-cluster {
    server host.docker.internal:8761;
    server host.docker.internal:8762;
    server host.docker.internal:8763;
}

server {
    listen 8760;
    location / {
        proxy_pass http://eureka-cluster;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
----

要让容器里的 Nginx 把请求转发到“宿主机上的 Eureka”，就得用宿主机在 Docker 网络中的地址。 +
Docker 已经预留了一个特殊 DNS 名：host.docker.internal +
它自动解析成宿主机在 Docker 网桥里的 IP。

访问 http://localhost:8760/ 会按 nginx 默认的负载均衡访问 3 台 Eureka 服务器。

==== 配置 微服务(2个)


===== file -> service-item/src/main/resources/application.yml
****
name 和 instance 两者都有重要作用，缺一不可：

- spring.application.name：服务的逻辑名称，用于服务发现和负载均衡
- eureka.instance 配置：实例的网络地址，用于实际通信

即使使用 IP 注册，仍然需要服务名称来进行服务发现和调用。
****

====== port
[source,yaml]
----
### 服务端口号(本身是一个web项目)
server:
    port: 8081
----

====== name
[source,yaml]
----
### 起个名字作为服务名称(该服务注册到eureka注册中心的名称，比如商品服务)
spring:
    application:
        name: app-item
----

====== eureka
[source,yaml]
----
### 服务注册到 eureka 注册中心的地址
eureka:
    client:
        service-url:
            # defaultZone: http://root:root@127.0.0.1:8761/eureka/
            defaultZone: http://root:root@eureka1:8761/eureka/,http://root:root@eureka2:8762/eureka/,http://root:root@eureka3:8763/eureka/
        register-with-eureka: true # 因为该应用为服务提供者，是 eureka 的一个客户端，需要注册到注册中心
        fetch-registry: true       # 是否需要从 eureka 上检索服务

    instance:
        prefer-ip-address: true    # 使用IP地址注册而不是主机名
        ip-address: 127.0.0.1      # 客户端在注册时使用自己的IP，而不是主机名。
                                   # 这是生产环境的最佳实践，避免主机名解析问题。
----

===== file -> service-order/src/main/resources/application.yml


====== port
[source,yaml]
----
server:
    port: 8091
----

====== name
[source, yaml]
----
# 起个名字作为服务名称(该服务注册到 eureka 注册中心的名称，比如订单服务)
spring:
    application:
        name: app-order
----

====== eureka
[source,yaml]
----
# 服务注册到 eureka 注册中心的地址
eureka:
    client:
        service-url:
            # defaultZone: http://root:root@127.0.0.1:8761/eureka/
            defaultZone: http://root:root@eureka1:8761/eureka/,http://root:root@eureka2:8762/eureka/,http://root:root@eureka3:8763/eureka/
        register-with-eureka: true  # 因为该应用为服务提供者，是 eureka 的一个客户端，需要注册到注册中心
        fetch-registry: true        # 是否需要从 eureka 上检索服务
    instance:
        prefer-ip-address: true     # 使用 IP地址 注册而不是主机名
        ip-address: 127.0.0.1       # 客户端在注册时使用自己的 IP，而不是主机名
                                    # 这是生产环境的最佳实践。避免主机名解析问题
----

==== 测试高可用性


===== httpie 测试
[source,console]
----
http :8091/order/201810300001
----

....
HTTP/1.1 200
Connection: keep-alive
Content-Type: application/json
Date: Mon, 22 Sep 2025 16:32:37 GMT
Keep-Alive: timeout=60
Transfer-Encoding: chunked

{
    "createDate": "2025-09-22T16:30:20.174+00:00",
    "orderDetails": [
        {
            "item": {
                "desc": "商品描述1",
                "id": 1,
                "pic": "http://图片1",
                "price": 1000,
                "title": "商品1"
            },
            "orderId": "201810300001"
        },
        {
            "item": {
                "desc": "商品描述2",
                "id": 2,
                "pic": "http://图片2",
                "price": 2000,
                "title": "商品2"
            },
            "orderId": "201810300001"
        }
    ],
    "orderId": "201810300001",
    "updateDate": "2025-09-22T16:30:20.174+00:00",
    "userId": 1
}
....

===== 停止一个 eureka 服务再测试
停掉端口为 8761 的 eureka 服务，再测试应该还是能正常访问的。

===== 创建新订单再测试
为了防止是缓存的效果，再创建一个订单 order2，如下。

====== file -> service-order/src/main/java/com/tjise/serviceorder/service/OrderService.java


====== class OrderService
[source,java]
----
/**
 * 订单服务类
 * 提供订单查询功能，并通过调用商品服务获取商品详细信息
 */
@Service
public class OrderService {
    @others
}
----

====== ORDER_DATA 模拟数据
[source,java]
----
// 使用静态Map模拟数据库存储订单数据
private static final Map<String, Order> ORDER_DATA = new HashMap<String, Order>();
// 初始化订单数据
static {
    // 模拟数据库，构造测试数据
    @others
}
----

====== 第一个订单 order
[source,java]
----
Order order = new Order();
order.setOrderId("201810300001");
order.setCreateDate(new Date());
order.setUpdateDate(order.getCreateDate());  // 真会偷懒呀
order.setUserId(1L);
List<OrderDetail> orderDetails = new ArrayList<OrderDetail>();

// 创建第一个商品详情（仅保存商品ID，需要调用商品微服务获取详细信息）
Item item = new Item();
item.setId(1L);
orderDetails.add(new OrderDetail(order.getOrderId(), item));

// 创建第二个商品详情
item = new Item();
item.setId(2L);
orderDetails.add(new OrderDetail(order.getOrderId(), item));

order.setOrderDetails(orderDetails);

ORDER_DATA.put(order.getOrderId(), order);
----

====== 第二个订单 order2
[source,java]
----
Order order2 = new Order();
order2.setOrderId("201810300002");
order2.setCreateDate(new Date());
order2.setUpdateDate(order.getCreateDate());  // 真会偷懒呀
order2.setUserId(2L);
List<OrderDetail> orderDetails2 = new ArrayList<OrderDetail>();

// 创建第一个商品详情（仅保存商品ID，需要调用商品微服务获取详细信息）
Item item2 = new Item();
item2.setId(3L);
orderDetails2.add(new OrderDetail(order2.getOrderId(), item2));

// 创建第二个商品详情
item2 = new Item();
item2.setId(4L);
orderDetails2.add(new OrderDetail(order2.getOrderId(), item2));

order2.setOrderDetails(orderDetails2);

ORDER_DATA.put(order2.getOrderId(), order2);
----

====== queryOrderById
[source,java]
----
// 注入商品服务，用于查询商品详细信息
@Autowired
private ItemService itemService;
/**
 * 根据订单ID查询订单数据
 * 
 * @param orderId 订单ID
 * @return Order 订单信息，包含完整的商品详情
 */
public Order queryOrderById(String orderId) throws IOException {
    // 从模拟数据库中查询订单
    Order order = ORDER_DATA.get(orderId);
    if (null == order) {
        return null;
    }
    // 获取订单详情列表
    List<OrderDetail> orderDetails = order.getOrderDetails();

    // 遍历订单详情，通过商品微服务查询商品详细数据
    for (OrderDetail orderDetail : orderDetails) {
        // 通过商品微服务查询商品详细数据
        Item item = itemService.queryItemById(orderDetail.getItem().getId());
        if (null == item) {
            continue;
        }
        // 将查询到的商品详细信息设置到订单详情中
        orderDetail.setItem(item);
    }
    return order;
}
----

===== 重启 service-order 后，httpie 测试:
[source,console]
----
http :8091/order/201810300002
----

.测试结果说明 Eureka 高可用无问题
....
HTTP/1.1 200
Connection: keep-alive
Content-Type: application/json
Date: Mon, 22 Sep 2025 16:31:11 GMT
Keep-Alive: timeout=60
Transfer-Encoding: chunked

{
    "createDate": "2025-09-22T16:30:20.175+00:00",
    "orderDetails": [
        {
            "item": {
                "desc": "商品描述3",
                "id": 3,
                "pic": "http://图片3",
                "price": 3000,
                "title": "商品3"
            },
            "orderId": "201810300002"
        },
        {
            "item": {
                "desc": "商品描述4",
                "id": 4,
                "pic": "http://图片4",
                "price": 4000,
                "title": "商品4"
            },
            "orderId": "201810300002"
        }
    ],
    "orderId": "201810300002",
    "updateDate": "2025-09-22T16:30:20.174+00:00",
    "userId": 2
}
....

== 8. 容错保护：Resilience4j


=== 雪崩效应
在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。

服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用，并将不可用逐渐放大的过程。

如下图所示：A 作为服务提供者，B 为 A 的服务消费者，C 和 D 是 B 的服务消费者。A 不可用引起了 B 的不可用，并将不可用像滚雪球一样放大到 C 和 D 时，雪崩效应就形成了。

image::img/avalanche.png[,600]

下面我们使用 Resilience4j 依赖，来解决服务雪崩效应。

=== Resilience4j 快速入门
IMPORTANT: 提前说明一下，我们是 #启了负载均衡# 的，所以 #不能使用注解# 的方式来使用 queryItemByIdFallback, 会被负载均衡给拦截掉。
只能使用手动通过 circuitBreakerRegistry 的方式来启用断路器 Resilience4j，这点要注意了。因为通过多次调试发现，Resilience4j 不起作用的原因就在这儿了。

==== file -> service-order/pom.xml


===== resilience4j 依赖
[source,scss]
....
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot2</artifactId>
    <!-- 兼容 Spring Boot 2.7.18 -->
    <version>1.7.0</version>
</dependency>
....

==== file -> service-order/src/main/resources/application.yml


===== port
[source,yaml]
----
server:
    port: 8091
----

===== name
[source, yaml]
----
# 起个名字作为服务名称(该服务注册到 eureka 注册中心的名称，比如订单服务)
spring:
    application:
        name: app-order
----

===== eureka
[source,yaml]
----
# 服务注册到 eureka 注册中心的地址
eureka:
    client:
        service-url:
            # defaultZone: http://root:root@127.0.0.1:8761/eureka/
            defaultZone: http://root:root@eureka1:8761/eureka/,http://root:root@eureka2:8762/eureka/,http://root:root@eureka3:8763/eureka/
        register-with-eureka: true  # 因为该应用为服务提供者，是 eureka 的一个客户端，需要注册到注册中心
        fetch-registry: true        # 是否需要从 eureka 上检索服务
    instance:
        prefer-ip-address: true     # 使用 IP地址 注册而不是主机名
        ip-address: 127.0.0.1       # 客户端在注册时使用自己的 IP，而不是主机名
                                    # 这是生产环境的最佳实践。避免主机名解析问题
----

===== resilience4j
[source,yaml]
----
resilience4j:
  circuitbreaker:
    instances:
      # OrderService 这个名称是在代码中创建 CircuitBreaker 实例时指定的标识符，配置中的名称必须与代码中的名称完全一致才能生效。
      OrderService:
        sliding-window-size: 5                  # 需要 5 次调用来计算失败率
        failure-rate-threshold: 50              # 大于等于 50% 失败率才跳闸
        wait-duration-in-open-state: 10s        # 10 秒后进入半开状态
        permitted-number-of-calls-in-half-open-state: 2     # 半开状态允许 2 次调用
        sliding-window-type: COUNT_BASED        # 基于调用次数
        record-exceptions:                      # 哪些异常算失败
          - org.springframework.web.reactive.function.client.WebClientResponseException
          - java.lang.RuntimeException
          - java.io.IOException
        ignore-exceptions:                      # 忽略的异常类型
          - java.lang.IllegalArgumentException
----

NOTE: 实际生产要宽松一些的。

[caption=]
测试 vs 生产
[cols="1,1,1",options="header"]
|===
| 场景    | 测试配置 | 生产配置
| 窗口大小 | 5 次调用 | 100 次调用
| 故障阈值 | 50%     | 75%
| 恢复时间 | 10 秒   | 60秒
| 目的    | 快速验证 | 稳定运行
|===

==== file -> service-order/src/main/java/com/tjise/serviceorder/service/OrderService.java


===== class OrderService
[source,java]
----
/**
 * 订单服务类
 * 提供订单查询功能，并通过调用商品服务获取商品详细信息
 */
@Service
public class OrderService {

    @Autowired
    private CircuitBreakerRegistry circuitBreakerRegistry;

    @others
}
----

====== Item queryItemByIdWithCircuitBreaker
[source,java]
----
// name 对应 application.yml 中的配置
public Item queryItemByIdWithCircuitBreaker(Long id) {
    CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker("OrderService");
    System.out.println("=== 断路器状态: " + circuitBreaker.getState() + " ===");
    System.out.println("=== 断路器失败率: " + circuitBreaker.getMetrics().getFailureRate() + " ===");
    System.out.println("=== 断路器调用次数: " + circuitBreaker.getMetrics().getNumberOfBufferedCalls() + " ===");

    try {
        Item result = circuitBreaker.executeSupplier(
            () -> itemService.queryItemByIdWithWebClient(id)
        );
        System.out.println("=== WebClient 调用成功 ===");
        return result;
    } catch (Exception e) {
        System.out.println("=== 断路器抛出异常: " + e.getClass().getSimpleName() + " - " + e.getMessage() + " ===");
        throw e;
    }
}
----

====== Item queryItemByIdFallback 断路器降级方法
[source,java]
----
/**
 * 断路器降级方法
 * @param id 商品 ID
 * @param throwable 抛出的异常
 * @return 降级后的默认商品信息
 */
public Item queryItemByIdFallback(Long id, Throwable throwable) {
    System.out.println("=======CircuitBreaker 降级处理，原因：" + throwable.getMessage());
    return new Item(id, "查询商品信息出错", null, null, null);
}
----

====== queryOrderById
[source,java]
----
// 注入商品服务，用于查询商品详细信息
@Autowired
private ItemService itemService;
/**
 * 根据订单ID查询订单数据
 * 
 * @param orderId 订单ID
 * @return Order 订单信息，包含完整的商品详情
 */
public Order queryOrderById(String orderId) throws IOException {
    // 从模拟数据库中查询订单
    Order order = ORDER_DATA.get(orderId);
    if (null == order) {
        return null;
    }
    // 获取订单详情列表
    List<OrderDetail> orderDetails = order.getOrderDetails();

    // 遍历订单详情，通过商品微服务查询商品详细数据
    for (OrderDetail orderDetail : orderDetails) {
        // 通过商品微服务查询商品详细数据
        try {
            Item item = queryItemByIdWithCircuitBreaker(orderDetail.getItem().getId());
            if (null == item) {
                continue;
            }
            // 将查询到的商品详细信息设置到订单详情中
            orderDetail.setItem(item);
        } catch (Exception e) {
            // 如果断路器抛出异常，使用降级商品
            // 注意：这里不再打印日志，因为 queryItemByIdWithCircuitBreaker 中已经处理了异常
            Item fallbackItem = queryItemByIdFallback(orderDetail.getItem().getId(), e);
            orderDetail.setItem(fallbackItem);
        }
    }
    return order;
}
----

==== 测试 Resilience4j
测试步骤：

1. 启动 Eureka 服务注册中心
2. 启动 service-item 服务（也可以不启动）
3. 启动 service-order 服务
4. 关闭 service-item 服务（这样调用会失败）
5. 调用 order 服务的相关接口
+
[source,console]
----
http :8091/order/201810300001
----

5. 重复调用几次，因为 service-item 不在线，所以会没用失败，超过 failure-rate-threshold 设置的阈值。

6. 观察日志输出，应该会看到降级方法被调用。
+
.输出结果如下
....
2025-10-01 17:17:40.308  INFO 4711 --- [nio-8091-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2025-10-01 17:17:40.309  INFO 4711 --- [nio-8091-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms
=== 断路器状态: CLOSED ===
=== 断路器失败率: -1.0 ===
=== 断路器调用次数: 0 ===
2025-10-01 17:17:40.437  WARN 4711 --- [nio-8091-exec-1] o.s.c.l.core.RoundRobinLoadBalancer      : No servers available for service: app-item
2025-10-01 17:17:40.438  WARN 4711 --- [nio-8091-exec-1] eactorLoadBalancerExchangeFilterFunction : LoadBalancer does not contain an instance for the service app-item
=== 断路器抛出异常: ServiceUnavailable - 503 Service Unavailable from UNKNOWN  ===
=======CircuitBreaker 降级处理，原因：503 Service Unavailable from UNKNOWN 
=== 断路器状态: CLOSED ===
=== 断路器失败率: -1.0 ===
=== 断路器调用次数: 1 ===
2025-10-01 17:17:40.478  WARN 4711 --- [nio-8091-exec-1] o.s.c.l.core.RoundRobinLoadBalancer      : No servers available for service: app-item
2025-10-01 17:17:40.478  WARN 4711 --- [nio-8091-exec-1] eactorLoadBalancerExchangeFilterFunction : LoadBalancer does not contain an instance for the service app-item
=== 断路器抛出异常: ServiceUnavailable - 503 Service Unavailable from UNKNOWN  ===
=======CircuitBreaker 降级处理，原因：503 Service Unavailable from UNKNOWN 
=== 断路器状态: CLOSED ===
=== 断路器失败率: -1.0 ===
=== 断路器调用次数: 2 ===
2025-10-01 17:18:04.135  WARN 4711 --- [nio-8091-exec-3] o.s.c.l.core.RoundRobinLoadBalancer      : No servers available for service: app-item
2025-10-01 17:18:04.135  WARN 4711 --- [nio-8091-exec-3] eactorLoadBalancerExchangeFilterFunction : LoadBalancer does not contain an instance for the service app-item
=== 断路器抛出异常: ServiceUnavailable - 503 Service Unavailable from UNKNOWN  ===
=======CircuitBreaker 降级处理，原因：503 Service Unavailable from UNKNOWN 
=== 断路器状态: CLOSED ===
=== 断路器失败率: -1.0 ===
=== 断路器调用次数: 3 ===
2025-10-01 17:18:04.136  WARN 4711 --- [nio-8091-exec-3] o.s.c.l.core.RoundRobinLoadBalancer      : No servers available for service: app-item
2025-10-01 17:18:04.136  WARN 4711 --- [nio-8091-exec-3] eactorLoadBalancerExchangeFilterFunction : LoadBalancer does not contain an instance for the service app-item
=== 断路器抛出异常: ServiceUnavailable - 503 Service Unavailable from UNKNOWN  ===
=======CircuitBreaker 降级处理，原因：503 Service Unavailable from UNKNOWN 
=== 断路器状态: CLOSED ===
=== 断路器失败率: -1.0 ===
=== 断路器调用次数: 4 ===
2025-10-01 17:18:10.612  WARN 4711 --- [nio-8091-exec-5] o.s.c.l.core.RoundRobinLoadBalancer      : No servers available for service: app-item
2025-10-01 17:18:10.612  WARN 4711 --- [nio-8091-exec-5] eactorLoadBalancerExchangeFilterFunction : LoadBalancer does not contain an instance for the service app-item
=== 断路器抛出异常: ServiceUnavailable - 503 Service Unavailable from UNKNOWN  ===
=======CircuitBreaker 降级处理，原因：503 Service Unavailable from UNKNOWN 
=== 断路器状态: OPEN ===  --> 断路器已经是打开状态了
=== 断路器失败率: 100.0 ===
=== 断路器调用次数: 5 ===  --> 第 5 次才开始计算的
=== 断路器抛出异常: CallNotPermittedException - CircuitBreaker 'OrderService' is OPEN and does not permit further calls ===
=======CircuitBreaker 降级处理，原因：CircuitBreaker 'OrderService' is OPEN and does not permit further calls
--> 不会进行实际的网络调用了，断路器直接返回降级结果
=== 断路器状态: OPEN ===
=== 断路器失败率: 100.0 ===
=== 断路器调用次数: 5 ===
2025-10-01 17:18:37.444  WARN 4711 --- [nio-8091-exec-7] o.s.c.l.core.RoundRobinLoadBalancer      : No servers available for service: app-item
2025-10-01 17:18:37.444  WARN 4711 --- [nio-8091-exec-7] eactorLoadBalancerExchangeFilterFunction : LoadBalancer does not contain an instance for the service app-item
=== 断路器抛出异常: ServiceUnavailable - 503 Service Unavailable from UNKNOWN  ===
=======CircuitBreaker 降级处理，原因：503 Service Unavailable from UNKNOWN 
=== 断路器状态: HALF_OPEN ===  --> 10s 以后断路器就变成半开状态，且允许 2 次实际的网络调用，可以看见负载均衡又起作用了。
=== 断路器失败率: -1.0 ===
=== 断路器调用次数: 1 ===
2025-10-01 17:18:37.446  WARN 4711 --- [nio-8091-exec-7] o.s.c.l.core.RoundRobinLoadBalancer      : No servers available for service: app-item
2025-10-01 17:18:37.446  WARN 4711 --- [nio-8091-exec-7] eactorLoadBalancerExchangeFilterFunction : LoadBalancer does not contain an instance for the service app-item
=== 断路器抛出异常: ServiceUnavailable - 503 Service Unavailable from UNKNOWN  ===
=======CircuitBreaker 降级处理，原因：503 Service Unavailable from UNKNOWN 
=== 断路器状态: OPEN ===
=== 断路器失败率: 100.0 ===  --> 2 次调用都失败了，断路器又打开了
=== 断路器调用次数: 2 ===
2025-10-01 17:19:07.312  WARN 4711 --- [nio-8091-exec-9] o.s.c.l.core.RoundRobinLoadBalancer      : No servers available for service: app-item
2025-10-01 17:19:07.312  WARN 4711 --- [nio-8091-exec-9] eactorLoadBalancerExchangeFilterFunction : LoadBalancer does not contain an instance for the service app-item
=== 断路器抛出异常: ServiceUnavailable - 503 Service Unavailable from UNKNOWN  ===
=======CircuitBreaker 降级处理，原因：503 Service Unavailable from UNKNOWN 
=== 断路器状态: HALF_OPEN ===  --> 10s 以后又变成了半开状态，如此反复吧......
=== 断路器失败率: -1.0 ===
=== 断路器调用次数: 1 ===

直到 app-item(service-item) 恢复正常，断路器重新将状态 State 更改为 CLOSE。
....

这个日志完美展示了：

- ✅ 断路器状态管理：CLOSED → OPEN → HALF_OPEN
- ✅ 阈值触发机制： 失败率达到50%时跳闸
- ✅ 自动恢复尝试： 定期试探服务可用性
- ✅ 性能优化：OPEN状态时避免无效调用

断路器完全按照设计工作，在系统层面提供了有效的故障保护和自动恢复机制！

== 9. OpenFeign 客户端（声明式 REST 调用）
虽然使用了 WebClient 或 RestTemplate + @LoadBalanced + Resilience4j 可以实现负载均衡和容错处理，但是这个编码在实现大量业务时会显得太过于冗余（如，多参数的 URL 拼接）。

思考：有没有更加优雅的实现呢？有，那就是 OpenFeign。

=== Feign 与其它客户端差异与关系
1. 基本概念差异
+
OpenFeign:

- 是一个声明式的 Web 服务客户端
- 通过注解驱动，将 HTTP 请求抽象为接口方法
- 本质上是对 HTTP 客户端的高层次封装
- 专注于微服务间的通信

+
WebClient/RestTemplate:

- 是底层的 HTTP 客户端工具
- RestTemplate 是同步阻塞的
- WebClient 是响应式异步的
- 提供基础的 HTTP 操作能力

2. 关系梳理
+
实际上，Feign 与其他工具的关系是：Feign 是一个抽象层，它可以使用不同的底层 HTTP 客户端实现：

- 默认使用 HttpURLConnection
- 可以配置使用 Apache HttpClient
- 可以配置使用 OkHttp
- 甚至可以与 WebClient 集成

但是，Feign 不能直接使用 RestTemplate 或 WebClient 作为其底层实现，因为它们的设计理念不同。

=== Feign 与其它客户端在微服务架构中的使用场景
Feign 专为微服务设计:

- 与 Eureka、LoadBalancer 无缝集成
- 内置负载均衡支持
- 提供声明式服务调用
- 天然支持熔断器模式

WebClient/RestTemplate 需要额外配置:

- RestTemplate: 需要 @LoadBalanced 注解与服务发现集成
- WebClient: 需要手动配置与 LoadBalancer 的集成
- 都需要额外配置熔断机制

=== Feign 与其它客户端代码示例对比


==== 项目中使用的 RestTemplate 方式
[source,java]
----
@Service
public class ItemService {

    @Autowired
    private RestTemplate restTemplate;

    public Item queryItemById(Long id) {
        Item item = restTemplate.getForObject(
                "http://app-item/item/" + id, Item.class);
        return item;
    }
}
----

==== 项目中使用的 WebClient 方式
[source,java]
----
@Service
public class ItemService {

    private final WebClient webClient;

    // 单构造器注入
    public ItemService(WebClient webClient) {
        this.webClient = webClient;
    }

    public Item queryItemByIdWithWebClient(Long id) {
        return webClient.get()
            .uri("/{id}", id)
            .retrieve()
            .bodyToMono(Item.class)  // 类似于 js Promise
            .block();   // 同步调用
    }
}
----

==== 项目中使用的 Feign 方式
先展示一下，具体内容参后面详细步骤。注意：这是发送请求哟！

[source,java]
----
// 要访问在 Eureka 中的服务名，并指定实现该接口的降级类名
@FeignClient(name = "app-item", fallback = ItemFallback.class)
public interface ItemFeignClient {
    @GetMapping("/item/{id}")
    Item queryItemById(@PathVariable("id") Long id);
}
----

=== 各自优势和适用场景总结
Feign 优势:

1. 声明式接口: 代码简洁，像调用本地方法
2. 开箱即用: 自动集成负载均衡、熔断器
3. 微服务友好的: 与 Spring Cloud 生态无缝集成
4. 配置简单: 通过注解和配置文件即可完成大部分配置

WebClient/RestTemplate 优势:

1. 灵活性: 完全控制 HTTP 请求的每个细节
2. 通用性: 不仅适用于微服务，也适用于一般 HTTP 客户端场景
3. 响应式: WebClient 支持非阻塞异步编程
4. 性能: 底层控制，理论上性能更高

关系总结:

- Feign 是面向微服务的高级抽象层
- WebClient/RestTemplate 是通用的底层 HTTP 客户端
- 三者解决的问题层次不同
- Feign 自动处理了很多微服务特有的问题（负载均衡、熔断等）
- WebClient/RestTemplate 需要手动配置这些微服务特性

在 Spring Cloud 微服务项目中，Feign 提供了更优雅的解决方案，减少了样板代码，让开发者更专注于业务逻辑。

总的来说，Feign 与 WebClient|RestTemplate 并不是直接竞争关系，而是解决不同层次问题的工具。
Feign 更专注于微服务间的声明式通信，而 WebClient|RestTemplate 是更通用的 HTTP 客户端工具。在微服务架构中，Feign 提供了更高层次的抽象和更好的开发体验。

=== Feign 客户端配合断路器入门


==== 1) 直接使用断路器 Resilience4j (纯手工)
正常测试

* http :8091/order/201810300001 


item3 id 为 -1，会抛出异常，查看 8091 打印

* http :8091/order/201810300003

===== file -> service-order/pom.xml


====== openfeign
[source,scss]
....
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
....

===== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java


====== class ServiceOrderApplication -> @EnableFeignClients
[source,java]
----
/**
 * 订单服务启动类，Spring Boot 应用程序入口点。
 */
@SpringBootApplication
@EnableEurekaClient  // 启用 Eureka 客户端功能
@EnableFeignClients  // --- New Added --- 会初始化和配置 feign
public class ServiceOrderApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceOrderApplication.class, args);
    }
    // 包含其他代码
    @others
}
----

.负载均衡使用拦截器原理：
****
1. 拦截请求URL
2. 识别服务名
3. 通过服务发现获取实际地址
4. 替换URL并发起请求
****

===== file -> service-order/src/main/java/com/tjise/serviceorder/client/ItemFeignClient.java
新建 OpenFeign 接口文件

[source,java]
----
package com.tjise.serviceorder.client;

import com.tjise.serviceorder.pojo.Item;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "app-item")  // 要访问的在 Eureka 中的服务名
public interface ItemFeignClient {
    @GetMapping("/item/{id}")
    Item queryItemById(@PathVariable("id") Long id);
}
----

===== file -> service-order/src/main/java/com/tjise/serviceorder/service/OrderService.java


====== class OrderService
[source,java]
----
/**
 * 订单服务类
 * 提供订单查询功能，并通过调用商品服务获取商品详细信息
 */
@Service
public class OrderService {

    @Autowired
    private CircuitBreakerRegistry circuitBreakerRegistry;

    @Autowired
    ItemFeignClient itemFeignClient;  // --- New Added ---

    @others
}
----

====== 第三个订单 order3 -- item3.setId(-1L) 设为 -1 ItemController.java 会抛出异常
[source,java]
----
Order order3 = new Order();
order3.setOrderId("201810300003");
order3.setCreateDate(new Date());
order3.setUpdateDate(order.getCreateDate());  // 真会偷懒呀
order3.setUserId(3L);
List<OrderDetail> orderDetails3 = new ArrayList<OrderDetail>();

// 创建第一个商品详情（仅保存商品ID，需要调用商品微服务获取详细信息）
Item item3 = new Item();
item3.setId(-1L);          // --- 注意这里设置了 -1 哟! ---
orderDetails3.add(new OrderDetail(order3.getOrderId(), item3));

// 创建第二个商品详情
item3 = new Item();
item3.setId(6L);
orderDetails3.add(new OrderDetail(order3.getOrderId(), item3));

order3.setOrderDetails(orderDetails3);

ORDER_DATA.put(order3.getOrderId(), order3);
----

====== Item queryItemByIdWithCircuitBreaker
[source,java]
----
// name 对应 application.yml 中的配置
public Item queryItemByIdWithCircuitBreaker(Long id) {
    CircuitBreaker circuitBreaker = circuitBreakerRegistry
            .circuitBreaker("OrderService");
    System.out.println("=== 断路器状态: " + 
            circuitBreaker.getState());
    System.out.println("=== 断路器失败率: " + 
            circuitBreaker.getMetrics().getFailureRate());
    System.out.println("=== 断路器调用次数: " + 
            circuitBreaker.getMetrics().getNumberOfBufferedCalls());

    try {
        // 这是之前使用 WebClient 的方式
        // Item result = circuitBreaker.executeSupplier(
            // () -> itemService.queryItemByIdWithWebClient(id));  // 注释不用了

        // 启用断路器
        Item result = circuitBreaker.executeSupplier(  // 断路器会生效
            () -> itemFeignClient.queryItemById(id)    // --New Added-- 使用 feign
        );
        System.out.println("result:" + result);
        return result;
    }
    catch (Exception e) {
        System.out.println("=== 断路器抛出异常: " +
                e.getClass().getSimpleName() + 
                " - " + e.getMessage());
        throw e;
    }
}
----

===== file -> service-item/src/main/java/com/tjise/serviceitem/controller/ItemController.java


====== public class ItemController --New Added-- 当 ID 为 -1 时抛出异常，为了测试出异常会导致断路器 Open
[source,java]
----
@RestController
public class ItemController {

    @Autowired
    private ItemService itemService;
    
    @Value("${server.port}")
    private int serverPort;

    private static final Logger logger = Logger.getLogger(ItemController.class.getName());

    /**
     * 对外提供接口服务，查询商品信息
     *
     * @param id
     * @return
     */
    @GetMapping(value = "item/{id}")
    public Item queryItemById(@PathVariable("id") Long id) {
        // 增加了日志打印功能，方便查看是哪个 service-item 提供的服务。
        logger.info("Handling request on port: " + serverPort + " for item ID: " + id);
        System.out.println("Processing request on port: " + serverPort + " for item ID: " + id);
        
        // -- New Added Begin --- 测试用例，当 ID 为 -1 时抛出运行时异常
        if (id == -1) {
            System.out.println("=== 触发异常测试，ID 为 -1 ===");
            throw new RuntimeException("服务内部错误");
        }
        // -- New Added End -- 
        return this.itemService.queryItemById(id);  // 正常返回
    }
}
----

==== 2) 使用自带断路器 Resilience4j（SpringCloud 自带，在服务层更细粒度控制）
正常测试
http :8091/order/201810300001 


item3 id 为 -1，会抛出异常，查看 8091 打印 +
http :8091/order/201810300003

===== file -> service-order/pom.xml


====== resilience4j 注释掉不用了
[source,scss]
....
<!-- <dependency> -->
    <!-- <groupId>io.github.resilience4j</groupId> -->
    <!-- <artifactId>resilience4j-spring-boot2</artifactId> -->
    <!-- <version>1.7.0</version> -->
<!-- </dependency> -->
....

====== spring-cloud-...resilience4j
[source,java]
....
// spring cloud 集成的 resilience4j
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>
....

===== file -> service-order/src/main/java/com/tjise/serviceorder/service/OrderService.java


====== class OrderService
[source,java]
----
/**
 * 订单服务类
 * 提供订单查询功能，并通过调用商品服务获取商品详细信息
 */
@Service
public class OrderService {

    @Autowired
    // private CircuitBreakerRegistry circuitBreakerRegistry;  // 不能使用了
    private CircuitBreakerFactory circuitBreakerFactory;  // 更改为工厂模式
    
    @Autowired
    ItemFeignClient itemFeignClient;  // --- New Added ---

    @others
}
----

====== Item queryItemByIdWithCircuitBreaker -- 主要更改的代码
[source,java]
----
public Item queryItemByIdWithCircuitBreaker(Long id) {
    // Using Spring Cloud Circuit Breaker with CircuitBreakerFactory
    // 使用 Factory 创建断路器
    return circuitBreakerFactory.create("OrderService").run(  // OrderService 是在yaml配置文件中定义的名称
        () -> {
            Item result = itemFeignClient.queryItemById(id);  // 使用 feign
            System.out.println("result:" + result);
            return result;
        },
        throwable -> queryItemByIdFallback(id, throwable)
    );
}
----

====== Item queryItemByIdFallback 断路器降级方法
[source,java]
----
/**
 * 断路器降级方法
 * @param id 商品 ID
 * @param throwable 抛出的异常
 * @return 降级后的默认商品信息
 */
public Item queryItemByIdFallback(Long id, Throwable throwable) {
    System.out.println("=======CircuitBreaker 降级处理，原因：" + throwable.getMessage());
    return new Item(id, "查询商品信息出错", null, null, null);
}
----

====== Order queryOrderById
[source,java]
----
// 注入商品服务，用于查询商品详细信息
@Autowired
private ItemService itemService;
/**
 * 根据订单ID查询订单数据
 * 
 * @param orderId 订单ID
 * @return Order 订单信息，包含完整的商品详情
 */
public Order queryOrderById(String orderId) throws IOException {
    // 从模拟数据库中查询订单
    Order order = ORDER_DATA.get(orderId);
    if (null == order) {
        return null;
    }
    // 获取订单详情列表
    List<OrderDetail> orderDetails = order.getOrderDetails();

    // 遍历订单详情，通过商品微服务查询商品详细数据
    for (OrderDetail orderDetail : orderDetails) {
        // 通过商品微服务查询商品详细数据
        try {
            Item item = queryItemByIdWithCircuitBreaker(
                orderDetail.getItem().getId()
            );
            if (null == item) {
                continue;
            }
            // 将查询到的商品详细信息设置到订单详情中
            orderDetail.setItem(item);
        } catch (Exception e) {
            // 如果断路器抛出异常，使用降级商品
            Item fallbackItem = queryItemByIdFallback(
                orderDetail.getItem().getId(), e
            );
            orderDetail.setItem(fallbackItem);
        }
    }
    return order;
}
----

==== 3) 使用自带断路器 Feign（Feign 集成 SpringCloud 自带的断路器 Resilience4j，不需要在服务层手动管理断路器，不成功！）
WARNING: 断路器没有成功！fallback 是可以的。


正常测试
http :8091/order/201810300001

item3 id 为 -1，会抛出异常，查看 8091 打印，可以查看断路器工作状态的切换。 +
http :8091/order/201810300003


查看负载均衡情况：

1. 把 8081 | 8082 | 8083 端口的服务都启动。

2. 发送上面的命令查看各个端口的微服务是否有日志打印。
+
.日志类似于这样
....
2025-10-06 18:33:17.112  INFO 91339 --- [nio-8082-exec-3] c.t.s.controller.ItemController          : Handling request on port: 8082 for item ID: 2
Processing request on port: 8082 for item ID: 2
....

===== file -> service-order/src/main/resources/application.yml


====== feign 开启断路器
[source,yaml]
----
feign:
  circuitbreaker:
    enabled: true
----

====== resilience4j 要改 OrderService -> app-item (service-item 在 Eureka 中注册的服务名)
[source,yaml]
----
resilience4j:
  circuitbreaker:
    instances:
      # OrderService:  这里就要改成与 Feign 要使用的 Eureka 服务名一样才行，如下面改成 app-item
      app-item:        # --New Added--
        sliding-window-size: 5                  # 需要 5次调用来计算失败率
        failure-rate-threshold: 20              # 50% 失败率才跳闸
        wait-duration-in-open-state: 10s        # 10 秒后进入半开状态
        permitted-number-of-calls-in-half-open-state: 2     # 半开状态允许 2 次调用
        sliding-window-type: COUNT_BASED        # 基于调用次数
        record-exceptions:                      # 哪些异常算失败
          - org.springframework.web.reactive.function.client.WebClientResponseException
          - java.lang.RuntimeException
          - java.io.IOException
        ignore-exceptions:                      # 忽略的异常类型
          - java.lang.IllegalArgumentException
----

NOTE: 实际生产要宽松一些的。

[caption=]
测试 vs 生产
[cols="1,1,1",options="header"]
|===
| 场景    | 测试配置 | 生产配置
| 窗口大小 | 5 次调用 | 100次调用
| 故障阈值 | 50%     | 75%
| 恢复时间 | 10 秒   | 60秒
| 目的    | 快速验证 | 稳定运行
|===

===== file -> service-order/src/main/java/com/tjise/serviceorder/client/ItemFeignClient.java
[source,java]
----
package com.tjise.serviceorder.client;

import com.tjise.serviceorder.pojo.Item;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

// 要访问的在 Eureka 中的服务名，并指定实现该接口的降级类名
@FeignClient(name = "app-item",
             fallback = ItemFallback.class)  // --New Added--
public interface ItemFeignClient {
    @GetMapping("/item/{id}")
    Item queryItemById(@PathVariable("id") Long id);
}
----

===== file -> service-order/src/main/java/com/tjise/serviceorder/client/ItemFallback.java
[source,java]
----
package com.tjise.serviceorder.client;

import com.tjise.serviceorder.pojo.Item;
import org.springframework.stereotype.Component;

@Component
public class ItemFallback implements ItemFeignClient {
    @Override
    public Item queryItemById(Long id) {
        System.out.println("=== ItemFallback.queryItemById 兜底回调被调用 ===");
        return new Item(id, "Feign 降级商品", null, null, null);
    }
}
----

===== file -> service-order/src/main/java/com/tjise/serviceorder/service/OrderService.java


====== class OrderService
[source,java]
----
/**
 * 订单服务类
 * 提供订单查询功能，并通过调用商品服务获取商品详细信息
 */
@Service
public class OrderService {

    // @Autowired
    // private CircuitBreakerRegistry circuitBreakerRegistry;
    // private CircuitBreakerFactory circuitBreakerFactory;  // 更改为工厂模式
    
    @Autowired
    ItemFeignClient itemFeignClient;  // --- New Added ---

    @others
}
----

====== 第三个订单 order3 -- item3.setId(-1L) 设为 -1 ItemController.java 会抛出异常
[source,java]
----
Order order3 = new Order();
order3.setOrderId("201810300003");
order3.setCreateDate(new Date());
order3.setUpdateDate(order.getCreateDate());  // 真会偷懒呀
order3.setUserId(3L);
List<OrderDetail> orderDetails3 = new ArrayList<OrderDetail>();

// 创建第一个商品详情（仅保存商品ID，需要调用商品微服务获取详细信息）
Item item3 = new Item();
item3.setId(-1L);          // --- 注意这里设置了 -1 哟! ---
orderDetails3.add(new OrderDetail(order3.getOrderId(), item3));

// 创建第二个商品详情
item3 = new Item();
item3.setId(6L);
orderDetails3.add(new OrderDetail(order3.getOrderId(), item3));

order3.setOrderDetails(orderDetails3);

ORDER_DATA.put(order3.getOrderId(), order3);
----

====== Item queryItemByIdWithCircuitBreaker -- 主要更改的代码
[source,java]
----
public Item queryItemByIdWithCircuitBreaker(Long id) {

    // --New Added-- 简化为直接调用，断路器由 Feign 自动处理
    Item result = itemFeignClient.queryItemById(id);  // 使用 feign
    System.out.println("result:" + result);
    return result;
}
----

====== Item queryItemByIdFallback 断路器降级方法 -- 没用了，可以删除了
[source,java]
----
/**
 * 断路器降级方法
 * @param id 商品 ID
 * @param throwable 抛出的异常
 * @return 降级后的默认商品信息
 */
public Item queryItemByIdFallback(Long id, Throwable throwable) {
    System.out.println("=======CircuitBreaker 降级处理，原因：" + throwable.getMessage());
    return new Item(id, "查询商品信息出错", null, null, null);
}
----

==== 开启 Spring Boot Actuator 查看断路器状态
启动应用后，您可以访问以下端点：

- http :8091/order/201810300004
+
....
HTTP/1.1 200
Connection: keep-alive
Content-Type: application/json
Date: Sun, 05 Oct 2025 14:15:05 GMT
Keep-Alive: timeout=60
Transfer-Encoding: chunked

{
    "createDate": "2025-10-05T14:14:44.090+00:00",
    "orderDetails": [
        {
            "item": {
                "desc": null,
                "id": -1,
                "pic": null,
                "price": null,
                "title": "Feign 降级商品"
            },
            "orderId": "201810300004"
        }
    ],
    "orderId": "201810300004",
    "updateDate": "2025-10-05T14:14:44.089+00:00",
    "userId": 4
}
....

- http :8091/actuator/health - 查看断路器健康状态
- http :8091/actuator/circuitbreakerevents - 查看断路器事件历史

===== file -> service-order/pom.xml


====== actuator
[source,scss]
....
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

<!-- Spring Retry -->
<!-- <dependency> -->
    <!-- <groupId>org.springframework.retry</groupId> -->
    <!-- <artifactId>spring-retry</artifactId> -->
<!-- </dependency> -->
....

===== file -> service-order/src/main/resources/application.yml


====== management
[source,yaml]
----
management:
  endpoints:
    web:
      exposure:
        include: health,info,circuitbreakerevents  # 暴露断路器事件端点
  endpoint:
    health:
      show-details: always
  health:
    circuitbreakers:
      enabled: true  # 启用断路器健康检查
----

===== file -> service-order/src/main/java/com/tjise/serviceorder/service/OrderService.java


====== class OrderService
[source,java]
----
/**
 * 订单服务类
 * 提供订单查询功能，并通过调用商品服务获取商品详细信息
 */
@Service
public class OrderService {

    // @Autowired
    // private CircuitBreakerRegistry circuitBreakerRegistry;
    // private CircuitBreakerFactory circuitBreakerFactory;  // 更改为工厂模式
    
    @Autowired
    ItemFeignClient itemFeignClient;  // --- New Added ---

    @others
}
----

====== 第四个订单 order4 -- item4.setId(-1L) 设为 -1 ItemController.java 会抛出异常
[source,java]
----
Order order4 = new Order();
order4.setOrderId("201810300004");
order4.setCreateDate(new Date());
order4.setUpdateDate(order.getCreateDate());  // 真会偷懒呀
order4.setUserId(4L);
List<OrderDetail> orderDetails4 = new ArrayList<OrderDetail>();

// 创建一个商品详情（仅保存商品ID，需要调用商品微服务获取详细信息）
Item item4 = new Item();
item4.setId(-1L);          // --- 注意这里设置了 -1 哟! ---
orderDetails4.add(new OrderDetail(order4.getOrderId(), item4));  // <1>

order4.setOrderDetails(orderDetails4);

ORDER_DATA.put(order4.getOrderId(), order4);
----

<1> 就创建一个商品，逐个累加计数，方便查看断路器的状态，不会跳数字，能看到半开状态 HALF_OPEN。
+
image::img/actuator_health.png[,900]

=== Feign 知识点
Declarative rest Client 声明式 rest 客户端（之前叫编程式 rest 客户端，如 RestTemplate）。

注解驱动

- 指定远程地址: @FeignClient
- 指定请求方式: @GetMapping @PostMapping @DeleteMapping ...
- 指定携带数据: @PathVariable(路径参数) @RequestHeader @RequestParam @RequestBody ...
- 指定结果返回: 封装成的响应模型，如商品对象 Item

==== 发送请求基本使用步骤（总结了未使用断路器 Resilience4j 的步骤）
. 引入依赖 openfeign
+
.service-order/pom.xml
[source,scss]
....
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
....

. 启动类开启 openfeign 远程调用功能 -> @EnableFeignClients
+
.service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java
[source,java]
----
@SpringBootApplication
@EnableEurekaClient  // 启用 Eureka 客户端功能
@EnableFeignClients  // --- New Added --- 会初始化和配置 feign
public class ServiceOrderApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceOrderApplication.class, args);
    }
    // 包含其他代码
    @others
}
----


. 定义 feign 客户端接口
+
[source,java]
----
// 要访问的在 Eureka 中的服务名，feign 已经实现了负载均衡，不用再写 @LoadBalanced
// 会自动注入 ItemFeignClient 对象到 IOC 容器中，后面使用时直接 @Autowired 即可
@FeignClient(name = "app-item")
public interface ItemFeignClient {
    // 使用 MVC 的注解，在 controller 上是接收请求，在 FeignClient 上是发送请求
    @GetMapping("/item/{id}")
    // 接收到的数据封装成商品对象 Item
    Item queryItemById(@PathVariable("id") Long id);  // id 由下往上传递
}
----


. 使用注入的 itemFeignClient（不要忘记先使用 @Autowired 注入）
+
[source,java]
----
public Item queryItemByIdWithCircuitBreaker(Long id) {

    // 简化为直接调用，断路器由 Feign 自动处理
    Item result = itemFeignClient.queryItemById(id);  // --New Added-- 使用 feign
    System.out.println("result:" + result);
    return result;
}
----

==== Feign 调用第三方提供的 API
测试天气 api
http://t.weather.sojson.com/api/weather/city/101030100

citycode.json 文件下载（只是单纯的测试，用不到）:
https://github.com/LS-KR/China-Citycode/blob/main/citycode.json

.通过 url 判断为第三方 API
[source,java]
----
// weather-client 是自己随便起的名字，在这儿没具体作用
// url 是第三方 API 的域名，有 url 则是第三方 API
@FeignClient(name = "weather-client", url = "http://t.weather.sojson.com")
// 定义接口的代码
----

这里只是最简单的一个 API，您可以自己找个复杂的 API 去练习一下，
比如有 @PathVariable(路径参数) @RequestHeader @RequestParam @RequestBody ...

===== file -> service-order/src/main/java/com/tjise/serviceorder/client/WeatherFeignClient.java
[source,java]
----
package com.tjise.serviceorder.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

// weather-client 是自己随便起的名字，在这儿没具体作用
// url 是第三方 API 的域名，有 url 则是第三方 API
@FeignClient(name = "weather-client", url = "http://t.weather.sojson.com")
public interface WeatherFeignClient {
    @GetMapping("/api/weather/city/{citycode}")
    String getWeather(@PathVariable("citycode") String citycode);
}
----

===== file -> service-order/src/test/java/com/tjise/serviceorder/WeatherTest.java
[source,java]
----
package com.tjise.serviceorder;

import com.tjise.serviceorder.client.WeatherFeignClient;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class WeatherTest {
    @Autowired
    private WeatherFeignClient weatherFeignClient;

    @Test
    void testGetWeather() {
        String weather = weatherFeignClient.getWeather("101030100");
        System.out.println("weather: "  + weather);
    }
}
----

==== 面试题: 客户端负载均衡与服务端负载均衡的区别是什么？
看下面的图就明白了

image::img/client_and_server_balanced.png[,700]

客户端自己决定负载均衡算法，如我们使用的 service-order 定义了负载均衡算法，则称为客户端负载均衡。

服务端自己决定负载均衡算法，如墨迹天气自动提供了负载均衡算法，则称为服务端负载均衡。

==== 日志功能
参考文档:
https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#feign-logging

.打开 feign 日志前
image::img/feign_before_open_log.png[]

.打开 feign 日志后
image::img/feign_after_open_log.png[]

下面是开启 Feign 日志的方法，开启后直接测试就行，不用启动任何微服务。

===== file -> service-order/src/main/resources/application.yml


====== logging
[source,yaml]
----
logging:
    level:
        com.tjise.serviceorder.client: debug
----

===== file -> service-order/src/main/java/com/tjise/serviceorder/config/FeignConfig.java
[source,java]
----
package com.tjise.serviceorder.config;

import feign.Logger;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FeignConfig {
    @Bean
    Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }
}
----

==== 超时控制
没有断路器也是能返回兜底数据的，只是没有断路器的 Close|Open|HalfOpen 功能。

.超时控制流程图
image::img/feign_timeout.png[,800]

超时分为：连接超时 和 读取超时。

.超时控制分类
image::img/feign_timeout_category.png[,800]

===== 测试默认 readTimeout 60s 超时（注意要关闭 feign 断路器功能）
下面先模拟查询商品微服务返回超时 readTimeout 大于 FeignClient 默认的 60s，设置为 100s，这样可以模拟出超时的效果来。

测试步骤：

. 启动 Eureka-server 注册中心
. 启动 service-item 微服务
. 启动 service-order 微服务

. 访问下面链接会在 60s 超时
* http :8091/order/201810300001
+
....
HTTP/1.1 500
Connection: close
Content-Type: application/json
Date: Tue, 07 Oct 2025 12:28:55 GMT
Transfer-Encoding: chunked

{
    "error": "Internal Server Error",
    "path": "/order/201810300001",
    "status": 500,
    "timestamp": "2025-10-07T12:28:55.156+00:00"
}
....
+
.微服务 service-order 显示 readTimeout
....
java.net.SocketTimeoutException: Read timed out -> 显示读取超时了
	at java.net.SocketInputStream.socketRead0(Native Method) ~[na:1.8.0_301]
	at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) ~[na:1.8.0_301]
	at java.net.SocketInputStream.read(SocketInputStream.java:171) ~[na:1.8.0_301]
	at java.net.SocketInputStream.read(SocketInputStream.java:141) ~[na:1.8.0_301]
	at java.io.BufferedInputStream.fill(BufferedInputStream.java:246) ~[na:1.8.0_301]
	at java.io.BufferedInputStream.read1(BufferedInputStream.java:286) ~[na:1.8.0_301]
	at java.io.BufferedInputStream.read(BufferedInputStream.java:345) ~[na:1.8.0_301]
	at sun.net.www.http.HttpClient.parseHTTPHeader(HttpClient.java:735) ~[na:1.8.0_301]
....

====== file -> service-item/src/main/java/com/tjise/serviceitem/service/ItemService.java


====== Item queryItemById -> 增加超时 100s 模拟
[source,java]
----
/**
 * 模拟实现商品查询
 *
 * @param id
 * @return
 */
public Item queryItemById(Long id) {

    // 模拟超时 100s 大于 FeignClient 默认的 60s 超时，可以实现 FeignClient readTimeout 效果。
    try {
        TimeUnit.SECONDS.sleep(100);  // 该语句会抛出受检异常，要么 try，要么向上抛出
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }

    return ITEM_MAP.get(id);
}
----

====== file -> service-order/src/main/resources/application.yml


====== feign 关闭断路器 -> 如果开启，Spring Cloud 设置了 5s 默认的慢超时
.注释 feign 的断路器功能才能测出来我们自定义的 readTimeout 60s
[source,yaml]
----
# feign:
  # circuitbreaker:
    # enabled: true
----

.参考知识
****
在 Resilience4JCircuitBreakerFactory 或 Resilience4JAutoConfiguration 类中，
Spring Cloud 会覆盖 Resilience4j 的默认配置，源码如下，请参考。

[source,java]
----
@Configuration
@ConditionalOnClass(CircuitBreaker.class)
public class Resilience4JAutoConfiguration {
    @Bean
    @ConditionalOnMissingBean
    public CircuitBreakerConfig circuitBreakerConfig() {
        return CircuitBreakerConfig.custom()
            // Spring Cloud 会设置更严格的默认值
            .slowCallDurationThreshold(Duration.ofSeconds(5))  // 这里设置为5秒
            .slowCallRateThreshold(100)
            .build();
    }
}
----
****

===== 配置 connectTimeout 和 readTimeout


====== file -> service-order/src/main/resources/application.yml


====== spring -> import application-feign.yml
[source, yaml]
----
spring:
    config:
        # -- New Added import application-feign.yml 文件 --
        import: application-feign.yml
    application:
        # 起个名字作为服务名称(该服务注册到 eureka 注册中心的名称，比如订单服务)
        name: app-order
    cloud:
        circuitbreaker:
            resilience4j:
                enabled: true
----

====== feign 开启断路器（测试时不用再关闭 feign 断路器功能）
connectTimeout & readTimeout 以配置为准，如 readTimeout 不再是 spring cloud 断路器的默认值 5s。
所以在测试时，是否开启该功能则没有影响了。

[source,yaml]
----
feign:
    circuitbreaker:
        enabled: true
----

====== file -> service-order/src/main/resources/application-feign.yml


====== spring -> 专门定义 openfeign 会被 application.yml 导入
[source, yaml]
----
feign:
    client:
        config:
            # 默认设置
            default:
                connectTimeout: 5000
                readTimeout: 5000

            # -- NOTE: feignName 写要调用的微服务名，会覆盖 default 默认设置 --
            app-item:  // feignName
                connectTimeout: 3000
                readTimeout: 2000
                # 优先级低于 config/FeignConfig.java 中的 Logger.Level
                # loggerLevel: full
----

==== 重试机制
远程调用超时失败后，还可以进行多次尝试。如果某次成功返回 ok，如果多次依然失败则结束调用，返回错误。

测试：
[source,console]
----
> http :8091/order/201810300001
HTTP/1.1 500
Connection: close
Content-Type: application/json
Date: Wed, 08 Oct 2025 02:40:29 GMT
Transfer-Encoding: chunked

{
    "error": "Internal Server Error",
    "path": "/order/201810300001",
    "status": 500,
    "timestamp": "2025-10-08T02:40:29.444+00:00"
}
----

.微服务 service-item 8081 打印尝试了 5 次
....
Processing request on port: 8081 for item ID: 1
Processing request on port: 8081 for item ID: 1
Processing request on port: 8081 for item ID: 1
Processing request on port: 8081 for item ID: 1
Processing request on port: 8081 for item ID: 1
....

===== 只是重试没有兜底返回（不能使用断路器）


.重试规则
****
https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#spring-cloud-feign-overriding-defaults

.spring 官网说 openfeign 默认没有开启重试机制
....
A bean of Retryer.NEVER_RETRY with the type Retryer is created by default, which will disable retrying. Notice this retrying behavior is different from the Feign default one, where it will automatically retry IOExceptions, treating them as transient network related exceptions, and any RetryableException thrown from an ErrorDecoder.
....

openfeign 的重试规则源码:
/Users/swot/maven/repository/io/github/openfeign/feign-core/11.10/feign-core-11.10.jar!/feign/Retryer.class

[source,java]
----
public static class Default implements Retryer {
    private final int maxAttempts;
    private final long period;
    private final long maxPeriod;
    int attempt;
    long sleptForMillis;

    public Default() {
        this(100L, TimeUnit.SECONDS.toMillis(1L), 5);
    }
----

这是 OpenFeign 的默认重试器实现，详细解释它的重试规则和延时机制：

.重试规则参数
[source,java]
----
public Default() {
    this(100L, TimeUnit.SECONDS.toMillis(1L), 5);
}
// 参数含义：period, maxPeriod, maxAttempts
----

**核心参数：**

- `period: 100L` - **基础延时100毫秒**
- `maxPeriod: 1000L` - **最大延时1000毫秒**（1秒）
- `maxAttempts: 5` - **最多重试5次**（包含初始请求）

延时机制

1. 指数退避策略（OpenFeign 使用 1.5倍指数退避 算法）

- 第1次重试：等待 100ms × 1.5⁰ = 100ms
- 第2次重试：等待 100ms × 1.5¹ = 150ms
- 第3次重试：等待 100ms × 1.5² = 225ms
- 第4次重试：等待 100ms × 1.5³ ≈ 338ms
- 第5次重试：等待 100ms × 1.5⁴ ≈ 506ms

2. **最大延时限制**
- 即使计算出的延时超过 `maxPeriod(1000ms)`，实际等待时间也不会超过1秒。

重试场景，这个重试器在以下情况会触发重试：

- HTTP连接超时
- 服务端返回5xx错误
- 网络IO异常等可重试的异常

.使用示例
....
// 如果服务调用失败，重试过程如下：
第1次请求 → 失败 → 等待100ms
第2次请求 → 失败 → 等待150ms
第3次请求 → 失败 → 等待225ms
第4次请求 → 失败 → 等待338ms
第5次请求 → 失败 → 停止重试，抛出异常
....

**注意事项**

- **总重试次数 = 初始请求 + 4次重试**
- **不适合所有场景**：对于非幂等操作（POST、PUT）要谨慎使用（容易多次提交数据！）
- 可以通过自定义 `Retryer` 实现来修改重试策略

这种**指数退避+最大限制**的策略既能给服务恢复时间，又避免了无限等待和雪崩效应。
****

====== file -> service-order/src/main/java/com/tjise/serviceorder/config/FeignConfig.java


====== Retryer retryer -> New Added 重试机制
[source,java]
----
@Bean
Retryer retryer() {
    return new Retryer.Default();
}
----

====== file -> service-order/src/main/resources/application.yml


====== spring -> import application-feign.yml
[source, yaml]
----
spring:
    config:
        # -- New Added import application-feign.yml 文件 --
        import: application-feign.yml
    application:
        # 起个名字作为服务名称(该服务注册到 eureka 注册中心的名称，比如订单服务)
        name: app-order
    cloud:
        circuitbreaker:
            resilience4j:
                enabled: true
----

====== feign 开启断路器（测试时需要关闭 feign 断路器功能）
[source,yaml]
----
# feign:
    # circuitbreaker:
        # enabled: true
----

===== spring Retry 重试加 fallback 兜底返回（未使用断路器）-- 理解


====== file -> service-order/pom.xml


====== retry
[source,scss]
....
<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
</dependency>
....

====== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java


====== class ServiceOrderApplication -> @EnableRetry
[source,java]
----
/**
 * 订单服务启动类，Spring Boot 应用程序入口点。
 */
@SpringBootApplication
@EnableEurekaClient  // 启用 Eureka 客户端功能
@EnableFeignClients  // 会初始化和配置 feign
@EnableRetry         // --- New Added --- 启用Spring Retry支持
public class ServiceOrderApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceOrderApplication.class, args);
    }
    // 包含其他代码
    @others
}
----

====== file -> service-order/src/main/java/com/tjise/serviceorder/service/ElegantRetryService.java


====== class ElegantRetryService
[source,java]
----
@Slf4j
@Service
public class ElegantRetryService {

    @Autowired
    private ItemFeignClient itemFeignClient;
    
    /**
     * 优雅的重试实现 - 使用Spring Retry注解
     * 策略：重试5次 -> 如果都失败 -> 返回降级结果
     */
    @Retryable(
        value = {RuntimeException.class},
        maxAttempts = 5,
        backoff = @Backoff(delay = 500)
    )
    public Item getItemWithElegantRetry(String itemId) {
        Long id = Long.parseLong(itemId);
        log.info("尝试调用商品服务，商品ID: {}", id);
        return itemFeignClient.queryItemById(id);
    }
    
    /**
     * 降级方法 - 当重试5次都失败时调用，是通过 @Recover 找到 fallbackItem 的
     */
    @Recover
    public Item fallbackItem(RuntimeException e, String itemId) {
        Long id = Long.parseLong(itemId);
        log.warn("重试5次后仍然失败，返回降级结果，异常: {}", e.getMessage());
        return new Item(id, "降级商品", null, "服务暂时不可用", 0L);
    }
}
----

====== file -> service-order/src/main/java/com/tjise/serviceorder/controller/ElegantRetryController.java


====== class ElegantRetryController
[source,java]
----
@Slf4j
@RestController
@RequestMapping("/elegant")
public class ElegantRetryController {

    @Autowired
    private ElegantRetryService elegantRetryService;

    /**
     * 测试优雅的重试机制
     * 策略：重试5次 -> 如果都失败 -> 返回降级结果
     */
    @GetMapping("/item/{id}")
    public Item getItemWithElegantRetry(@PathVariable String id) {
        log.info("开始调用优雅重试服务，商品ID: {}", id);
        Item result = elegantRetryService.getItemWithElegantRetry(id);
        log.info("最终结果: {}", result);
        return result;
    }
}
----

==== 请求和响应拦截器(只举了请求拦截器的例子)
image::img/feign_interceptor.png[,800]

测试发送
http -v :8091/elegant/item/1

.在 service-item 微服务打印 header 内容
....
header token = 1ea826d5-3c48-4e5b-890d-a00f59e8a92a
Processing request on port: 8081 for item ID: 1
....

===== file -> service-order/src/main/java/com/tjise/serviceorder/interceptor/XTokenRequestInterceptor.java
[source,java]
----
package com.tjise.serviceorder.interceptor;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import org.springframework.stereotype.Component;

import java.util.UUID;

@Component  // -- New Added -- 会自动应用 IOC 容器中的 RequestInterceptor 组件
public class XTokenRequestInterceptor implements RequestInterceptor {
    /**
     * 请求拦截器
     * @param requestTemplate 请求模板
     */
    @Override
    public void apply(RequestTemplate requestTemplate) {
        System.out.println("请求拦截器...");
//        requestTemplate.header("X-Token", "123456");
        requestTemplate.header("X-Token", UUID.randomUUID().toString());
    }
}
----

===== file -> service-item/src/main/java/com/tjise/serviceitem/service/ItemService.java


====== Item queryItemById -> 注释模拟超时代码
[source,java]
----
/**
 * 模拟实现商品查询
 *
 * @param id
 * @return
 */
public Item queryItemById(Long id) {

    // 模拟超时 100s 大于 FeignClient 默认的 60s 超时，可以实现 FeignClient readTimeout 效果。
    // try {
        // TimeUnit.SECONDS.sleep(100);
    // } catch (InterruptedException e) {
        // throw new RuntimeException(e);
    // }

    return ITEM_MAP.get(id);
}
----

===== file -> service-item/src/main/java/com/tjise/serviceitem/controller/ItemController.java


====== public class ItemController
[source,java]
----
@RestController
public class ItemController {

    @Autowired
    private ItemService itemService;
    
    @Value("${server.port}")
    private int serverPort;

    private static final Logger logger = Logger.getLogger(
                         ItemController.class.getName());
    /**
     * 对外提供接口服务，查询商品信息
     *
     * @param id
     * @return
     */
    @GetMapping(value = "item/{id}")
    public Item queryItemById(@PathVariable("id") Long id,
                              HttpServletRequest request  // -- New Added Start --
    ){
        String header = request.getHeader("X-Token");
        System.out.println("header token = " + header);
        // -- New Added End --

        // 增加了日志打印功能，方便查看是哪个 service-item 提供的服务。
        // logger.info("Handling request on port: " + serverPort + " for item ID: " + id);
        System.out.println("Processing request on port: " + serverPort + " for item ID: " + id);

        if (id == -1) {
            System.out.println("=== 触发异常测试，ID 为 -1 ===");
            throw new RuntimeException("服务内部错误");
        }
        return this.itemService.queryItemById(id);  // 正常返回
    }
}
----

==== 兜底返回 -> Feign with Sentinel fallback
image::img/feign_fallback.png[,800]

前面已经实现过了。参考「使用自带断路器 Feign（Feign 集成 SpringCloud 自带的断路器 Resilience4j，不需要在服务层手动管理断路器）」。


下面我们再看如何使用熔断框架 #Sentinel# 如何实现 Feign 的兜底返回。

.测试结果
....
> http :8091/order/201810300004
HTTP/1.1 200
Connection: keep-alive
Content-Type: application/json
Date: Fri, 10 Oct 2025 06:28:19 GMT
Keep-Alive: timeout=60
Transfer-Encoding: chunked

{
    "createDate": "2025-10-10T06:27:52.828+00:00",
    "orderDetails": [
        {
            "item": {
                "desc": null,
                "id": -1,
                "pic": null,
                "price": null,
                "title": "Feign 降级商品"
            },
            "orderId": "201810300004"
        }
    ],
    "orderId": "201810300004",
    "updateDate": "2025-10-10T06:27:52.826+00:00",
    "userId": 4
}
....

===== file -> service-order/pom.xml


====== Sentinel
[source,scss]
....
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
    <version>2021.0.5.0</version>
</dependency>
....

===== file -> service-order/src/main/resources/application.yml


====== spring -> 停用 spring cloud 集成的 resilience4j 断路器
[source, yaml]
----
spring:
    config:
        import: application-feign.yml
    application:
        # 起个名字作为服务名称(该服务注册到 eureka 注册中心的名称，比如订单服务)
        name: app-order
    cloud:
        # 使用 spring cloud 集成的 resilience4j
        circuitbreaker:
            resilience4j:
                enabled: false  # 要停用
        # sentinel:
            # transport:
                # dashboard: localhost:8858  # Sentinel 控制台地址
            # eager: true  # 立即初始化 Sentinel
----

====== feign 开启断路器 -> 测试时需要开启 sentinel 支持 feign 断路器功能
[source,yaml]
----
feign:
    # 直接使用 resilience4j
    # circuitbreaker:
        # enabled: true
    sentinel:
        enabled: true
----

== 10. 服务网关 Gateway


=== Gateway - 网关功能
image::img/gateway_overview.png[,800]

上图中展示的是 Spring Cloud Gateway 的功能，以下是每个功能的简短描述：

1. **统一入口**：所有外部请求通过单一网关进入系统，简化客户端访问。

2. **请求路由**：根据请求的URL、Header等信息，将请求转发到正确的服务。

3. **负载均衡**：在多个服务实例之间分配请求，提高系统的可用性和容错性。

4. **流量控制**：限制请求的流量，防止系统过载，保障服务的稳定性。

5. **身份认证**：验证请求的合法性，确保只有授权的用户可以访问服务。

6. **协议转换**：支持不同协议之间的转换，如HTTP到HTTPS，或HTTP1到HTTP2。

7. **系统监控**：监控网关的运行状态，收集请求的统计信息，便于性能分析。

8. **安全防护**：提供安全机制，如防止DDoS攻击，保护系统免受恶意攻击。

=== Gateway - 网关分类
[mermaid, target=img/mermaid-2025-10-12-170255, format=svg]
....
graph TD
    subgraph mvcGateway [Spring Cloud Gateway<br>Server MVC]
    end
    subgraph reactiveGateway [Spring Cloud Gateway<br>Reactive Server]
    end

    reactiveGateway -->|group:<br>org.springframework.cloud| reactive[artifactId:<br>spring-cloud-starter-gateway]
    mvcGateway -->|group:<br>org.springframework.cloud| mvc[artifactId:<br>spring-cloud-starter-gateway-mvc]
....

1. **Spring Cloud Gateway Reactive Server**:
   - 基于反应式编程模型，使用 Netty 服务器作为底层 HTTP 服务器。
   - 适用于需要高性能和高并发处理能力的场景。
   - 支持异步非阻塞 I/O 操作，可以更好地利用资源。

2. **Spring Cloud Gateway Server MVC**:
   - 基于传统的 Spring MVC 模型，使用 Tomcat 或 Jetty 作为底层 HTTP 服务器。
   - 更适合传统的 Spring 应用和需要同步处理的场景。
   - 易于与现有的 Spring MVC 应用集成。

两者都提供了路由、过滤器等功能，但底层实现和性能特点有所不同。
#推荐使用 Reactive Server。#

=== Gateway - 创建网关
如下图创建模块 gateway

image::img/gateway_create.png[,1000]

测试访问网关
http :8001/

.目前新创建的网关服务器没有路由，所以是 404
....
HTTP/1.1 404 Not Found
Content-Length: 129
Content-Type: application/json

{
    "error": "Not Found",
    "message": null,
    "path": "/",
    "requestId": "a1258588-1",
    "status": 404,
    "timestamp": "2025-10-20T06:35:17.417+00:00"
}
....

==== file -> gateway/pom.xml


===== project 从 service-item 复制过来的，增加 gateway 即可（注意模块名要改一下）
[source,scss]
....
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.18</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.tjise</groupId>
    <artifactId>gateway</artifactId>
    <version>1.0-SNAPSHOT</version>
    <name>gateway</name>
    <description>gateway</description>
    <properties>
        <java.version>1.8</java.version>
        <spring-cloud.version>2021.0.8</spring-cloud.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        @others
        <!-- 添加Spring Boot Test依赖 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- 添加Eureka客户端依赖，用于将服务注册到Eureka -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
....

====== gateway
如果使用了 Reactive Server，则需要改
spring-boot-starter-web 为
*spring-boot-starter-webflux*

[source,scss]
....
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
....

====== 更改为 Spring Boot WebFlux依赖 for Gateway
[source,scss]
....
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
....

====== 引入负载均衡 loadbalancer
[source,scss]
....
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
....

==== file -> gateway/src/main/resources/application.yml
****
name 和 instance 两者都有重要作用，缺一不可：

- spring.application.name：服务的逻辑名称，用于服务发现和负载均衡
- eureka.instance 配置：实例的网络地址，用于实际通信

即使使用 IP 注册，仍然需要服务名称来进行服务发现和调用。
****

===== port
[source,yaml]
----
### 服务端口号(本身是一个web项目)
server:
    port: 8001
----

===== name
[source,yaml]
----
### 起个名字作为服务名称(该服务注册到eureka注册中心的名称，比如商品服务)
spring:
    application:
        name: gateway
----

===== eureka
[source,yaml]
----
### 服务注册到 eureka 注册中心的地址
eureka:
    client:
        service-url:
            # defaultZone: http://root:root@127.0.0.1:8761/eureka/
            defaultZone: http://root:root@eureka1:8761/eureka/,http://root:root@eureka2:8762/eureka/,http://root:root@eureka3:8763/eureka/
        register-with-eureka: true # 因为该应用为服务提供者，是 eureka 的一个客户端，需要注册到注册中心
        fetch-registry: true       # 是否需要从 eureka 上检索服务

    instance:
        prefer-ip-address: true    # 使用IP地址注册而不是主机名
        ip-address: 127.0.0.1      # 客户端在注册时使用自己的IP，而不是主机名。
                                   # 这是生产环境的最佳实践，避免主机名解析问题。
----

==== file -> gateway/src/main/java/com/tjise/gateway/GatewayMainApplication.java
[source,java]
----
package com.tjise.gateway;


import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
public class GatewayMainApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayMainApplication.class, args);
    }
}
----

=== Gateway - 路由 - 规则配置
实现功能如下，客户端通过 gateway 向不同的服务（service-order 和 service-item）发送请求的流程。

[mermaid, target=img/mermaid-2025-10-12-183606, format=svg]
....
graph LR
    A[浏览器] --> B[gateway]
    B -->|/api/order/**  | C[service-order]
    B -->|/api/item/**| D[service-item]
....


测试：
http :8001/api/order/201810300001

==== file -> gateway/src/main/resources/application-route.yml


===== spring
[source,yaml]
....
spring:
  cloud:
    gateway:
      routes:
        - id: order-route      # 自已定义的id，全局不能重复
          uri: lb://app-order  # 注册的服务名; lb 指负载均衡
          predicates:
            - Path=/api/order/**  # 将前端路由 redirect 到 app-order 微服务

        - id: item-route      # 自已定义的id，全局不能重复
          uri: lb://app-item  # 注册的服务名; lb 指负载均衡
          predicates:
            - Path=/api/item/**  # 将前端路由 redirect 到 app-item 微服务
....

==== file -> gateway/src/main/resources/application.yml
****
name 和 instance 两者都有重要作用，缺一不可：

- spring.application.name：服务的逻辑名称，用于服务发现和负载均衡
- eureka.instance 配置：实例的网络地址，用于实际通信

即使使用 IP 注册，仍然需要服务名称来进行服务发现和调用。
****

===== include -- New Added --
[source,yaml]
----
### 起个名字作为服务名称(该服务注册到eureka注册中心的名称，比如商品服务)
spring:
    application:
        name: gateway
    # -- New Added --
    profiles:
        include: route
----

==== file -> service-order/src/main/java/com/tjise/serviceorder/controller/OrderController.java


===== class OrderController -- New Added -- @RequestMapping("/api/order")
[source,java]
----
/**
 * 订单控制器
 * 处理订单相关的HTTP请求
 */
@RequestMapping("/api")  // -- New Added --
@RestController
public class OrderController {

    // 注入订单服务
    @Autowired
    private OrderService orderService;

    /**
     * 根据订单ID查询订单信息
     *
     * @param orderId 订单ID
     * @return Order 订单信息
     */
    @GetMapping(value = "order/{orderId}")
    public Order queryOrderById(@PathVariable("orderId") String orderId) throws IOException {
        return orderService.queryOrderById(orderId);
    }
}
----

==== file -> service-item/src/main/java/com/tjise/serviceitem/controller/ItemController.java


===== public class ItemController -- New Added -- @RequestMapping("/api/item")
[source,java]
----
@RequestMapping("/api")  // -- New Added --
@RestController
public class ItemController {

    @Autowired
    private ItemService itemService;
    
    @Value("${server.port}")
    private int serverPort;

    private static final Logger logger = Logger.getLogger(
                         ItemController.class.getName());
    /**
     * 对外提供接口服务，查询商品信息
     *
     * @param id
     * @return
     */
    @GetMapping(value = "item/{id}")
    public Item queryItemById(@PathVariable("id") Long id,
                              HttpServletRequest request  // -- New Added Start --
    ){
        String header = request.getHeader("X-Token");
        System.out.println("header token = " + header);
        // -- New Added End --

        // 增加了日志打印功能，方便查看是哪个 service-item 提供的服务。
        // logger.info("Handling request on port: " + serverPort + " for item ID: " + id);
        System.out.println("Processing request on port: " + serverPort + " for item ID: " + id);

        if (id == -1) {
            System.out.println("=== 触发异常测试，ID 为 -1 ===");
            throw new RuntimeException("服务内部错误");
        }
        return this.itemService.queryItemById(id);  // 正常返回
    }
}
----

==== file -> service-order/src/main/java/com/tjise/serviceorder/client/ItemFeignClient.java
[source,java]
----
package com.tjise.serviceorder.client;

import com.tjise.serviceorder.pojo.Item;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

// 要访问的在 Eureka 中的服务名，并指定实现该接口的降级类名
@FeignClient(name = "app-item", fallback = ItemFallback.class)
public interface ItemFeignClient {
    @GetMapping("/api/item/{id}")  // -- New Added -- /api
    Item queryItemById(@PathVariable("id") Long id);
}
----

=== Gateway - 路由 - 工作原理
[mermaid, target=img/mermaid-2025-10-12-221421, format=svg]
....
flowchart TD
    A[前端请求] -->|进入| B[Spring Cloud Gateway]
    B --> C[Route路由规则按序匹配]
    C -->|匹配| D[Gateway HandlerMapping]
    D --> E[Gateway WebHandler]
    E -->|转发| F[Filter链]
    F --> G[目的地]
    G -->|响应| F
    F -->|返回| E
    E -->|处理完成| B
    B -->|离开| H[响应前端]

    subgraph SpringCloudGatewayInternal[In Spring Cloud Gateway]
        D
        E
        F
        G
    end

    classDef internal fill:#f9f,stroke:#333,stroke-width:2px;
    class SpringCloudGatewayInternal internal;

    style A fill:#ffcccb,stroke:#333,stroke-width:2px;  // Light Pink
    style B fill:#add8e6,stroke:#333,stroke-width:2px;  // Light Blue
    style C fill:#ffff99,stroke:#333,stroke-width:2px;  // Light Yellow
    style D fill:#d3d3e2,stroke:#333,stroke-width:2px;  // Light Purple
    style E fill:#c0ffc0,stroke:#333,stroke-width:2px;  // Light Green
    style F fill:#ffcc80,stroke:#333,stroke-width:2px;  // Light Orange
    style G fill:#ffccff,stroke:#333,stroke-width:2px;  // Light Magenta
    style H fill:#e0ffff,stroke:#333,stroke-width:2px;  // Light Cyan

    linkStyle 0 stroke:#333,stroke-width:2px,stroke-dasharray:5,fill:none;
    linkStyle 1 stroke:#333,stroke-width:2px,stroke-dasharray:5,fill:none;
    linkStyle 2 stroke:#333,stroke-width:2px,stroke-dasharray:5,fill:none;
    linkStyle 3 stroke:#333,stroke-width:2px,stroke-dasharray:5,fill:none;
    linkStyle 4 stroke:#333,stroke-width:2px,stroke-dasharray:5,fill:none;
    linkStyle 5 stroke:#333,stroke-width:2px,stroke-dasharray:5,fill:none;
    linkStyle 6 stroke:#333,stroke-width:2px,stroke-dasharray:5,fill:none;
    linkStyle 7 stroke:#333,stroke-width:2px,stroke-dasharray:5,fill:none;
    linkStyle 8 stroke:#333,stroke-width:2px,stroke-dasharray:5,fill:none;
    linkStyle 9 stroke:#333,stroke-width:2px,stroke-dasharray:5,fill:none;
....

下面举例兜底路由，可展示 Route 路由规则按序匹配。

==== file -> gateway/src/main/resources/application-route.yml


===== spring 兜底路由 - Path=/**
[source,yaml]
....
spring:
  cloud:
    gateway:
      routes:
        - id: order-route
          uri: lb://app-order
          # -- 短写法 --
          predicates:
            - Path=/api/order/**
          # -- 短写法结束 --
          order: 1

        - id: item-route
          uri: lb://app-item
          predicates:
            - Path=/api/item/**
          order: 2

        # 兜底路由  --New Added--
        - id: bing-route  # 自己定义的id
          uri: https://cn.bing.com/
          predicates:
            - Path=/**
          order: 3
....

order: 控制路由的匹配顺序。默认是从上到下的顺序。

=== Gateway - 断言 - 长短写法（短写法见上例）
1. 文档查看断言类型:
https://docs.spring.io/spring-cloud-gateway/docs/3.1.9/reference/html/#gateway-request-predicates-factories
+
image::img/gateway_predicate_category_0.png[]


2. 在 IDEA 中查看断言类型:
Shift Shift -> classs -> routePredicateFactory 打开是个接口
+
如下图去掉 RoutePredicateFactory 剩下的就是断言的名字，比如 Path
+
image::img/gateway_predicate_category.png[]

3. 断言类型解释
+
image::img/gateway_predicate_category_1.png[]


测试：
http :8001/api/order/201810300001

==== file -> gateway/src/main/resources/application-route.yml


===== spring 长写法 - name args
长短写法文档:
https://cloud.spring.io/spring-cloud-gateway/reference/html/#fully-expanded-arguments

[source,yaml]
....
spring:
  cloud:
    gateway:
      routes:  # IDEA中点击可以查看属性定义
        - id: order-route
          uri: lb://app-order
          # -- 断言长写法 --
          predicates:  # IDEA 中按 Shift Shift -> classes -> PredicateDefinition 可发现 name & args
            - name: Path
              args:  # IDEA 中按 Shift Shift -> classes -> PathRoutePredicateFactory 可发现定义了下面两个属性
                patterns: /api/order/**
                matchTrailingSlash: true  # 默认 true，是否匹配最后的 /
          # -- 断言长写法结束 --
          order: 1

        - id: item-route
          uri: lb://app-item
          predicates:
            - Path=/api/item/**
          order: 2

        # 兜底路由
        - id: bing-route
          uri: https://cn.bing.com/
          predicates:
            - Path=/**
          order: 3
....

order: 控制路由的匹配顺序。默认是从上到下的顺序。

=== Gateway - 断言 - Query
测试可以放行到:
http :8001/search?q=haha

其它的则不通，会报 404:
http :8001/search?q=wowo

NOTE: 用浏览器则可以看到网页的渲染内容。

==== file -> gateway/src/main/resources/application-route.yml


===== Query 请求参数
# 兜底路由
- id: bing-route
  uri: https://cn.bing.com/
  predicates:  # <1> 
    - name: Path
      args:
        patterns: /search
    - name: Query
      args:  # # IDEA 中按 Shift Shift -> classes -> QueryRoutePredicateFactory 可发现定义了下面两个属性
        param: q
        regexp: haha
  order: 3

<1> 所有的断言都匹配才能放行。

=== Gateway - 断言 - 自定义断言工厂（高级）
本课件忽略！可以参考该视频去实现:
https://www.bilibili.com/video/BV1UJc2ezEFU?spm_id_from=333.788.player.switch&vd_source=392e2829ea8e40de989be86888026747&p=57

=== Gateway - 过滤器 - 基本使用 RewritePath & AddResponseHeader
过滤器工厂名
https://cloud.spring.io/spring-cloud-gateway/reference/html/#gatewayfilter-factories

image::img/gateway_filter_1.png[,800]

常用的过滤器工厂 rewritepath
https://cloud.spring.io/spring-cloud-gateway/reference/html/#the-rewritepath-gatewayfilter-factory

因为前面我们在网关的配置中都加了 /api，
这样在每个微服务中都需要加 /api，如果微服务多了，就会冗余，且很麻烦，
下面我们使用过滤器来简化该操作。更改后，再测试如下：

.测试能正常返回订单数据且有新添加的响应头: AddResponseHeader 的作用
....
http :8001/api/order/201810300001
HTTP/1.1 200 OK
Content-Type: application/json
Date: Tue, 14 Oct 2025 07:51:58 GMT
X-Response-Red: Blue  ### -- 有了新添加的响应关
transfer-encoding: chunked

{
    "createDate": "2025-10-14T06:11:43.104+00:00",
    "orderDetails": [
        {
            "item": {
                "desc": "商品描述1",
                "id": 1,
                "pic": "http://图片1",
                "price": 1000,
                "title": "商品1"
            },
            "orderId": "201810300001"
        },
        {
            "item": {
                "desc": "商品描述2",
                "id": 2,
                "pic": "http://图片2",
                "price": 2000,
                "title": "商品2"
            },
            "orderId": "201810300001"
        }
    ],
    "orderId": "201810300001",
    "updateDate": "2025-10-14T06:11:43.104+00:00",
    "userId": 1
}
....

==== file -> gateway/src/main/resources/application.yml
****
name 和 instance 两者都有重要作用，缺一不可：

- spring.application.name：服务的逻辑名称，用于服务发现和负载均衡
- eureka.instance 配置：实例的网络地址，用于实际通信

即使使用 IP 注册，仍然需要服务名称来进行服务发现和调用。
****

===== logging --New Added-- 为了调试增加日志
[source,yaml]
----
logging:
  level:
    org.springframework.cloud.gateway: DEBUG
    org.springframework.cloud.gateway.route: TRACE
    org.springframework.cloud.gateway.handler: DEBUG
    reactor.netty.http.client: DEBUG
    reactor.netty.http.server: DEBUG
----

==== file -> gateway/src/main/resources/application-route.yml


===== spring
[source,yaml]
....
spring:
  cloud:
    gateway:
      routes:
        - id: order-route
          uri: lb://app-order
          # -- 长写法 --
          predicates:
            - name: Path
              args:
                patterns: /api/order/**
          # -- 长写法结束 --
          order: 1

          # --New Added Start--
          filters:  # /api/a/b -> /a/b  <1>
            - RewritePath=/api/(?<segment>.*), /$\{segment}
            - AddResponseHeader=X-Response-Red, Blue
          # --New Added End--

        - id: item-route
          uri: lb://app-item
          predicates:
            - Path=/api/item/**
          order: 2
          filters:  # 同上
            - RewritePath=/api/(?<segment>.*), /$\{segment}
        @others
....

order: 控制路由的匹配顺序。默认是从上到下的顺序。

<1> filter 中 RewritePath 的作用是将请求路径进行重写。具体来说，它将 /api/ 开头的路径重写为去掉 /api/ 前缀后的路径。
+
* /api/?：匹配以 /api/ 开头的路径，? 表示 / 是可选的。
* (?<segment>.*)：这是一个捕获组，捕获 /api/ 之后的所有内容，命名为 segment。
* , /$\{segment}：这是替换后的路径，/$\{segment} 表示将捕获的 segment 替换到新的路径中。
* 假设请求路径为 /api/a/b，RewritePath 会将其重写为 /a/b。

==== file -> service-order/src/main/java/com/tjise/serviceorder/controller/OrderController.java


===== class OrderController -- New Added-- 注释 @RequestMapping("/api")
[source,java]
----
/**
 * 订单控制器
 * 处理订单相关的HTTP请求
 */
// @RequestMapping("/api")  // -- 不要了
@RestController
public class OrderController {

    // 注入订单服务
    @Autowired
    private OrderService orderService;

    /**
     * 根据订单ID查询订单信息
     *
     * @param orderId 订单ID
     * @return Order 订单信息
     */
    @GetMapping(value = "/order/{orderId}")
    public Order queryOrderById(@PathVariable("orderId") String orderId) throws IOException {
        return orderService.queryOrderById(orderId);
    }
}
----

==== file -> service-item/src/main/java/com/tjise/serviceitem/controller/ItemController.java


===== public class ItemController --New Added-- 注释 @RequestMapping("/api")
[source,java]
----
// @RequestMapping("/api")  // 不要了
@RestController
public class ItemController {

    @Autowired
    private ItemService itemService;
    
    @Value("${server.port}")
    private int serverPort;

    private static final Logger logger = Logger.getLogger(
                         ItemController.class.getName());
    /**
     * 对外提供接口服务，查询商品信息
     *
     * @param id
     * @return
     */
    @GetMapping(value = "/item/{id}")
    public Item queryItemById(@PathVariable("id") Long id,
                              HttpServletRequest request
    ){
        String header = request.getHeader("X-Token");
        System.out.println("header token = " + header);
        // -- New Added End --

        // 增加了日志打印功能，方便查看是哪个 service-item 提供的服务。
        // logger.info("Handling request on port: " + serverPort + " for item ID: " + id);
        System.out.println("Processing request on port: " + serverPort + " for item ID: " + id);

        if (id == -1) {
            System.out.println("=== 触发异常测试，ID 为 -1 ===");
            throw new RuntimeException("服务内部错误");
        }
        return this.itemService.queryItemById(id);  // 正常返回
    }
}
----

==== file -> service-order/src/main/java/com/tjise/serviceorder/client/ItemFeignClient.java
[source,java]
----
package com.tjise.serviceorder.client;

import com.tjise.serviceorder.pojo.Item;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

// 要访问的在 Eureka 中的服务名，并指定实现该接口的降级类名
@FeignClient(name = "app-item", fallback = ItemFallback.class)
public interface ItemFeignClient {
    // @GetMapping("/api/item/{id}")  // 不要了
    @GetMapping("/item/{id}")
    Item queryItemById(@PathVariable("id") Long id);
}
----

=== Gateway - 过滤器 - 默认filter -> default-filters
测试结果中增加了 X-Response-Default-Red: Default-Blue
....
http :8001/api/order/201810300001
HTTP/1.1 200 OK
Content-Type: application/json
Date: Tue, 14 Oct 2025 09:36:07 GMT
X-Response-Default-Red: Default-Blue  --New Added--
X-Response-Red: Blue
transfer-encoding: chunked

{
    "createDate": "2025-10-14T09:24:39.056+00:00",
    "orderDetails": [
        {
            "item": {
                "desc": "商品描述1",
                "id": 1,
                "pic": "http://图片1",
                "price": 1000,
                "title": "商品1"
            },
            "orderId": "201810300001"
        },
        {
            "item": {
                "desc": "商品描述2",
                "id": 2,
                "pic": "http://图片2",
                "price": 2000,
                "title": "商品2"
            },
            "orderId": "201810300001"
        }
    ],
    "orderId": "201810300001",
    "updateDate": "2025-10-14T09:24:39.056+00:00",
    "userId": 1
}
....

==== file -> gateway/src/main/resources/application-route.yml


===== spring
[source,yaml]
....
spring:
  cloud:
    gateway:

      # --New Added Start--
      default-filters:
        - AddResponseHeader=X-Response-Default-Red, Default-Blue
      # --New Added End--

      routes:
        - id: order-route
          uri: lb://app-order
          # -- 长写法 --
          predicates:
            - name: Path
              args:
                patterns: /api/order/**
          # -- 长写法结束 --
          order: 1
          filters:  # /api/a/b -> /a/b  <1>
            - RewritePath=/api/(?<segment>.*), /$\{segment}
            - AddResponseHeader=X-Response-Red, Blue

        - id: item-route
          uri: lb://app-item
          predicates:
            - Path=/api/item/**
          order: 2
          filters:  # 同上
            - RewritePath=/api/(?<segment>.*), /$\{segment}
        @others
....

order: 控制路由的匹配顺序。默认是从上到下的顺序。

<1> filter 中 RewritePath 的作用是将请求路径进行重写。具体来说，它将 /api/ 开头的路径重写为去掉 /api/ 前缀后的路径。
+
* /api/?：匹配以 /api/ 开头的路径，? 表示 / 是可选的。
* (?<segment>.*)：这是一个捕获组，捕获 /api/ 之后的所有内容，命名为 segment。
* , /$\{segment}：这是替换后的路径，/$\{segment} 表示将捕获的 segment 替换到新的路径中。
* 假设请求路径为 /api/a/b，RewritePath 会将其重写为 /a/b。

=== Gateway - 过滤器 - GlobalFilter
spring cloud gateway GlobalFilter 与 default-filters 的使用区别。

* 认证/鉴权、全局日志、全局限流 这类所有请求都必须经过的逻辑，使用 GlobalFilter。

* 修改特定路由的请求/响应（如添加特定头、重写路径）、为特定路由设置限流 这类与业务路由紧密相关的逻辑，使用 default-filters 在配置文件中声明，使得路由配置更加清晰和易于管理。

官网文档:
https://cloud.spring.io/spring-cloud-gateway/reference/html/#global-filters

我们来做一个功能，计算一个请求响应的时间。

做好后测试:
http :8001/api/order/201810300001

.gateway 服务端打印测试结果
....
2025-10-15 11:53:07.163  INFO 79701 --- [ctor-http-nio-3] c.t.g.filter.ResponseTimeGlobalFilter    : 请求『http://localhost:8001/api/order/201810300001』开始：时间：1760500387163
2025-10-15 11:53:07.169 DEBUG 79701 --- [ctor-http-nio-3] r.netty.http.client.HttpClientConnect    : [f5090559-1, L:/127.0.0.1:63650 - R:/127.0.0.1:8091] Handler is being applied: {uri=http://127.0.0.1:8091/order/201810300001, method=GET}
2025-10-15 11:53:07.184 DEBUG 79701 --- [ctor-http-nio-3] r.n.http.client.HttpClientOperations     : [f5090559-1, L:/127.0.0.1:63650 - R:/127.0.0.1:8091] Received response (auto-read:false) : RESPONSE(decodeResult: success, version: HTTP/1.1)
HTTP/1.1 200 
Content-Type: <filtered>
Transfer-Encoding: <filtered>
Date: <filtered>
2025-10-15 11:53:07.184  INFO 79701 --- [ctor-http-nio-3] c.t.g.filter.ResponseTimeGlobalFilter    : 请求『http://localhost:8001/api/order/201810300001』结束：时间：1760500387184，耗时：21ms
....

==== file -> gateway/src/main/java/com/tjise/gateway/filter/ResponseTimeGlobalFilter.java
[source,java]
----
package com.tjise.gateway.filter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

// 全局 filter 只需要放在 IOC Bean 容器中即可，不用再注入。
@Component
@Slf4j
public class ResponseTimeGlobalFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        ServerHttpResponse response = exchange.getResponse();
        String uri = request.getURI().toString();

        long start= System.currentTimeMillis();
        log.info("请求『{}』开始：时间：{}", uri, start);

        // 放行请求并记录响应所花费的时间
        Mono<Void> filter = chain.filter(exchange)   // 放行请求
                .doFinally((result)->{               // 响应式编程的异步链式调用
                    long end = System.currentTimeMillis();
                    log.info("请求『{}』结束：时间：{}，耗时：{}ms", uri, end, end-start);
                });
        return filter;
    }

    @Override
    public int getOrder() {
        return 0;  // 数字越小，优先级越高
    }
}
----

=== Gateway - 过滤器 - 自定义过滤器工厂（高级）
本课件忽略！可以参考该视频去实现:
https://www.bilibili.com/video/BV1UJc2ezEFU?spm_id_from=333.788.videopod.episodes&vd_source=392e2829ea8e40de989be86888026747&p=61

=== Gateway - 扩展 - 全局跨域
https://cloud.spring.io/spring-cloud-gateway/reference/html/#cors-configuration

支持所有的微服务允许前端浏览器跨域。这样就不用在每个微服务中设置跨域了。


.浏览器在跨域时会发送预检请求，httpie 测试发送预检的正确返回
....
http OPTIONS http://localhost:8001/api/order/201810300001 \
  Origin:http://localhost:3000 \
  Access-Control-Request-Method:GET \
  Cookie:"sessionid=abc123"

HTTP/1.1 200 OK
Access-Control-Allow-Credentials: true
Access-Control-Allow-Methods: GET
Access-Control-Allow-Origin: http://localhost:3000
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
content-length: 0
....

下面是实现全局跨域需要更改的配置。

==== file -> gateway/src/main/resources/application-route.yml


===== spring
[source,yaml]
....
spring:
  cloud:
    gateway:
      # 全局跨域
      globalcors:
        cors-configurations:
          '[/**]':
            allowed-origin-patterns:
              - "http://*"              # 所有 HTTP 域名
              - "https://*"             # 所有 HTTPS 域名
              - "http://localhost:*"    # 本地开发环境
              - "http://127.0.0.1:*"    # 本地 IP
              - "http://*.example.com"  # 子域名匹配
            allow-credentials: true
            allowed-methods: "*"
            allowed-headers: "*"
      @others
....

==== 跨域常见问题
[qanda]
我知道在浏览器中使用 ajax 访问后端服务的 api 有跨域问题，想问在浏览器的地址栏直接输入后端的 api 会有跨域问题吗？::

答：没有跨域问题。
浏览器的“跨域限制”（即同源策略 + CORS 校验）只在前端脚本（JavaScript）发起网络请求时才会触发，
比如通过 XMLHttpRequest、fetch()、axios 等方式发起的请求。

=== Gateway - 面试题
[qanda]
微服务之间的调用经过网关吗？::

答：不需要经过网关 Gateway，因为网关是对接前端的，没有必要。
直接从 Eureka 注册中心发现服务进行调用就可以了。

== 11. 配置中心 Config
下面文档详细记录了 Spring Cloud Config 配置中心的完整搭建、配置和测试过程，包括 config-server 和 service-order 模块的集成。

=== 11.1 创建配置服务器
如下图创建模块 config-server

image::img/config-server_create.png[,1000]

测试访问网关
http :8888/

==== file -> config-server/pom.xml


===== config-server
[source,scss]
....
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-config-server</artifactId>
</dependency>
....

===== Actuator
[source,scss]
....
<!-- Spring Boot Actuator for monitoring and management -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
....

==== file -> config-server/src/main/java/com/tjise/serviceconfig/ConfigServerApplication.java
[source,java]
----
package com.tjise.serviceconfig;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@SpringBootApplication
@EnableConfigServer  // --New Added--
public class ConfigServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}
----

==== file -> config-server/src/main/resources/application.yml
[source,yaml]
----
server:
  port: 8888

spring:
  application:
    name: config-server
  profiles:
    active: native  # 启用本地模式，使配置服务器使用本地文件系统而不是Git仓库
  cloud:
    config:
      enabled: false  # 该配置中心本身不需要连接到其他配置中心
      server:
        native:       # 指定本地配置文件的位置
          search-locations: classpath:/config-repo
        # 启用健康检查端点
        health:
          enabled: true
    # 禁用配置客户端检查（config-server本身是配置服务器，不需要从其他配置中心获取配置）
    import-check:
      enabled: false

# 配置 Actuator 端点
management:
  endpoints:
    web:
      exposure:
        include: health,info,configprops  # 用于指定要暴露的端点
  endpoint:  # 用于配置特定端点的行为
    health:
      show-details: always
----

==== file -> config-server/src/main/resources/config-repo/application.yml
为所有微服务提供全局共享的默认配置。
任何微服务如果没有特定配置，都会继承这些设置。

[source,yaml]
----
spring:
  datasource:
    type: com.zaxxer.hikari.HikariDataSource
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000

  jpa:
    properties:
      hibernate:
        dialect: org.hibernate.dialect.H2Dialect
        format_sql: true
        use_sql_comments: true

logging:
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %logger{36} - %msg%n"
  level:
    root: INFO

# 应用通用配置
app:
  company: TJISE
  environment: ${spring.profiles.active:default}
  support-email: support@tjise.com

demo:
  config-server-url: http://localhost:8888
  refresh-endpoint: /actuator/refresh
  config-endpoint: /{application}/{profile}
----

==== file -> config-server/src/main/resources/config-repo/app-order.yml
针对名为 "app-order" 特定微服务的配置文件，会覆盖全局配置中的同名属性。

config-server/src/main/resources/config-repo/application.yml

config-server/src/main/resources/config-repo/app-order.yml

两者关系：

1. 继承关系：如果 "app-order" 微服务没有在 app-order.yml 中定义的配置项，会从 application.yml 中继承
2. 覆盖关系：app-order.yml 中的配置会覆盖 application.yml 中的相同配置项
3. 优先级：特定应用配置文件的优先级高于全局配置文件

例如，在 app-order.yml 中定义了 server.port: 8092，如果 application.yml 也有端口配置，app-order.yml 中的配置会生效。

这是 Spring Cloud Config 的标准行为，允许您定义全局共享配置和特定应用配置，实现配置的分层管理。

[source,yaml]
----
# app-order 默认配置
server:
  port: 8091

spring:
  application:
    name: app-order
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password: password
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true

# 应用业务配置
app:
  name: 订单服务
  version: 1.0.0
  description: 这是一个订单微服务示例
  features:
    - 订单创建
    - 订单查询
    - 订单状态更新
  limits:
    max-order-items: 10
    timeout-seconds: 30

demo:
  enabled: true
  message: "欢迎使用 Spring Cloud Config 配置中心！"
  retry-count: 3
  cache-enabled: true
----

==== file -> config-server/src/main/resources/config-repo/app-order-dev.yml
service-order 开发环境配置文件，当服务以 dev 环境启动时，app-order-dev.yml 会覆盖 app-order.yml 中相同配置项。

[source,yaml]
----
server:
  port: 8092

spring:
  application:
    name: app-order
  datasource:
    url: jdbc:h2:mem:devdb
    driver-class-name: org.h2.Driver
    username: dev_user
    password: dev123
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true

# 应用业务配置 - 开发环境
app:
  name: 订单服务 (开发环境)
  version: 1.1.0-dev
  description: 这是一个订单微服务示例 - 开发环境，包含新功能测试"
  features:
    - 订单创建
    - 订单查询
    - 订单状态更新
    - 调试模式
    - 新功能测试
  limits:
    max-order-items: 3
    timeout-seconds: 120

# 演示配置 - 开发环境
demo:
  enabled: true
  message: "开发环境：正在测试新功能，请谨慎使用！"
  retry-count: 10
  cache-enabled: false
  debug-mode: true
  branch: dev

# 开发环境特定配置
logging:
  level:
    com.tjise.serviceorder: TRACE
    org.springframework.web: DEBUG
    org.hibernate.SQL: DEBUG

# 动态配置测试 - 断路器故障率阈值
resilience4j:
  circuitbreaker:
    configs:
      default:
        failure-rate-threshold: 50
----

==== file -> config-server/src/main/resources/config-repo/app-order-prod.yml
service-order 生产环境配置文件，该配置只是演示，没有实际配置生效。

[source,yaml]
----
server:
  port: 8093

spring:
  application:
    name: service-order
  datasource:
    url: jdbc:mysql://localhost:3306/order_db
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: prod_user
    password: ${DB_PASSWORD:secret}
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false

# 自定义配置示例 - 生产环境
app:
  name: 订单服务 (生产环境)
  version: 1.0.0
  description: 这是一个订单微服务示例 - 生产环境
  features:
    - 订单创建
    - 订单查询
    - 订单状态更新
  limits:
    max-order-items: 50
    timeout-seconds: 10

# 演示配置 - 生产环境
demo:
  enabled: false
  message: "生产环境：系统运行中"
  retry-count: 2
  cache-enabled: true
  debug-mode: false

# 生产环境特定配置
logging:
  level:
    com.tjise.serviceorder: INFO
    org.springframework.web: WARN

# 监控配置
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,info
  endpoint:
    health:
      show-details: when_authorized
----

=== 11.2 在客户端使用配置中心数据（以 service-order）


==== file -> service-order/pom.xml


===== config
[source,scss]
....
<!-- Spring Cloud Config Client -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-config</artifactId>
</dependency>
....

===== actuator
[source,scss]
....
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
....

==== file -> service-order/src/main/resources/application.yml


===== spring -> 连接 config-server
[source, yaml]
----
spring:
    config:
        # --New Added--
        import: configserver:http://localhost:8888,application-feign.yml
    application:

        # 起个名字作为服务名称(该服务注册到 eureka 注册中心的名称，比如订单服务)
        name: app-order

    cloud:
        # --New Added Start--
        config:
            name: app-order    # 配置文件名
            profile: dev       # 环境配置
        # --New Added End--

        # 使用 spring cloud 集成的 resilience4j
        circuitbreaker:
            resilience4j:
                enabled: false  # --要停用--

        # 不使用节流等功能，可以不用开启
        # sentinel:
            # transport:
                # dashboard: localhost:8858  # Sentinel 控制台地址
            # eager: true  # 立即初始化 Sentinel
----

===== management -> 增加 refresh,env
[source,yaml]
----
management:
    endpoints:
        web:
            exposure:  # 暴露断路器事件端点
                include: health,info,circuitbreakerevents,refresh,env
    endpoint:
        health:
            show-details: always
    health:
        circuitbreakers:
            enabled: true  # 启用断路器健康检查
----

=== 11.3 测试配置中心


==== 检查 Config-Server 服务器状态
[source, console]
----
http 'http://localhost:8888/actuator/health' | jq .status
# 输出: "UP"

http http://localhost:8888/app-order/dev | jq '.propertySources[0].source."server.port"'
# 输出: 8092
----

==== 检查 Service-Order 状态
[source, console]
----
http http://localhost:8092/actuator/health | jq .status
# 输出: "UP"

http http://localhost:8092/actuator/env/resilience4j.circuitbreaker.configs.default.failure-rate-threshold | jq .property.value
# 检查是否有配置更新，输出: null，因为当前没有更新配置。
----

==== 测试动态配置的更新 failure-rate-threshold: 50 to 75
1. 先更改下面 yml 的配置，再进行测试。

2. 触发配置刷新
.. 由于使用 `native` 模式，需要重启 config-server 来加载新配置。
+
[source,console]
----
http POST http://localhost:8092/actuator/refresh
# 8092 是配置中心给的端口号
----

3. 验证配置更新
+
[source,console]
----
http GET http://localhost:8092/actuator/env/resilience4j.circuitbreaker.configs.default.failure-rate-threshold | jq '.property.value'
----

===== file -> config-server/src/main/resources/config-repo/app-order-dev.yml


====== resilience4j
[source,yaml]
----
# 动态配置测试 - 断路器故障率阈值
resilience4j:
  circuitbreaker:
    configs:
      default:
        # failure-rate-threshold: 50
        failure-rate-threshold: 75  # 改数字为了测试
----

=== 11.4 配置优先级说明
. 配置源优先级
+
[source]
----
高优先级 -> 低优先级
远程配置 (config-server) > 本地配置 (application.yml) > 默认配置
----

. 可动态更新的配置类型
* ✅ **支持动态更新**（无需重启服务）：
- 业务逻辑配置
- 日志级别配置
- 功能开关配置
- 超时时间配置
- Resilience4j 断路器配置
* ❌ **需要重启服务**：
- 服务器端口 (`server.port`)
- 数据库连接配置
- 网络相关配置
- 任何影响应用启动行为的配置

. 配置模式对比

[cols="1,1,1,2", options="header"]
|===
| 模式 | 自动检测 | 需要重启 | 适用场景
| `native` | ❌ | ✅ | 开发环境、简单演示
| `git` | ✅ | ❌ | 生产环境、团队协作
| `vault` | ✅ | ❌ | 安全敏感配置
| `nacos` | ✅ | ❌ | 云原生环境
|===

== 12. 分布式事务 Seata -- 使用 Nacos 注册服务例子
image::img/transactional.png[,800]

=== 创建 MySQL 数据库及相关表
创建了三个数据库：

* account_db
* order_db
* storage_db

每个数据库里的 undo_log 表是 seata 做事务管理要使用的。


[source,sql]
----
CREATE
DATABASE IF NOT EXISTS `storage_db`;
USE
`storage_db`;

DROP TABLE IF EXISTS `storage_tbl`;
CREATE TABLE `storage_tbl`
(
    `id`             int(11) NOT NULL AUTO_INCREMENT,
    `commodity_code` varchar(255) DEFAULT NULL,
    `count`          int(11) DEFAULT 0,
    PRIMARY KEY (`id`),
    UNIQUE KEY (`commodity_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `storage_tbl` (`commodity_code`, `count`)
VALUES ('P0001', 100);
INSERT INTO `storage_tbl` (`commodity_code`, `count`)
VALUES ('B1234', 10);

-- 注意此处 0.3.0+ 增加唯一索引 ux_undo_log
DROP TABLE IF EXISTS `undo_log`;
CREATE TABLE `undo_log`
(
    `id`            bigint(20) NOT NULL AUTO_INCREMENT,
    `branch_id`     bigint(20) NOT NULL,
    `xid`           varchar(100) NOT NULL,
    `context`       varchar(128) NOT NULL,
    `rollback_info` longblob     NOT NULL,
    `log_status`    int(11) NOT NULL,
    `log_created`   datetime     NOT NULL,
    `log_modified`  datetime     NOT NULL,
    `ext`           varchar(100) DEFAULT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

CREATE
DATABASE IF NOT EXISTS `order_db`;
USE
`order_db`;

DROP TABLE IF EXISTS `order_tbl`;
CREATE TABLE `order_tbl`
(
    `id`             int(11) NOT NULL AUTO_INCREMENT,
    `user_id`        varchar(255) DEFAULT NULL,
    `commodity_code` varchar(255) DEFAULT NULL,
    `count`          int(11) DEFAULT 0,
    `money`          int(11) DEFAULT 0,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- 注意此处 0.3.0+ 增加唯一索引 ux_undo_log
DROP TABLE IF EXISTS `undo_log`;
CREATE TABLE `undo_log`
(
    `id`            bigint(20) NOT NULL AUTO_INCREMENT,
    `branch_id`     bigint(20) NOT NULL,
    `xid`           varchar(100) NOT NULL,
    `context`       varchar(128) NOT NULL,
    `rollback_info` longblob     NOT NULL,
    `log_status`    int(11) NOT NULL,
    `log_created`   datetime     NOT NULL,
    `log_modified`  datetime     NOT NULL,
    `ext`           varchar(100) DEFAULT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

CREATE
DATABASE IF NOT EXISTS `account_db`;
USE
`account_db`;

DROP TABLE IF EXISTS `account_tbl`;
CREATE TABLE `account_tbl`
(
    `id`      int(11) NOT NULL AUTO_INCREMENT,
    `user_id` varchar(255) DEFAULT NULL,
    `money`   int(11) DEFAULT 0,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `account_tbl` (`user_id`, `money`)
VALUES ('1', 10000);

-- 注意此处 0.3.0+ 增加唯一索引 ux_undo_log
DROP TABLE IF EXISTS `undo_log`;
CREATE TABLE `undo_log`
(
    `id`            bigint(20) NOT NULL AUTO_INCREMENT,
    `branch_id`     bigint(20) NOT NULL,
    `xid`           varchar(100) NOT NULL,
    `context`       varchar(128) NOT NULL,
    `rollback_info` longblob     NOT NULL,
    `log_status`    int(11) NOT NULL,
    `log_created`   datetime     NOT NULL,
    `log_modified`  datetime     NOT NULL,
    `ext`           varchar(100) DEFAULT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
----

== 13. 服务保护 Sentinel


=== docker 开启 sentinel-dashboard
image::img/sentinel_dashboard186.png[]

image::img/sentinel_dashboard186_run.png[]

image::img/sentinel_dashboard186_admin.png[]

== 14. 服务部署
[mermaid, target=img/mermaid-2025-10-12-105950, format=svg]
....
flowchart TD

    Client[客户端请求<br/>https://api.company.com]

    subgraph NginxLayer [第一层: Nginx 静态负载均衡]
        Nginx[Nginx<br/>基于配置文件的负载均衡]
    end

    subgraph GatewayLayer [第二层: Gateway 动态集群]
        G1[Gateway 实例1]
        G2[Gateway 实例2]
        G3[Gateway 实例3]
        %% 横向排列
        G1 --> G2 --> G3
    end

    subgraph MicroserviceLayer [第三层: 微服务集群]
        User[用户服务<br>192.168.1.10:8080<br>192.168.1.11:8081]
        Order[订单服务<br>192.168.1.12:8082<br>192.168.1.13:8083]
        Product[商品服务<br>192.168.1.14:8084]
        %% 横向排列
        User --> Order --> Product
    end

    Client --> NginxLayer
    NginxLayer --> GatewayLayer
    GatewayLayer --> MicroserviceLayer
....

