:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3

= Spring Cloud 微服务

++++
<button id="toggleButton">Table of Contents</button>
<script>
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () => {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
</script>
++++

== 1. Spring Cloud 微服务介绍


=== 1.1 什么是微服务？
1. 单体架构的困境
+
在传统单体架构（Monolithic Architecture）中，所有功能模块（如用户管理、订单管理、支付管理等）都被打包在一个大的应用程序中，并部署在一个应用服务器上。

* *优点*：开发、测试、部署简单。
* *缺点*：
  ** 复杂性高：代码庞大，耦合度高，维护困难。
  ** 技术栈僵化：难以引入新的技术或框架。
  ** 扩展性差：无法针对特定模块进行扩展，必须扩展整个应用。
  ** 部署不灵活：一个小修改就需要重新部署整个应用，风险高。
  ** 可靠性低：一个微小的问题可能导致整个应用崩溃。


2. 微服务架构的解决方案
+
微服务架构（Microservices Architecture）是一种将单个应用程序拆分为 #一组小而自治的服务# 的架构风格。

* *核心思想*：*拆分* 与 *解耦*。
* *每个服务*：
  ** 围绕 *业务能力* 构建。
  ** 拥有独立的 *数据库* 和 *数据模型*。
  ** 可以独立 *开发*、*部署*、*扩展* 和 *重启*。
  ** 通过轻量级的通信机制（如 HTTP/REST、gRPC）进行协作。

+
比喻：

* *单体应用* 像一个 *大商场* ：所有部门（服装、餐饮、超市）在一个大楼里，共享水电消防。一损俱损。
* *微服务* 像一个 *商业街* ：每个店铺（服务）独立经营，有自己的特色和库存，通过公共街道（网络）连接。一店装修，不影响其他店。

=== 1.2 微服务带来的新挑战
拆分成多个服务后，也引入了新的复杂性：

. 服务发现：服务实例动态变化，消费者如何找到提供者？
. 配置管理：如何统一管理所有服务的配置，并实现动态更新？
. 负载均衡：如何将请求合理地分发到多个服务实例上？
. 容错与熔断：如何防止一个服务故障导致整个系统雪崩？
. API网关：如何为外部客户端提供一个统一的入口，并处理跨切面问题（认证、限流、路由）？
. 分布式事务：如何保证跨多个服务的数据一致性？
. 监控与链路追踪：如何跟踪一个请求穿越多个服务的全过程，以便排查问题？

=== 1.3 Spring Cloud？
1. 定义
+
Spring Cloud 是一套基于 Spring Boot的 #微服务生态工具集#。它提供了一系列 #标准化的工具和组件#，用于快速解决微服务架构中的常见问题（如上述挑战），让我们能更专注于业务逻辑的开发。
+
*简单来说*：Spring Boot 让开发单个微服务变得简单，而 Spring Cloud 让 #管理和协调# 这些微服务变得简单。


2. 核心定位
+
Spring Cloud 通过封装 *Netflix*、*Alibaba* 等公司成熟的微服务解决方案，提供了 *开箱即用* 的分布式系统开发体验。

=== 1.4 Cloud 的核心组件/子项目
Spring Cloud是一个“全家桶”，包含众多组件，以下是其中最核心的几个：

[cols="1,3,2", options="header"]
|===
| 组件名称
| 功能
| 比喻

| *Eureka / Nacos*
| *服务发现与注册*：服务提供者启动后向注册中心注册自己的地址，消费者从注册中心拉取服务列表。
| *电话簿*：服务在这里注册和查找彼此的地址。

| *Ribbon / LoadBalancer*
| *客户端负载均衡*：从服务列表中选择一个实例，将请求分发过去。
| *导游*：在多个相同的服务实例中，选择一个带你去。

| *Feign / OpenFeign*
| *声明式HTTP客户端*：基于接口和注解的方式调用远程服务，像调用本地方法一样简单。
| *翻译官*：帮你自动完成HTTP请求的组装和发送。

| *Hystrix / Sentinel*
| *熔断器*：当服务调用失败率达到阈值时，快速失败（熔断），防止雪崩效应，并提供服务降级。
| *保险丝*：电流过大（故障太多）自动熔断，保护整个电路（系统）。

| *Zuul / Gateway*
| *API网关*：所有外部请求的统一入口，负责路由、过滤、认证、限流、监控等。
| *前台/门卫*：所有访客必须经过这里，由它决定谁可以进、去哪里。

| *Config / Nacos*
| *分布式配置中心*：集中管理所有环境的配置文件，支持动态刷新。
| *公告板*：所有服务从这里获取最新配置，无需重启即可生效。

| *Sleuth / Zipkin*
| *分布式链路追踪*：跟踪一个请求从开始到结束的完整路径，用于性能分析和故障排查。
| *快递追踪*：可以查看你的包裹（请求）经过了哪些中转站（服务）。
|===

=== 1.5 Cloud 的流派
目前主要有两大主流体系：

. *Netflix系*：Spring Cloud Netflix（如 Eureka, Hystrix, Zuul）是早期标准，目前已部分进入维护模式。

. *Alibaba系*：*Spring Cloud Alibaba* 是目前国内最主流的方案，它提供了一站式的微服务解决方案（如 Nacos, Sentinel, Seata），与 Spring Cloud 生态无缝集成，功能强大且活跃度高。

*建议*：新项目首选 *Spring Cloud Alibaba*。

=== 1.6 总结
* 微服务架构通过拆分和解耦，解决了单体应用的痛点，但也带来了分布式系统的复杂性。

* *Spring Cloud* 不是一门新技术，而是一个 *工具箱*，它提供了 *一整套标准化的解决方案* 来轻松应对这些复杂性。

* 使用 *Spring Boot + Spring Cloud*，可以快速构建和治理一套完整、健壮的分布式微服务系统。

== 2. 创建一个空的工程 micro-service

image::img/create_empty_project.png[,800]

== 3. 创建商品微服务模块 service-item
写完下面的代码后，使用 httpie 测试一下

http :8081/item/1

=== file -> service-item/pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.18</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.tjise</groupId>
    <artifactId>service-item</artifactId>
    <version>1.0-SNAPSHOT</version>
    <name>service-item</name>
    <description>service-item</description>
    <properties>
        <java.version>1.8</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>


</project>

=== file -> service-item/src/main/java/com/tjise/serviceitem/pojo/Item.java
package com.tjise.serviceitem.pojo;

import lombok.Data;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Item {
    
    private Long id;
    
    private String title;
    
    private String pic;
    
    private String desc;
    
    private Long price;
}

=== file -> service-item/src/main/java/com/tjise/serviceitem/service/ItemService.java
package com.tjise.serviceitem.service;

import com.tjise.serviceitem.pojo.Item;
import org.springframework.stereotype.Service;
import java.util.HashMap;
import java.util.Map;

@Service
public class ItemService {

    private static final Map<Long, Item> ITEM_MAP = new HashMap<Long, Item>();

    static {// 准备一些静态数据，模拟数据库，只是为了简单而已
        ITEM_MAP.put(1L, new Item(1L, "商品1", "http://图片1", "商品描述1", 1000L));
        ITEM_MAP.put(2L, new Item(2L, "商品2", "http://图片2", "商品描述2", 2000L));
        ITEM_MAP.put(3L, new Item(3L, "商品3", "http://图片3", "商品描述3", 3000L));
        ITEM_MAP.put(4L, new Item(4L, "商品4", "http://图片4", "商品描述4", 4000L));
        ITEM_MAP.put(5L, new Item(5L, "商品5", "http://图片5", "商品描述5", 5000L));
        ITEM_MAP.put(6L, new Item(6L, "商品6", "http://图片6", "商品描述6", 6000L));
        ITEM_MAP.put(7L, new Item(7L, "商品7", "http://图片7", "商品描述7", 7000L));
        ITEM_MAP.put(8L, new Item(8L, "商品8", "http://图片8", "商品描述8", 8000L));
        ITEM_MAP.put(9L, new Item(9L, "商品9", "http://图片9", "商品描述9", 9000L));
        ITEM_MAP.put(10L, new Item(10L, "商品10", "http://图片10", "商品描述10", 10000L));
    }

    /**
     * 模拟实现商品查询
     *
     * @param id
     * @return
     */
    public Item queryItemById(Long id) {
        return ITEM_MAP.get(id);
    }

}

=== file -> service-item/src/main/java/com/tjise/serviceitem/controller/ItemController.java
package com.tjise.serviceitem.controller;

import com.tjise.serviceitem.pojo.Item;
import com.tjise.serviceitem.service.ItemService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ItemController {

    @Autowired
    private ItemService itemService;

    /**
     * 对外提供接口服务，查询商品信息
     *
     * @param id
     * @return
     */
    @GetMapping(value = "item/{id}")
    public Item queryItemById(@PathVariable("id") Long id) {
        return this.itemService.queryItemById(id);
    }

}

=== file -> service-item/src/main/java/com/tjise/serviceitem/ServiceItemApplication.java
package com.tjise.serviceitem;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ServiceItemApplication {

    public static void main(String[] args) {
        SpringApplication.run(ServiceItemApplication.class, args);
    }
}

=== file -> service-item/src/main/resources/application.yml
server:
  port: 8081

== 4. 创建订单微服务模块 service-order


=== file -> service-order/pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.18</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.tjise</groupId>
    <artifactId>service-order</artifactId>
    <version>1.0-SNAPSHOT</version>
    <name>service-order</name>
    <description>service-order</description>
    <properties>
        <java.version>1.8</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>

=== file -> service-order/src/main/java/com/tjise/serviceorder/pojo/Item.java
.商品实体类 Item
[source,java]
----
package com.tjise.serviceorder.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Item {
    private Long id;
    private String title;
    private String pic;
    private String desc;
    private Long price;
}
----

=== file -> service-order/src/main/java/com/tjise/serviceorder/pojo/Order.java
.订单实体类 Order
[source,java]
----
package com.tjise.serviceorder.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.Date;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    private String orderId;
    private Long userId;
    private Date createDate;
    private Date updateDate;
    private List<OrderDetail> orderDetails;
}
----

=== file -> service-order/src/main/java/com/tjise/serviceorder/pojo/OrderDetail.java
package com.tjise.serviceorder.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderDetail {
    private String orderId;
    private Item item;
}

=== file -> service-order/src/main/java/com/tjise/serviceorder/service/OrderService.java


==== class OrderService
/**
 * 订单服务类
 * 提供订单查询功能，并通过调用商品服务获取商品详细信息
 */
@Service
public class OrderService {
    @others
}

===== ORDER_DATA 模拟数据
// 使用静态Map模拟数据库存储订单数据
private static final Map<String, Order> ORDER_DATA = new HashMap<String, Order>();
// 初始化订单数据
static {
    // 模拟数据库，构造测试数据
    @others
}

====== 订单 order
Order order = new Order();
order.setOrderId("201810300001");
order.setCreateDate(new Date());
order.setUpdateDate(order.getCreateDate());  // 真会偷懒呀
order.setUserId(1L);
List<OrderDetail> orderDetails = new ArrayList<OrderDetail>();

// 创建第一个商品详情（仅保存商品ID，需要调用商品微服务获取详细信息）
Item item = new Item();
item.setId(1L);
orderDetails.add(new OrderDetail(order.getOrderId(), item));

// 创建第二个商品详情
item = new Item();
item.setId(2L);
orderDetails.add(new OrderDetail(order.getOrderId(), item));

order.setOrderDetails(orderDetails);

ORDER_DATA.put(order.getOrderId(), order);

===== queryOrderById
// 注入商品服务，用于查询商品详细信息
@Autowired
private ItemService itemService;
/**
 * 根据订单ID查询订单数据
 * 
 * @param orderId 订单ID
 * @return Order 订单信息，包含完整的商品详情
 */
public Order queryOrderById(String orderId) throws IOException {
    // 从模拟数据库中查询订单
    Order order = ORDER_DATA.get(orderId);
    if (null == order) {
        return null;
    }
    // 获取订单详情列表
    List<OrderDetail> orderDetails = order.getOrderDetails();

    // 遍历订单详情，通过商品微服务查询商品详细数据
    for (OrderDetail orderDetail : orderDetails) {
        // 通过商品微服务查询商品详细数据
        Item item = itemService.queryItemById(orderDetail.getItem().getId());
        if (null == item) {
            continue;
        }
        // 将查询到的商品详细信息设置到订单详情中
        orderDetail.setItem(item);
    }
    return order;
}

=== file -> service-order/src/main/java/com/tjise/serviceorder/service/ItemService.java
package com.tjise.serviceorder.service;

import com.tjise.serviceorder.pojo.Item;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

/**
 * 商品服务类
 * 通过 REST 方式调用商品微服务获取商品信息
 */
@Service
public class ItemService {

    // Spring 框架对 RESTful 方式的 http 请求做了封装，来简化操作
    @Autowired
    private RestTemplate restTemplate;

    /**
     * 根据商品 ID 查询商品信息
     * 通过 REST 调用商品微服务获取商品详细数据
     * 
     * @param id 商品ID
     * @return Item 商品信息
     */
    public Item queryItemById(Long id) {
        return restTemplate.getForObject("http://127.0.0.1:8081/item/"
                + id, Item.class);
    }
}

=== file -> service-order/src/main/java/com/tjise/serviceorder/controller/OrderController.java
[source,java]
----
package com.tjise.serviceorder.controller;

import com.tjise.serviceorder.pojo.Order;
import com.tjise.serviceorder.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

/**
 * 订单控制器
 * 处理订单相关的HTTP请求
 */
@RestController
public class OrderController {
    
    // 注入订单服务
    @Autowired
    private OrderService orderService;

    /**
     * 根据订单ID查询订单信息
     * 
     * @param orderId 订单ID
     * @return Order 订单信息
     */
    @GetMapping(value = "order/{orderId}")
    public Order queryOrderById(@PathVariable("orderId") String orderId) {
        return orderService.queryOrderById(orderId);
    }
}
----

httpie 测试:
http :8091/order/201810300001

=== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java
package com.tjise.serviceorder;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

/**
 * 订单服务启动类
 * Spring Boot 应用程序入口点
 */
@SpringBootApplication
public class ServiceOrderApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceOrderApplication.class, args);
    }

    /**
     * 创建RestTemplate实例
     * 用于调用其他微服务
     * 
     * @return RestTemplate
     */
    @Bean
    public RestTemplate restTemplate() {
        // 可以在这里添加拦截器来统一处理URL前缀
        return new RestTemplate();
    }
}

=== file -> service-order/src/main/resources/application.yml
server:
  port: 8091

== 5. HTTP 客户端


=== 5.1 RestTemplate -- Spring 提供的传统同步 HTTP 客户端
前面演示的是 方式一：字段注入（需要 @Autowired），
下面演示一下使用 方式二单个构造函数注入的例子。

==== file -> service-order/src/main/java/com/tjise/serviceorder/service/ItemService.java


===== class ItemService
/**
 * 商品服务类
 * 通过 REST 方式调用商品微服务获取商品信息
 */
@Service
public class ItemService {
    @others
}

====== 方式二 单个构造函数注入
[source,java]
----
private final RestTemplate restTemplate;
public ItemService(RestTemplate restTemplate) {
    this.restTemplate = restTemplate;
}
----

=== 5.2 RestTemplate + OkHttp 可以兼容老代码
为了兼容老的 RestTemplate 代码，也可以在 RestTemplate 中配置 OkHttp。

==== file -> service-order/pom.xml


===== okhttp 依赖
[source,scss]
....
<!-- 使用 Spring Boot 管理的版本： -->
<dependency>
    <groupId>com.squareup.okhttp3</groupId>
    <artifactId>okhttp</artifactId>
</dependency>
....

==== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java


===== RestTemplate restTemplate
[source,java]
----
/**
 * 创建RestTemplate实例
 * 用于调用其他微服务
 * 
 * @return RestTemplate
 */
@Bean
public RestTemplate restTemplate() {
    // 可以在这里添加拦截器来统一处理URL前缀
    // return new RestTemplate();  // 未使用 OkHttp
    return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
}
----

==== file -> service-order/src/main/java/com/tjise/serviceorder/service/ItemService.java


===== 方式二 单个构造函数注入 -- 增加了查看是否成功使用了 OkHttp 打印
[source,java]
----
private final RestTemplate restTemplate;
public ItemService(RestTemplate restTemplate) {  // 单个构造函数
    this.restTemplate = restTemplate;
    // 检查请求工厂类型
    System.out.println("Request Factory: " + restTemplate.getRequestFactory().getClass().getName());
    // 成功使用 OkHttp 会打印
    // Request Factory: org.springframework.http.client.OkHttp3ClientHttpRequestFactory
}
----

=== 5.3 OkHttp -- 单独使用 Square 开源的高性能 HTTP 客户端
OkHttp 的异步 API 在应用程序层面实现了与 Node.js 类似的高并发编程模型：通过非阻塞 I/O 和回调机制，最大化利用少量线程来处理海量网络连接，从而高效地处理高并发 HTTP 请求。

==== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java


===== OkHttpClient okHttpClient
[source,java]
----
@Bean
public OkHttpClient okHttpClient() {
    return new OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .build();
}
----

==== file -> service-order/src/main/java/com/tjise/serviceorder/service/ItemService.java
[source,java]
----
package com.tjise.serviceorder.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tjise.serviceorder.pojo.Item;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import org.springframework.stereotype.Service;

import java.io.IOException;

@Service
public class ItemService {
    // 下面这两种方式是等价的，看自己的使用方式而定
    // 方式一：字段注入（需要 @Autowired）
    // @Autowired
    // private OkHttpClient client;

    // 方式二 单个构造函数注入
    private final OkHttpClient client;  // 单个构造函数注入（不需要 @Autowired
    private final ObjectMapper objectMapper;  // 可支持 json 序列化
    public ItemService(OkHttpClient client, ObjectMapper objectMapper) {
        this.client = client;
        this.objectMapper = objectMapper;
        // 检查请求工厂类型
        System.out.println("Using OkHttpClient: " + client.getClass().getName());
        // 打印：Using OkHttpClient: okhttp3.OkHttpClient
    }

    public Item queryItemById(Long id) throws IOException {
        Request request = new Request.Builder()
                .url("http://127.0.0.1:8081/item/" + id)
                .build();
        try (Response response = client.newCall(request).execute()) {
            // 读取响应体
            String json = response.body().string();
            // 使用注入的 objectMapper 反序列化成 JSON 字符串
            return objectMapper.readValue(json, Item.class);
        }
    }
}
----

=== 5.4 WebClient  -- Spring WebFlux 提供的响应式 HTTP 客户端


==== file -> service-order/pom.xml


===== WebClient
[source,scss]
....
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
....

==== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java


===== WebClient
[source,java]
----
@Bean
public WebClient webClient() {
    return WebClient.builder()
          .baseUrl("http://127.0.0.1:8081/item")
          .build();
}
----

==== file -> service-order/src/main/java/com/tjise/serviceorder/service/ItemService.java
[source,java]
----
package com.tjise.serviceorder.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tjise.serviceorder.pojo.Item;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;

import java.io.IOException;

@Service
public class ItemService {
    // 下面这两种方式是等价的，看自己的使用方式而定
    // 方式一：字段注入（需要 @Autowired）
    // @Autowired
    // private WebClient webClient;

    // 方式二 单个构造函数注入
    private final WebClient webClient;
    public ItemService(WebClient webClient) {
        this.webClient = webClient;
    }

    public Item queryItemById(Long id) {
        return webClient.get()
            .uri("/{id}", id)
            .retrieve()
            .bodyToMono(Item.class)
            .block(); // 同步调用，如需要异步可去掉block()
    }
}
----

=== 5.5  RestClient -- Spring 6.1 才支持（目前的 Spring Boot 2.7.18 使用的是 Spring 5.3.x）
RestClient 的主要价值在于它提供了一个现代化但又不失简单的 API，结合了 RestTemplate 的易用性和 WebClient 的功能强大，是未来 Spring 应用HTTP客户端调用的推荐选择。

== 6. service-order url 硬编码问题


=== 6.1 解决 service-order url 硬编码问题：使用 @Value
通过以上的测试我们发现，在订单系统中要调用商品微服务中的查询接口来获取数据，在订单微服务中将 url 硬编码到代码中，这样显然不好，因为，运行环境一旦发生变化这个 url 地址将不可用。

如何解决呢？

解决方案：将 url 地址写入到 yml 配置文件中。

==== file -> service-order/src/main/resources/application.yml
[source,python]
----
server:
  port: 8091

# 新增 url 配置
myspcloud:
  item:
    url: http://127.0.0.1:8081/item/

----

==== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java


===== class ServiceOrderApplication
/**
 * 订单服务启动类
 * Spring Boot 应用程序入口点
 */
@SpringBootApplication
public class ServiceOrderApplication {

    // 新增使用 @Value 注解获取配置的 url
    @Value("${myspcloud.item.url}")
    private String itemUrl;

    public static void main(String[] args) {
        SpringApplication.run(ServiceOrderApplication.class, args);
    }
    @others
}

====== WebClient
[source,java]
----
@Bean
public WebClient webClient() {
    return WebClient.builder()
        .baseUrl(itemUrl)   // 使用注入的 Url
        .build();
}
----

=== 6.2 解决 service-order url 硬编码问题：使用 @ConfigurationProperties


==== file -> service-order/src/main/java/com/tjise/serviceorder/utils/ItemProperties.java
[source,java]
----
package com.tjise.serviceorder.utils;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;


@Data
@Component
@ConfigurationProperties(prefix = "myspcloud.item")
public class ItemProperties {
    // 下面属性值的内容会从配置文件中被自动获取到
    private String url;
}
----

==== file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java


===== class ServiceOrderApplication
/**
 * 订单服务启动类
 * Spring Boot 应用程序入口点
 */
@SpringBootApplication
public class ServiceOrderApplication {

    // 新增 DI 注入 配置的 url
    @Autowired
    private ItemProperties itemProperties;

    public static void main(String[] args) {
        SpringApplication.run(ServiceOrderApplication.class, args);
    }
    @others
}

====== @Bean WebClient
[source,java]
----
// 直接注入也可以的
// public WebClient webClient(ItemServiceProperties properties) {
@Bean
public WebClient webClient() {
    return WebClient.builder()
        .baseUrl(itemProperties.getUrl())   // 使用注入的 Url
        .build();
}
----

== 7. 引入微服务注册、发现机制
* 问题：商品微服务 ip 发生变更则需要更改订单微服务的配置文件
* 问题：商品微服务有多个，订单微服务该链接哪个？

从而引入微服务注册、发现机制，如下。

image::img/service_register.png[,640]

1. 服务提供者将服务注册到注册中心
2. 服务消费者通过注册中心查找服务
3. 查找到服务后进行调用（这里就是无需硬编码 url 的解决方案）
4. 服务的消费者与服务注册中心保持心跳连接，一旦服务提供者的地址发生变更时，注册中心会通知服务消费者

=== 7.1 Eureka 介绍
Eureka 是 Netfix 开源的服务发现组件，本身是一个基于 REST 的服务。它包含 Server 和 Client 两部分。SpringCloud 将它集成在子项目 SpringCloud Netfix 中，从而实现微服务的注册与发现。

* Eureka Server 提供服务注册服务，各个节点启动后，会在 Eureka Server 中进行注册，这样 EurekaServer 中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。

* Eureka Client 是一个 java 客户端，用于简化与 Eureka Server 的交互，客户端同时也有一个内置的、使用轮询(round-robin)负载算法的负载均衡器。

* 在应用启动后，将会向 Eureka Server 发送心跳,默认周期为 30 秒，如果 Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，Eureka Server 将会从服务注册表中把这个服务节点移除(默认90秒)。

* Eureka Server 之间通过复制的方式完成数据的同步，Eureka 还提供了客户端缓存机制，即使所有的 Eureka Server 都挂掉，客户端依然可以利用缓存中的信息消费其他服务的 API。

综上，Eureka 通过心跳检查、客户端缓存等机制，确保了系统的高可用性、灵活性和可伸缩性。

=== 7.2 Eureka Server 的创建
创建一个 maven 的项目，命名为 eureka。

image::img/create_eureka_module.png[,800]

==== file -> eureka/pom.xml
[source,scss]
....
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.tjise</groupId>
    <artifactId>eureka</artifactId>
    <version>1.0-SNAPSHOT</version>
    <!-- 加入下面各项内容 -->
    @others
</project>
....

===== 1. properties 配置项目属性：Java 版本、Spring Boot 和 Spring Cloud 版本
[source,scss]
....
<properties>
    <maven.compiler.source>8</maven.compiler.source>
    <maven.compiler.target>8</maven.compiler.target>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <!-- 这两个版本要匹配才行 -->
    <spring.boot.version>2.7.18</spring.boot.version>
    <spring.cloud.version>2021.0.8</spring.cloud.version>
</properties>
....

===== 2. dependencyManagement 依赖管理：导入 Spring Boot 和 Spring Cloud 的依赖管理
[source,scss]
....
<dependencyManagement>
    <dependencies>
        <!-- Spring Boot 依赖管理 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>${spring.boot.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <!-- Spring Cloud依赖管理 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring.cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
....

===== 3. dependencies 项目依赖：添加 Eureka Server 依赖
[source,scss]
....
<dependencies>
    <!-- Eureka Server核心依赖 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>
</dependencies>
....

===== 4. plugins 构建配置：添加 Spring Boot Maven 插件
[source,scss]
....
<build>
    <plugins>
        <!-- Spring Boot Maven插件，用于打包可执行jar -->
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <version>${spring.boot.version}</version>
        </plugin>
    </plugins>
</build>
....

==== file -> eureka/src/main/java/com/tjise/eureka/EurekaApplication.java
package com.tjise.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/**
 * Eureka Server启动类
 * 
 * @EnableEurekaServer 注解启用 Eureka Server 功能
 */
@SpringBootApplication
@EnableEurekaServer
public class EurekaApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}

==== file -> eureka/src/main/resources/application.yml
server:
  port: 8761  # 1. Eureka Server端口设置为8761（默认端口）

eureka:
  instance:
    hostname: localhost  # 2. 设置主机名为localhost
  client:
    register-with-eureka: false  # 3. Eureka Server不向自己注册
    fetch-registry: false        # 4. Eureka 自己不需要获取服务注册信息
    service-url:
      # 5. 设置 Eureka Server 的访问地址
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
      
  server:
    enable-self-preservation: false  # 6. 关闭自我保护机制（开发环境建议关闭，但是会有红色警告提示，属于正常）
                                     # 设置成 false 后保证服务不可用时及时剔除相应的微服务，易测试。

==== 启动 Eureka Server 并测试网页管理端
现在可以通过以下命令启动 Eureka Server：

. 进入eureka项目目录
* cd /Users/swot/swot-learning/java/SpringCloud/eureka

. 使用 IDEA 启动应用
* mvn spring-boot:run

. 或者先打包再运行
* mvn clean package
* java -jar target/eureka-1.0-SNAPSHOT.jar

启动后访问 http://localhost:8761 即可看到 Eureka Server 的管理界面。

image::img/eureka_admin_no_instance.png[]

=== 7.3 Eureka Server 注册商品微服务
成功注册 service-item 到 eureka 是这样的，如下图

image::img/eureka_admin_with_service-item.png[]

==== file -> service-item/pom.xml


===== properties Add cloud Version 2021.0.8
[source,scss]
....
<properties>
    <java.version>1.8</java.version>
    <spring-cloud.version>2021.0.8</spring-cloud.version>
</properties>
....

===== dependencyManagement Add cloud dependency
[source,scss]
....
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
....

===== spring-cloud-starter-netflix-eureka-client
[source,scss]
....
<!-- 添加 Eureka 客户端依赖, 用于将服务注册到 Eureka -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
....

==== file -> service-item/src/main/resources/application.yml
[source,python]
----
### 服务端口号(本身是一个web项目)
server:
    port: 8081

### 起个名字作为服务名称(该服务注册到eureka注册中心的名称，比如商品服务)
spring:
    application:
        name: app-item

### 服务注册到eureka注册中心的地址
eureka:
    client:
        service-url:
            defaultZone: http://127.0.0.1:8761/eureka/
        ### 因为该应用为服务提供者，是 eureka 的一个客户端，需要注册到注册中心
        register-with-eureka: true
        ### 是否需要从 eureka 上检索服务
        fetch-registry: true
    instance:
        # 使用IP地址注册而不是主机名
        prefer-ip-address: true
        # 客户端在注册时使用自己的IP，而不是主机名，是生产环境的最佳实践。避免主机名解析问题
        ip-address: 127.0.0.1
----

****
name 和 instance 两者都有重要作用，缺一不可：

- spring.application.name：服务的逻辑名称，用于服务发现和负载均衡
- eureka.instance 配置：实例的网络地址，用于实际通信

即使使用IP注册，仍然需要服务名称来进行服务发现和调用。
****

==== file -> service-item/src/main/java/com/tjise/serviceitem/ServiceItemApplication.java
[source,java]
----
package com.tjise.serviceitem;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient  // <1>
public class ServiceItemApplication {

    public static void main(String[] args) {
        SpringApplication.run(ServiceItemApplication.class, args);
    }
}
----

<1> 启用 uereka 客户端注解

==== 启动多个 service-item 商品微服务实例
重复操作下面步骤 2 次，一共启动 3 个 service-item 实例。

.复制 service-item 配置
image::img/serviceItem_copy_config.png[]

.编辑 service-item 配置启动新端口
image::img/serviceItem_copy_config_edit.png[,520]

.在 Eureka 中发现有 3 个 service-item 实例已经注册成功
image::img/three_serviceItem_in_eureka.png[]

=== 7.4 Eureka 中发现商品微服务
之前我们在订单系统中是将商品微服务的地址进行了硬编码，现在，由于已经将商品服务注册到 Eureka 中，所以，只需要从 Eureka 中发现服务即可。

成功注册 service-order 到 eureka 是这样的，如下图

image::img/eureka_admin_with_service-order.png[]

httpie 测试:
[source,console]
----
http :8091/order/201810300001
----

==== 7.4.1 file -> service-order/pom.xml


===== properties version
[source,scss]
....
<properties>
    <java.version>1.8</java.version>
    <spring-cloud.version>2021.0.8</spring-cloud.version>
</properties>
....

===== Add cloud dependency
[source,scss]
....
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
....

===== eureka-client 依赖
[source,scss]
....
<!-- 添加 Eureka 客户端依赖, 用于将服务注册到 Eureka -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
....

==== 7.4.2 file -> service-order/src/main/resources/application.yml


===== port
[source,yaml]
----
server:
    port: 8091
----

===== name
[source, yaml]
----
# 起个名字作为服务名称(该服务注册到 eureka 注册中心的名称，比如订单服务)
spring:
    application:
        name: app-order
----

===== eureka
[source,yaml]
----
# 服务注册到 eureka 注册中心的地址
eureka:
    client:
        service-url:
            defaultZone: http://127.0.0.1:8761/eureka
        register-with-eureka: true  # 因为该应用为服务提供者，是 eureka 的一个客户端，需要注册到注册中心
        fetch-registry: true        # 是否需要从 eureka 上检索服务
    instance:
        prefer-ip-address: true     # 使用 IP地址 注册而不是主机名
        ip-address: 127.0.0.1       # 客户端在注册时使用自己的 IP，而不是主机名
                                    # 这是生产环境的最佳实践。避免主机名解析问题
----

==== 7.4.3 file -> service-order/src/main/java/com/tjise/serviceorder/ServiceOrderApplication.java


===== class ServiceOrderApplication -> NOTE:下面的三个客户端任选一个即可
[source,java]
----
/**
 * 订单服务启动类，Spring Boot 应用程序入口点。
 */
@SpringBootApplication
@EnableEurekaClient  // new -> 启用 Eureka 客户端功能
public class ServiceOrderApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceOrderApplication.class, args);
    }
    // 包含其他代码
    @others
}
----

.负载均衡使用拦截器原理：
****
1. 拦截请求URL
2. 识别服务名
3. 通过服务发现获取实际地址
4. 替换URL并发起请求
****

====== RestTemplate
[source,java]
----
/**
 * 创建 RestTemplate 实例，用于调用其他微服务。
 * @return RestTemplate
 */
@Bean
@LoadBalanced // new -> 使用负载均衡
public RestTemplate restTemplate() {
    // 可以在这里添加拦截器来统一处理URL前缀
    // return new RestTemplate();  // not use OkHttp
    return new RestTemplate(
           new OkHttp3ClientHttpRequestFactory());  // use OkHttp
}
----

====== OkHttpClient 不支持 @LoadBalanced
[source,java]
----
@Bean
// @LoadBalanced  // OkHttpClient 不支持负载均衡，在这儿写该注解没用。
public OkHttpClient okHttpClient() {
    return new OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .build();
}
----

====== WebClient
[source,java]
----
// 配置负载均衡的 WebClient.Builder
@Bean
@LoadBalanced // new -> 使用负载均衡
public WebClient.Builder loadBalancedWebClientBuilder() {
    return WebClient.builder();
}

// 使用 Builder 创建 WebClient
@Bean
public WebClient webClient(WebClient.Builder builder) {
    return builder
        .baseUrl("http://app-item/item")  // 使用 eureka 注册中心调用(去注册中心查找服务 app-item，这种方式必须先开启负载均衡 @LoadBalanced)
        .build();
}
----

.总结
****
WebClient 也需要使用 @LoadBalanced 注解，但需要注解在 WebClient.Builder 上，而不是 WebClient 实例上。
这与 WebClient 的设计有关：

- WebClient 是不可变的（immutable）
- WebClient.Builder 是可变的，用于构建 WebClient 实例
- Spring Cloud 需要在 Builder 层面注入负载均衡能力

这样设计是为了与 WebClient 的不可变性设计保持一致，同时也提供了更灵活的配置方式。
****

==== 7.4.4 file -> service-order/src/main/java/com/tjise/serviceorder/service/ItemService.java


===== import
package com.tjise.serviceorder.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tjise.serviceorder.pojo.Item;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.loadbalancer.LoadBalancerClient;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.reactive.function.client.WebClient;

import java.io.IOException;

===== class ItemService
[source,java]
----
// 根据商品 ID 查询商品信息：通过 REST 调用商品微服务获取商品详细数据
@Service
public class ItemService {  // 商品服务类
    @Autowired
    private RestTemplate restTemplate;

    private final WebClient webClient;
    private final OkHttpClient okHttpClient;
    private final ObjectMapper objectMapper;  // 可支持 json 序列化

    // 单个构造方法注入
    public ItemService(
            WebClient webClient,
            @Autowired(required = false) OkHttpClient okHttpClient,
            @Autowired(required = false) ObjectMapper objectMapper) {
        this.webClient = webClient;
        this.okHttpClient = okHttpClient;
        this.objectMapper = objectMapper;
    }
    // 包含其他代码
    @others
}
----

====== 方式一: RestTemplate -> queryItemById
[source,java]
----
public Item queryItemById(Long id) {
    return restTemplate.getForObject("http://app-item/item/" + id, Item.class);  // <1>
}
----

<1> app-item 是 service-item 在 Eureka 中注册的服务名。

====== 方式二: OkHttpClient -> queryItemByIdWithOkHttpClient -> OkHttpClient 本身不支持服务发现功能，需要自己实现负载均衡的调用
[source,java]
----
@Autowired
private LoadBalancerClient loadBalancerClient;

public Item queryItemByIdWithOkHttpClient(Long id) throws IOException {
    // 自己实现负载均衡的调用：使用 LoadBalancerClient 获取负载均衡的实例
    ServiceInstance instance = loadBalancerClient.choose("app-item");
    String actualUrl = "http://" + instance.getHost() + ":" + instance.getPort() + "/item/" + id;
    Request request = new Request.Builder().url(actualUrl).build();
    try (Response response = okHttpClient.newCall(request).execute()) {  // 执行 OkHttpClient 调用
        String json = response.body().string();  // 读取响应体
        // 使用注入的 objectMapper 反序列化成 JSON 字符串
        return objectMapper.readValue(json, Item.class);
    }
}
----

====== 方式三: WebClient -> queryItemByIdWithWebClient
[source,java]
----
public Item queryItemByIdWithWebClient(Long id) {
    return webClient.get()
                    .uri("/{id}", id)
                    .retrieve()
                    .bodyToMono(Item.class)
                    .block();
}
----

==== 7.4.5 file -> service-order/src/main/java/com/tjise/serviceorder/service/OrderService.java


===== Order queryOrderById
[source,java]
----
// 注入商品服务，用于查询商品详细信息
@Autowired
private ItemService itemService;
/**
 * 根据订单ID查询订单数据
 * @param orderId 订单ID
 * @return Order 订单信息，包含完整的商品详情
 */
public Order queryOrderById(String orderId) throws IOException {
    // 从模拟数据库中查询订单
    Order order = ORDER_DATA.get(orderId);
    if (null == order) {
        return null;
    }
    // 获取订单详情列表
    List<OrderDetail> orderDetails = order.getOrderDetails();
    // 遍历订单详情，通过商品微服务查询商品详细数据
    for (OrderDetail orderDetail : orderDetails) {
        // 通过商品微服务查询商品详细数据
        // Item item = itemService.queryItemById(orderDetail.getItem().getId());  // <1>
        // Item item = itemService.queryItemByIdWithOkHttpClient(orderDetail.getItem().getId());  // <2>
        Item item = itemService.queryItemByIdWithWebClient(orderDetail.getItem().getId());  // <3>
        if (null == item) {
            continue;
        }
        orderDetail.setItem(item);  // 将查询到的商品详细信息设置到订单详情中
    }
    return order;
}
----
<1> 使用 RestTemplate
<2> 使用 OkHttpClient
<3> 使用 WebClient

=== 7.5 Eureka 添加用户认证
在前面的示例中，我们可以看到不需要登录即可访问到 Eureka 服务，这样其实是不安全的。
所以需要为 Eureka 添加用户认证功能。

.加入用户认证功能后需要登录界面
image::img/eureka_login.png[,800]

.加入用户认证功能后依然可以注册成功
image::img/eureka_admin_with_user_and_pass.png[]

==== file -> eureka/pom.xml


===== security 安全认证依赖
[source,scss]
....
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
....

==== file -> eureka/src/main/resources/application.yml


===== server
[source,yaml]
----
server:
  port: 8761  # 1. Eureka Server端口设置为8761（默认端口）
----

===== spring -> new added
[source,yaml]
----
spring:
  application:
    name: app-eureka-center
  security:
    basic:
      enable: true  # 开启基于 HTTP basic 的认证
    user:  # 配置用户的账号信息
      name: root
      password: root
----

===== eureka -> new changed
[source,yaml]
----
eureka:
  instance:
    hostname: localhost  # 2. 设置主机名为localhost
  client:
    register-with-eureka: false  # 3. Eureka Server不向自己注册
    fetch-registry: false        # 4. Eureka 自己不需要获取服务注册信息
    service-url:
      # 5. 设置 Eureka Server 的访问地址
      # defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
      # 改成需要账号和密码的形式
      defaultZone: http://${spring.security.user.name}:${spring.security.user.password}@${eureka.instance.hostname}:${server.port}/eureka/
  server:
    enable-self-preservation: true  # 6. 关闭自我保护机制（开发环境建议关闭）
----

==== file -> eureka/src/main/java/com/tjise/eureka/conf/WebSecurityConfig.java


===== WebSecurityConfig 新建安全配置类
[source,java]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.NEVER)
            .and()
            .csrf().disable()
            .authorizeHttpRequests(authz -> authz
                    .anyRequest().authenticated()
            )
            .httpBasic(Customizer.withDefaults());
        return http.build();
    }
}
----

==== file -> service-item/src/main/resources/application.yml
****
name 和 instance 两者都有重要作用，缺一不可：

- spring.application.name：服务的逻辑名称，用于服务发现和负载均衡
- eureka.instance 配置：实例的网络地址，用于实际通信

即使使用 IP 注册，仍然需要服务名称来进行服务发现和调用。
****

===== port
[source,yaml]
----
### 服务端口号(本身是一个web项目)
server:
    port: 8081
----

===== name
[source,yaml]
----
### 起个名字作为服务名称(该服务注册到eureka注册中心的名称，比如商品服务)
spring:
    application:
        name: app-item
----

===== eureka
[source,yaml]
----
### 服务注册到eureka注册中心的地址
eureka:
    client:
        service-url:
            # defaultZone: http://127.0.0.1:8761/eureka/
            # 更改：加入用户名和密码
            defaultZone: http://root:root@127.0.0.1:8761/eureka/

        ### 因为该应用为服务提供者，是 eureka 的一个客户端，需要注册到注册中心
        register-with-eureka: true
        ### 是否需要从 eureka 上检索服务
        fetch-registry: true
    instance:
        prefer-ip-address: true  # 使用IP地址注册而不是主机名
        ip-address: 127.0.0.1    # 客户端在注册时使用自己的IP，而不是主机名。
                                 # 这是生产环境的最佳实践，避免主机名解析问题。
----

==== file -> service-order/src/main/resources/application.yml


===== port
[source,yaml]
----
server:
    port: 8082
----

===== name
[source, yaml]
----
# 起个名字作为服务名称(该服务注册到 eureka 注册中心的名称，比如订单服务)
spring:
    application:
        name: app-order
----

===== eureka
[source,yaml]
----
# 服务注册到 eureka 注册中心的地址
eureka:
    client:
        service-url:
            # defaultZone: http://127.0.0.1:8761/eureka/
            # 更改：加入用户名和密码
            defaultZone: http://root:root@127.0.0.1:8761/eureka/
        register-with-eureka: true  # 因为该应用为服务提供者，是 eureka 的一个客户端，需要注册到注册中心
        fetch-registry: true        # 是否需要从 eureka 上检索服务
    instance:
        prefer-ip-address: true     # 使用 IP地址 注册而不是主机名
        ip-address: 127.0.0.1       # 客户端在注册时使用自己的 IP，而不是主机名
                                    # 这是生产环境的最佳实践。避免主机名解析问题
----

=== 7.6 Eureka 集群（高可用性）
前面的测试发现，Eureka 服务是一个单点服务，在生产环境就会出现单点故障，为了确保 Eureka 服务的高可用，需要搭建 Eureka 服务的集群。

1. sudo vim /etc/hosts 增加 3 个主机名
+
[source,shell]
----
127.0.0.1 eureka1
127.0.0.1 eureka2
127.0.0.1 eureka3
----
2. 在 eureka 中创建 3 个配置文件: application-peer[1,2,3].yml
* defaultZone 配置多个地址在 Eureka 集群中的作用：
  ** 相互注册: 每个 Eureka Server 实例都需要知道集群中其他实例的地址，以便它们能够互相注册和同步服务注册信息。
    *** application-peer1.yml 中的这个配置告诉 eureka1 实例，它需要向 eureka2 和 eureka3 进行注册，并从它们那里获取服务注册信息。
    *** 同理，application-peer2.yml 会配置 eureka1 和 eureka3 的地址，application-peer3.yml 会配置 eureka1 和 eureka2 的地址。
  ** 高可用性: 通过相互注册，整个 Eureka 集群形成了一个去中心化的结构。即使其中一个 Eureka Server 实例宕机，其他实例仍然可以提供服务注册与发现功能，保证了服务的持续可用性。
  ** 信息同步: Eureka Server 实例之间会定期同步服务注册信息，确保所有实例上的服务列表保持一致。
  
3. 按下图在开发机器上配置 3 个 Eureka 服务的集群。
+
image::img/eureka_multi.png[]

4. 访问三个 eureka 管理端网址，查看注册情况。
+
http://localhost:8761/ | http://localhost:8762/ | http://localhost:8763/
+
.三个网址内容类似
image::img/eureka_multi_admin.png[]

TIP: 用户名: root 密码: root

5. 为了实现高可用性，service-item 和 service-order 应该像 Eureka Server 之间相互注册那样，将所有 Eureka Server 的地址都配置上。这样做可以确保即使其中一个 Eureka Server 实例宕机，服务仍然能够成功注册和发现其他服务，从而提高整个系统的可用性。
+
[source,yaml]
----
eureka:
    client:
        service-url:
            defaultZone: http://root:root@eureka1:8761/eureka/,http://root:root@eureka2:8762/eureka/,http://root:root@eureka3:8763/eureka/
        register-with-eureka: true
        fetch-registry: true
    instance:
        prefer-ip-address: true
        ip-address: 127.0.0.1
----

==== 配置 Eureka


===== file -> eureka/src/main/resources/application-peer2.yml
[source,yaml]
----
server:
  port: 8762

spring:
  application:
    name: eureka-server-clustered
  security:
    basic:
      enable: true
    user:
      name: root
      password: root

eureka:
  instance:
    hostname: eureka2
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://root:root@eureka1:8761/eureka/,http://root:root@eureka3:8763/eureka/
  server:
    enable-self-preservation: false
    # Eureka Server 的核心配置参数，用于控制服务失效实例的清理频率 10s。
    eviction-interval-timer-in-ms: 10000
----

===== file -> eureka/src/main/resources/application-peer1.yml
[source,yaml]
----
server:
  port: 8761

spring:
  application:
    name: eureka-server-clustered
  security:
    basic:
      enable: true
    user:
      name: root
      password: root

eureka:
  instance:
    hostname: eureka1
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://root:root@eureka2:8762/eureka/,http://root:root@eureka3:8763/eureka/
  server:
    enable-self-preservation: false
    # Eureka Server 的核心配置参数，用于控制服务失效实例的清理频率 10s。
    eviction-interval-timer-in-ms: 10000
----

===== file -> eureka/src/main/resources/application-peer3.yml
[source,yaml]
----
server:
  port: 8763

spring:
  application:
    name: eureka-server-clustered
  security:
    basic:
      enable: true
    user:
      name: root
      password: root

eureka:
  instance:
    hostname: eureka3
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://root:root@eureka1:8761/eureka/,http://root:root@eureka2:8762/eureka/
  server:
    enable-self-preservation: false
    # Eureka Server 的核心配置参数，用于控制服务失效实例的清理频率 10s。
    eviction-interval-timer-in-ms: 10000
----

===== 反例: 创建 nginx 容器实现访问 Eureka 3 台服务器集群的负载均衡（会引入 nginx 单点故障问题）
.创建 nginx 容器
[source,console]
----
docker run -d --name nginx \
-p 80:80 \
-p 8760:8760 \
-v ./eureka.conf:/etc/nginx/conf.d/eureka.conf \
nginx
----

NOTE: 使用命令行可以同时映射多个端口。docker desktop GUI 客户端无法映射多个端口。

***

WARNING: nginx 出现单点故障，则整个 Eureka 集群无法访问。所以这种方式用的很少。


.好好理解一下
****
- **Eureka 自己带了客户端负载均衡思想**

  - 客户端直接配置多台 `Eureka Server`，会自动轮询、重试。
  - 集群节点之间数据同步，不需要额外中间层。

- **Nginx 放在这里反而引入了单点**

  - Eureka 是 peer-to-peer 对等架构，本来就没有“主从”问题。
  - 加个 Nginx 只会让本来不需要的层变成潜在风险点。

- **现在更清楚 Nginx 的定位**

  - 它更适合放在 **网关层**（对外入口），做统一访问、鉴权、流量控制。
  - 不适合放在 **注册中心层**。
****

====== file -> eureka/src/main/resources/eureka.conf
[source,python]
----
upstream eureka-cluster {
    server host.docker.internal:8761;
    server host.docker.internal:8762;
    server host.docker.internal:8763;
}

server {
    listen 8760;
    location / {
        proxy_pass http://eureka-cluster;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
----

要让容器里的 Nginx 把请求转发到“宿主机上的 Eureka”，就得用宿主机在 Docker 网络中的地址。 +
Docker 已经预留了一个特殊 DNS 名：host.docker.internal +
它自动解析成宿主机在 Docker 网桥里的 IP。

访问 http://localhost:8760/ 会按 nginx 默认的负载均衡访问 3 台 Eureka 服务器。

==== 配置 微服务(2个)


===== file -> service-item/src/main/resources/application.yml
****
name 和 instance 两者都有重要作用，缺一不可：

- spring.application.name：服务的逻辑名称，用于服务发现和负载均衡
- eureka.instance 配置：实例的网络地址，用于实际通信

即使使用 IP 注册，仍然需要服务名称来进行服务发现和调用。
****

====== port
[source,yaml]
----
### 服务端口号(本身是一个web项目)
server:
    port: 8081
----

====== name
[source,yaml]
----
### 起个名字作为服务名称(该服务注册到eureka注册中心的名称，比如商品服务)
spring:
    application:
        name: app-item
----

====== eureka
[source,yaml]
----
### 服务注册到 eureka 注册中心的地址
eureka:
    client:
        service-url:
            # defaultZone: http://root:root@127.0.0.1:8761/eureka/
            defaultZone: http://root:root@eureka1:8761/eureka/,http://root:root@eureka2:8762/eureka/,http://root:root@eureka3:8763/eureka/
        register-with-eureka: true # 因为该应用为服务提供者，是 eureka 的一个客户端，需要注册到注册中心
        fetch-registry: true       # 是否需要从 eureka 上检索服务

    instance:
        prefer-ip-address: true    # 使用IP地址注册而不是主机名
        ip-address: 127.0.0.1      # 客户端在注册时使用自己的IP，而不是主机名。
                                   # 这是生产环境的最佳实践，避免主机名解析问题。
----

===== file -> service-order/src/main/resources/application.yml


====== port
[source,yaml]
----
server:
    port: 8091
----

====== name
[source, yaml]
----
# 起个名字作为服务名称(该服务注册到 eureka 注册中心的名称，比如订单服务)
spring:
    application:
        name: app-order
----

====== eureka
[source,yaml]
----
# 服务注册到 eureka 注册中心的地址
eureka:
    client:
        service-url:
            # defaultZone: http://root:root@127.0.0.1:8761/eureka/
            defaultZone: http://root:root@eureka1:8761/eureka/,http://root:root@eureka2:8762/eureka/,http://root:root@eureka3:8763/eureka/
        register-with-eureka: true  # 因为该应用为服务提供者，是 eureka 的一个客户端，需要注册到注册中心
        fetch-registry: true        # 是否需要从 eureka 上检索服务
    instance:
        prefer-ip-address: true     # 使用 IP地址 注册而不是主机名
        ip-address: 127.0.0.1       # 客户端在注册时使用自己的 IP，而不是主机名
                                    # 这是生产环境的最佳实践。避免主机名解析问题
----

==== 测试高可用性


===== 1. httpie 测试
[source,console]
----
http :8091/order/201810300001
----
+
....
HTTP/1.1 200
Connection: keep-alive
Content-Type: application/json
Date: Mon, 22 Sep 2025 16:32:37 GMT
Keep-Alive: timeout=60
Transfer-Encoding: chunked

{
    "createDate": "2025-09-22T16:30:20.174+00:00",
    "orderDetails": [
        {
            "item": {
                "desc": "商品描述1",
                "id": 1,
                "pic": "http://图片1",
                "price": 1000,
                "title": "商品1"
            },
            "orderId": "201810300001"
        },
        {
            "item": {
                "desc": "商品描述2",
                "id": 2,
                "pic": "http://图片2",
                "price": 2000,
                "title": "商品2"
            },
            "orderId": "201810300001"
        }
    ],
    "orderId": "201810300001",
    "updateDate": "2025-09-22T16:30:20.174+00:00",
    "userId": 1
}
....

===== 2. 停止一个 eureka 服务再测试
停掉端口为 8761 的 eureka 服务，再测试应该还是能正常访问的。

===== 3. 创建新订单再测试
为了防止是缓存的效果，再创建一个订单 order2，如下。

====== file -> service-order/src/main/java/com/tjise/serviceorder/service/OrderService.java


====== class OrderService
/**
 * 订单服务类
 * 提供订单查询功能，并通过调用商品服务获取商品详细信息
 */
@Service
public class OrderService {
    @others
}

====== ORDER_DATA 模拟数据
// 使用静态Map模拟数据库存储订单数据
private static final Map<String, Order> ORDER_DATA = new HashMap<String, Order>();
// 初始化订单数据
static {
    // 模拟数据库，构造测试数据
    @others
}

====== 第一个订单 order
Order order = new Order();
order.setOrderId("201810300001");
order.setCreateDate(new Date());
order.setUpdateDate(order.getCreateDate());  // 真会偷懒呀
order.setUserId(1L);
List<OrderDetail> orderDetails = new ArrayList<OrderDetail>();

// 创建第一个商品详情（仅保存商品ID，需要调用商品微服务获取详细信息）
Item item = new Item();
item.setId(1L);
orderDetails.add(new OrderDetail(order.getOrderId(), item));

// 创建第二个商品详情
item = new Item();
item.setId(2L);
orderDetails.add(new OrderDetail(order.getOrderId(), item));

order.setOrderDetails(orderDetails);

ORDER_DATA.put(order.getOrderId(), order);

====== 第二个订单 order2
Order order2 = new Order();
order2.setOrderId("201810300002");
order2.setCreateDate(new Date());
order2.setUpdateDate(order.getCreateDate());  // 真会偷懒呀
order2.setUserId(2L);
List<OrderDetail> orderDetails2 = new ArrayList<OrderDetail>();

// 创建第一个商品详情（仅保存商品ID，需要调用商品微服务获取详细信息）
Item item2 = new Item();
item2.setId(3L);
orderDetails2.add(new OrderDetail(order2.getOrderId(), item2));

// 创建第二个商品详情
item2 = new Item();
item2.setId(4L);
orderDetails2.add(new OrderDetail(order2.getOrderId(), item2));

order2.setOrderDetails(orderDetails2);

ORDER_DATA.put(order2.getOrderId(), order2);

====== queryOrderById
// 注入商品服务，用于查询商品详细信息
@Autowired
private ItemService itemService;
/**
 * 根据订单ID查询订单数据
 * 
 * @param orderId 订单ID
 * @return Order 订单信息，包含完整的商品详情
 */
public Order queryOrderById(String orderId) throws IOException {
    // 从模拟数据库中查询订单
    Order order = ORDER_DATA.get(orderId);
    if (null == order) {
        return null;
    }
    // 获取订单详情列表
    List<OrderDetail> orderDetails = order.getOrderDetails();

    // 遍历订单详情，通过商品微服务查询商品详细数据
    for (OrderDetail orderDetail : orderDetails) {
        // 通过商品微服务查询商品详细数据
        Item item = itemService.queryItemById(orderDetail.getItem().getId());
        if (null == item) {
            continue;
        }
        // 将查询到的商品详细信息设置到订单详情中
        orderDetail.setItem(item);
    }
    return order;
}

===== 4. 重启 service-order 后，httpie 测试:
[source,console]
----
http :8091/order/201810300002
----
+
.测试结果说明 Eureka 高可用无问题
....
HTTP/1.1 200
Connection: keep-alive
Content-Type: application/json
Date: Mon, 22 Sep 2025 16:31:11 GMT
Keep-Alive: timeout=60
Transfer-Encoding: chunked

{
    "createDate": "2025-09-22T16:30:20.175+00:00",
    "orderDetails": [
        {
            "item": {
                "desc": "商品描述3",
                "id": 3,
                "pic": "http://图片3",
                "price": 3000,
                "title": "商品3"
            },
            "orderId": "201810300002"
        },
        {
            "item": {
                "desc": "商品描述4",
                "id": 4,
                "pic": "http://图片4",
                "price": 4000,
                "title": "商品4"
            },
            "orderId": "201810300002"
        }
    ],
    "orderId": "201810300002",
    "updateDate": "2025-09-22T16:30:20.174+00:00",
    "userId": 2
}
....

