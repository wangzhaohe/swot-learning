:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:toc:
:toc: right
:toc-title: Table of Contents
:toclevels: 3

= Q_and_A

++++
<button id="toggleButton">Table of Contents</button>
<script>
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () => {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
</script>
++++

== Nuxt3


=== utils vs composables?
Nuxt 3 中 composables/ 与 utils/ 的区别与用法整理

.概览对比
[cols="1,2,3,4", options="header"]
|===
|目录
|是否自动导入
|推荐用途
|说明

|composables/
|✅ 是
|组合式逻辑（响应式状态）
|封装使用 Vue/Nuxt API 的函数，如 `useFetch`、`ref`、`useState` 等。适合响应式和生命周期相关逻辑。

|utils/
|✅ 是（Nuxt 3.5+）
|通用工具函数
|封装纯函数，不依赖 Vue/Nuxt 上下文。适合处理字符串、日期、数学计算等通用逻辑。
|===

.composables 示例
[source,javascript]
----
export function useUser(userId: string) {
  return useFetch(`/api/users/${userId}`)
}
----

.自动导入使用示例：
[source,javascript]
----
const { data, pending, error } = useUser('abc123')
----

.utils 示例
[source,javascript]
----
export function formatDate(date: Date): string {
  return date.toISOString().split('T')[0]
}
----

.自动导入使用示例（Nuxt 3.5+）：
[source,javascript]
----
const today = formatDate(new Date())
----

.使用场景对比
[cols="1,1", options="header"]
|===
|适合放在 composables/
|适合放在 utils/

|需要响应式状态逻辑：如 `useAuth()`、`useTheme()`、`useXxxFetch()`
|纯函数：如 `formatDate()`、`slugify()`、`trimText()`

|依赖 Vue/Nuxt API，如 `useRoute()`、`useHead()`、`useAsyncData()`
|无任何 Vue/Nuxt 上下文依赖的逻辑

|与组件或页面状态紧密相关
|可在任何 JS 环境中
|===

=== app.config.ts vs nuxt.config.ts?
https://nuxt.com/docs/getting-started/configuration#runtimeconfig-vs-appconfig

== Web


=== http   body 3 种上传数据方式有什么不同？
[discrete]
=== Postman Body 数据传递方式总结

在 Postman 中发送请求时，`Body` 部分常用的三种数据格式包括：

[discrete]
==== 1. form-data

- Content-Type: `multipart/form-data`
- 用途：
  * 多用于表单数据提交
  * 支持上传文件
- 数据结构：键值对，每个字段单独处理
- 使用场景：带文件的表单上传（如头像）

[discrete]
==== 2. x-www-form-urlencoded

- Content-Type: `application/x-www-form-urlencoded`
- 用途：
  * 传统 Web 表单提交方式
  * 不支持文件，仅传普通键值对
- 数据结构：`key1=value1&key2=value2` 形式
- 使用场景：简单表单提交，如登录表单

[discrete]
==== 3. raw - JSON

- Content-Type: `application/json`
- 用途：
  * RESTful 接口推荐格式
  * 支持嵌套结构（对象、数组等）
- 数据结构：纯 JSON 格式
- 使用场景：现代前后端分离架构的接口交互

.对比表格
[cols="2,2,1,1,2", options="header"]
|===
| 类型
| Content-Type
| 支持文件
| 支持结构化
| 常见使用场景

| form-data
| multipart/form-data
| 是
| 否
| 表单提交、文件上传

| x-www-form-urlencoded
| application/x-www-form-urlencoded
| 否
| 否
| 登录、注册等传统表单

| raw - JSON
| application/json
| 否
| 是
| 前后端交互的 API 接口
|===

=== httpie body 3 种上传数据方式如何使用？
[discrete]
==== 1. multipart/form-data 上传文件（form-data）

[source,shell]
----
http --form POST https://example.com/upload name=ChatGPT file@./image.png
----

说明：

- 使用 `-f --form` 参数
    * 如果传入了文件就是 `multipart/form-data`
    * 否则是 application/x-www-form-urlencoded
- 使用 `--multipart` 参数则始终是 `multipart/form-data`
- `name=ChatGPT` 是普通字段
- `file@./image.png` 表示上传文件

.自动设置的请求头：
[source,text]
----
Content-Type: multipart/form-data; boundary=...
----

常用于表单上传或文件上传接口。

[discrete]
==== 2. application/x-www-form-urlencoded 提交表单数据

.使用 -f 或 --form
[source,shell]
----
http --form POST https://example.com/login username=admin password=123456
----

说明：

- 使用 `--form` 参数启用 `x-www-form-urlencoded`
- 所有字段以 `key=value` 格式发送

.自动设置的请求头：
[source,text]
----
Content-Type: application/x-www-form-urlencoded
----

适用于传统 Web 表单提交（如登录、注册等）。

[discrete]
==== 3. application/json 提交 JSON 数据

默认情况下，不加 `-f` 或 `--form`，HTTPie 自动使用 JSON：

[source,shell]
----
http POST https://example.com/api name=ChatGPT role=assistant
----

.也可以显式指定请求头：
[source,shell]
----
http POST https://example.com/api Content-Type:application/json name=ChatGPT role=assistant
----

发送的数据将被自动序列化为 JSON：

[source,json]
----
{
  "name": "ChatGPT",
  "role": "assistant"
}
----

.自动设置的请求头：
[source,text]
----
Content-Type: application/json
----

适用于现代前后端分离的 API 接口。

[discrete]
==== 三种格式对比表

[cols="1,2,1", options="header"]
|===
| 格式
| 示例命令
| Content-Type

| form-data
| `http --form POST URL key=value file@file`
| multipart/form-data

| x-www-form-urlencoded
| `http --form POST URL key=value`
| application/x-www-form-urlencoded

| JSON
| `http POST URL key=value`
| application/json
|===

=== httpie 如何显示请求和响应部分的数据
可以使用 `--print` 参数来控制 HTTPie 显示请求和响应的哪些部分。

[discrete]
==== 显示请求和响应的全部内容

```bash
http --print=HBhb POST https://example.com/api name=ChatGPT
```

说明：

* `H`：请求头（Request headers）
* `B`：请求体（Request body）
* `h`：响应头（Response headers）
* `b`：响应体（Response body）

[discrete]
==== 只查看发送的请求（不显示响应）

```bash
http --print=HB POST https://example.com/api name=ChatGPT
```

这将显示：

* 请求头
* 请求体

不会显示响应部分。

[discrete]
==== 示例输出（请求部分）

```text
POST /api HTTP/1.1
Accept: application/json, */*
Content-Type: application/json
User-Agent: HTTPie/3.0.0

{
    "name": "ChatGPT"
}
```

[discrete]
==== 仅调试请求而不发送

使用 `--offline` 模拟请求但不发送，可用于本地调试：

```bash
http --offline --print=HB POST https://example.com/api name=ChatGPT
```

[discrete]
==== 快捷选项

* `--verbose` 或 `-v` 相当于 `--print=HhBb`，即显示完整请求和响应内容。

=== Web 配色网站哪个好用？
https://mycolor.space/
这个配色网站很棒，还支持 3-color-gradient

=== css
css汇总： https://github.com/dbohdan/classless-css

Pico.css 好不好？

* https://github.com/picocss/pico
* https://picocss.com/

=== Web 新框架
1. Svelte: 不用虚拟 dom，比 react 更好写。

2. Web Component: 代表有 Lit。

3. htmx: 原始风

== Chrome


=== 打开开发者控制台模式的快捷键是什么？
macOS: Cmd + Option + J 直接打开到 Console 面板

Windows/Linux: Ctrl + Shift + J 直接打开到 Console 面板

== macos


=== 2026-02-14 macos idleassetsd 疯狂下载屏保视频问题
使用 macos 的用户遇见了比较让人恼火的事，本来硬盘就不大，apple 还使劲往硬盘里下载屏保视频，在我的电脑上下载了 15 个G，杀都杀不掉，太不像话了！下载的目录： +
'/Library/Application Support/com.apple.idleassetsd/Customer/4KSDR240FPS'

* 方案：问 apple 客服，回复说无法解决，等待下个系统更新，看有没有改善，这……

* 方案： cuplimit 限速
+
.使用 cpulimit 限制下载速率（存在问题，过一会儿 idleassetsd 自己就杀死自己了，再重启换了一个系统id，太……）
[source,console]
----
> sudo cpulimit -e idleassetsd -l 1 -z
Password:
Process 19196 found
----

* 方案：firewall LuLu +
限制进程 idleassetsd 是可行的。但是如果开启了代理，又不行了，因为流量走代理了。总不能把代理也关了吧。

* **方案：使用代理 Clash Verge 限制访问 apple 的屏保资源（目前可行）**

==== Clash Verge 限制访问 apple 屏保资源
1. 开启 TUN 模式：虚拟网上模式
+
image::img/ClashVerge-TUN.png[]
+
image::img/ClashVerge-TUN-system.png[,520]

2. 启用 DNS fake-ip 功能
+
image::img/ClashVerge-DNS.png[]

3. 全局扩展覆写配置
+
image::img/ClashVerge-global-edit.png[]
+
image::img/ClashVerge-global-edit-content.png[]
+
[source,yaml]
----
# Profile Enhancement Merge Template for Clash Verge
profile:
  store-selected: true

prepend-rules:
  - PROCESS-NAME,idleassetsd,REJECT
  - DOMAIN-SUFFIX,sylvan.apple.com,REJECT
  - DOMAIN-SUFFIX,desktop-assets.apple.com,REJECT
  - DOMAIN-KEYWORD,assets.itunes.apple,REJECT
  - DOMAIN,sylvan.apple.com,REJECT

  # GitHub 规则：确保 Git 走代理
  - DOMAIN-SUFFIX,github.com,PROXY
  - DOMAIN-KEYWORD,github,PROXY
  
  # Gemini 规则：确保 Gemini 走支持的节点（如美国、新加坡）
  - DOMAIN-SUFFIX,gemini.google.com,PROXY
  - DOMAIN-KEYWORD,googleai,PROXY
----

=== 2026-02-14 macos 无法 ssh github 问题
有时候因为 dns 污染了，或者代理就是不让发 ssh，从而导致无法使用 ssh 来和 github 交互。这时候转换成 https 去使用 github 吧。

.改成使用 https 的方式
[source,console]
----
git remote set-url origin https://github.com/wangzhaohe/swot-learning.git
----

.强制 Git 走本地的 7897 代理端口出去（根据自己的代理情况而定）
[source,console]
----
# 设置 HTTP 代理
git config --global http.proxy http://127.0.0.1:7897

# 设置 HTTPS 代理
git config --global https.proxy http://127.0.0.1:7897
----

`git push` 推送时输入用户名和密码（github 要求密码要是 token 才行，参下面获取说明）。

进入 github 的全局设置中，创建 tokens，用它当作密码来确认登录。
https://github.com/settings/tokens

image::img/github_tokens-classic.png[]

==== https 方式推送时报 RPC failed HTTP 400
....
> git push
Enumerating objects: 17, done.
Counting objects: 100% (17/17), done.
Delta compression using up to 12 threads
Compressing objects: 100% (12/12), done.
error: RPC failed; HTTP 400 curl 22 The requested URL returned error: 400
send-pack: unexpected disconnect while reading sideband packet
Writing objects: 100% (12/12), 1.14 MiB | 1.78 MiB/s, done.
Total 12 (delta 4), reused 0 (delta 0), pack-reused 0 (from 0)
fatal: the remote end hung up unexpectedly
Everything up-to-date
....

RPC failed; HTTP 400	The server didn't understand the request (often because it was too large). +
所以放大 postBuffer 试试，我成功了。

[source,console]
----
git config --global http.postBuffer 524288000
git push //成功
----

== neovim


=== 2026-02-14 How to install LazyVim?
https://github.com/LazyVim/LazyVim

LazyVim 是目前最成熟的配置框架，它的作者已经处理好了所有版本兼容性问题。

1. 清空现有配置（备份后删除）：
+
[source, console]
----
rm -rf ~/.config/nvim ~/.local/share/nvim ~/.local/state/nvim ~/.cache/nvim
----

2. 一键克隆官方模版：
+
[source,java]
----
git clone https://github.com/LazyVim/starter ~/.config/nvim
----

3. 启用 Svelte 支持

* 打开 nvim，按 <leader>x（通常是空格+x）或者输入 :LazyExtras
* 找到 lang.svelte 和 lang.typescript，按 x 选中即可。
* 按下 I (大写) 进行安装。
+
它会自动帮你配好 0.10 或 0.11 下最稳定的解析器。

.官网参考
****
https://www.lazyvim.org/
****

