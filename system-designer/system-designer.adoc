:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:toc:
:toc: right
:toc-title: 目录
:toclevels: 3
:tip-caption: ⚡
:note-caption: ❕
:important-caption: ❗
:warning-caption: ‼️
:caution-caption: ⚠️

= 系统架构设计师

++++
<button id="toggleButton">目录开关</button>
<script>
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () => {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
</script>
++++

== 2026-02-13 全栈架构模式：从宏观到微观的 MVC 映射及前端 MVVM
[discrete]
=== 全栈架构核心笔记

[abstract]
将 “Svelte 前端 + Spring Boot 后端” 构成的系统，拆解为宏观 MVC、后端内部 MVC 与前端 MVVM 三层逻辑，实现职责的彻底分离。

=== 1. 宏观视角：系统级 MVC (System Level)

从整体看，前端是 UI，后端是逻辑与数据的提供者。

[cols="1,2,3", options="header"]
|===
| 维度 | 对应技术栈 | 核心职责
| M (Model) | Spring Boot (Service + Mapper) | **系统大脑**：业务逻辑、数据持久化、单一事实来源
| C (Controller) | Spring Boot (API Layer) | **交通枢纽**：路由分发、参数解析、指挥 Service、返回 JSON。
| V (View) | Svelte (Pages + Stores + api fetch) | **系统面孔**：数据渲染、交互监听、将意图转化为 API 请求。
|===

[discrete]
==== 宏观数据流向 (The Flow)

// 如果不是在 GitHub 环境（即本地渲染），执行 Mermaid 脚本
ifndef::env-github[]
[mermaid, target=img/mermaid-2026-02-13-131950, format=svg]
....
graph LR
    User((用户)) -- 点击保存 --> V[View: Svelte]
    V -- HTTP Request --> C[Controller: Spring]
    C -- 指挥调度 --> M_S[Model: Service + Mapper]
    M_S -- 持久化 --> M_D[(Database)]

    M_S -- 返回结果 --> C
    C -- JSON Response --> V
    V -- 更新 UI --> User
....
endif::[]

// 如果是在 GitHub 环境，引用你已经上传的图片
ifdef::env-github[]
image::img/mermaid-2026-02-13-131950.svg[]
endif::[]

=== 2. 后端视角：Spring Boot 内部 MVC
深入后端代码，拆解“主厨”与“前台”的配合。

* **M (Model) = 业务逻辑 + 数据访问**
** *Service 层 (@Service)*：**主厨**。负责计算、校验、事务控制（如：`userService.register()`）。
** *Mapper 层 (@Mapper)*：**库管**。负责搬运数据，执行 SQL。
** *Entity/DTO*：**食材**。在 Service 和 Mapper 之间传递的数据包。

* **C (Controller) = 请求调度**
** *RestController*：**前台服务员**。不干脏活，解析 URL 后只喊一句：“后厨，来活了！”

* **V (View) = 数据呈现**
** *JSON 响应*：**摆盘**。后端不画 HTML，生成的 **JSON 字符串** 就是它提供给外界的视图。

=== 3. 前端视角：Svelte 内部 MVVM
前端通过状态驱动（Reactive）来治理复杂的交互逻辑。

[horizontal]
**V (View)** :: **组件 (+page.svelte)**。像“顾客”，只负责绑定数据和触发事件。它是“愚笨”的，不关心后端细节。

**VM (ViewModel)** :: **状态管理 (store.svelte.ts)**。像“大堂经理”，持有 `$state`，封装前端处理逻辑，并通过 fetch 调用  API

**M (Model)** :: **数据源代理 (operations.ts)**。像“快递员”，定义 TS 接口，负责发起真正的 fetch/axios 请求。

=== 4. 架构总结及思考
.核心记忆口诀
[TIP]
====
* **后端 M 是个组合拳**：M = Service(脑) + Mapper(手)。
* **后端 C 是个传话筒**：只负责转发，不负责思考。
* **前端 VM 是个管家**：Store 帮 View 屏蔽了所有复杂的异步 API 细节。
====

[sidebar]
--
*思考题*：如果我要更换数据库，应该改哪一层？ +
*答案*：只改 **Model (Mapper)** 层，Controller 和 View 理论上完全不需要感知。
--

== 2026-02-14 开发语言解惑汇总


=== 1. 编程语言执行机制与性能哲学


==== 1.1 Lua：极致的嵌入式胶水
* **核心定位：** Lua 被设计为极简的解释型语言，专门用于嵌入 C/C++ 或 Rust 编写的编译型主程序中。

* **极低开销：** Lua 的虚拟机非常小巧（只有几百 KB），内存占用极低，这让它成为嵌入到 C/C++ 程序中的首选。

* **弥补缺陷：** 解决编译型语言“修改即需重新编译”的痛点，提供动态逻辑控制。

* **游戏逻辑：** 在游戏开发中，底层引擎用 C++ 写，但角色的 AI 行为、关卡触发器通常是用 Lua 写的。

* **特殊用途：** 动态语言在特殊情况下也会使用 Lua
    ** 性能考量（LuaJIT）： LuaJIT 是世界上最快的动态语言解释器之一。如果一个 Python 项目中有某些高频计算逻辑（但又不想写复杂的 C 扩展），有时会调用 Lua 来提速。
    ** 沙箱环境（安全性）： 这是 Lua 的杀手锏。如果你在 Python 应用中允许用户上传并运行脚本（比如插件系统），直接运行 Python 脚本很难限制用户的权限（用户可能会删你磁盘文件）。而 Lua 极其容易被限制在一个安全的“沙箱”里，无法访问系统资源。
    ** 跨平台逻辑复用： 比如你的游戏底层逻辑是用 Lua 写的，那么无论前端是用浏览器（JS）还是桌面端工具，都可以共用这一套 Lua 代码。

==== 1.2 编译、解释与 JIT 的三角关系
* **JavaScript (JS)：** 为了跨平台和网络分发而采用源码传输。比如 Chrome 浏览器的现代引擎（V8）使用 **JIT (Just-In-Time)** 在运行时将热点代码转为机器码。
    ** 跨平台与碎片化（最大的障碍）： 浏览器环境极其复杂。Chrome、Safari、Firefox 都有不同的内核，且运行在 Windows、Android、iOS 等各种硬件架构上。如果 JS 是编译后的二进制文件，开发者就得像发布安卓 App 或 Windows 软件一样，为每个平台编译一个版本。目前的 JS 代码（文本）由浏览器实时解析，确保了**“一份代码，到处运行”**。
    ** 网络传输效率： 编译后的二进制文件往往比压缩后的文本（Gzip/Brotli）大得多。在 Web 早期，带宽极其珍贵，传输文本更高效。
    ** 安全性： 浏览器是一个高度受限的“沙箱”。如果执行预编译的代码，浏览器很难实时监控代码是否在非法操作内存，安全性会大打折扣。
    ** 当前的“中间方案”： 实际上，现代浏览器已经进化了。它们不再是简单的“逐行解释”，而是采用了 JIT (Just-In-Time) 编译技术。
    ** 现在的做法是： JS 代码以文本形式传给浏览器，浏览器在运行过程中，把经常执行的热点代码直接编译成机器码。这兼顾了文本传输的灵活性和编译语言的高性能。

* **Java：** 属于“先编译、后解释、再 JIT”的混合语言。源码转为平台无关的**字节码**，由 JVM 执行。JIT 优化使其后期性能接近 C++。
    ** 第一阶段：编译（Compile）
        *** 开发者写完 .java 源代码后，使用 javac 命令进行编译。但它生成的不是 CPU 能直接读懂的机器码，而是 字节码（Bytecode，即 .class 文件）。
        *** 特点： 字节码是平台无关的，它不针对特定的 CPU。
    ** 第二阶段：解释与执行（Runtime）
        *** 当你在电脑上运行 Java 程序时，JVM（Java 虚拟机） 登场了。
        *** 解释： JVM 逐行读取字节码并将其翻译成当前机器的指令。
        *** JIT 编译： JVM 非常聪明，如果它发现某段代码运行了很多次，它会直接把这段字节码编译成机器码并缓存起来，下次直接运行，速度飞快。

* **Python：** 标准实现（CPython）也是字节码，但缺乏原生 JIT，且受限于**动态类型**的运行时检查，性能较差。

* **PyPy：** 带有 JIT 的 Python 实现，虽快但受限于 **C 扩展（C-API）兼容性**，未能在 AI 领域取代 CPython。
    ** 兼容性天敌（C 扩展）： Python 强大的核心在于它的生态（NumPy, Pandas, PyTorch）。这些库是用 C 语言写的。PyPy 运行纯 Python 代码极快，但在调用这些 C 扩展时，会有巨大的转换开销，甚至比标准 Python 还慢。
    ** 部署成本： 很多企业级应用更看重稳定性。标准 CPython 简单可靠，而 PyPy 的 JIT 内存占用更高，且偶尔会有难以预料的性能波动（JIT 预热过程）。

==== 1.3 为什么 AI 偏爱 Python 而非 Java？
* **性能错位：** AI 的重型矩阵运算在底层 C++/CUDA 中完成，Python 仅作为“指挥官”。
* **开发体验：** Python 语法更符合数学家思维（简洁、像数学公式）。
* **内存管理：** Java 的 **GC (垃圾回收)** 机制在处理海量张量数据时容易产生停顿，且 Java 的强类型在实验性开发中显得繁琐。

NOTE: 虽然 Java 在 AI 训练 领域不行，但在 大数据处理（Hadoop, Spark）和 企业级推理（将模型部署到后端）领域，Java 依然是主力。

=== 2. Web 图形与计算架构演进


==== 2.1 WebAssembly (WASM)
* **本质：** 一种低级、类汇编的二进制指令格式，作为 C++/Rust 等语言在浏览器的运行目标。

    ** 它的本质： 它不是一种像 Python 那样的编程语言，而是一种低级的类汇编格式。它可以让 C++、Rust、Go 等高性能语言编译后的代码，直接在浏览器中运行。
    ** 为什么需要它： JS 虽然有 JIT 优化，但在处理视频剪辑、3D 游戏、复杂物理计算时仍然显得吃力。WASM 接近原生机器码的执行速度，且加载速度极快。
    ** 它会取代 JS 吗？ 不会。WASM 负责“重体力活”（算法、渲染），JS 负责“胶水工作”（UI 交互、DOM 操作）。

* Three.js 使用了 WebAssembly 技术吗？
    ** Three.js 核心： 依然是纯 JavaScript。因为它主要负责 3D 场景的组织、材质管理和 WebGL 接口调用。对于大多数 UI 交互，JS 的性能已经足够。
    ** WebAssembly 的引入： 当遇到“重体力活”时，Three.js 会引入 WASM。
        *** 物理引擎： 比如 Ammo.js（Bullet 物理引擎的移植版）通常以 WASM 形式运行，处理碰撞检测、重力模拟等极高频计算。
        *** 模型解码： 比如 Draco 压缩格式的 3D 模型，解码过程是在 WASM 中完成的，比纯 JS 快得多。

* **辨析：** 它与 **Web 3.0** 无直接技术归属关系（前者是性能标准，后者是去中心化架构），但常被 Web3 用作高效的合约运行环境。
    ** 如很多 Web 3.0 的项目（比如以太坊 2.0 的虚拟机 eWASM）使用 WebAssembly 作为合约运行的底层引擎。因为 WASM 足够快、足够安全且跨平台。

==== 2.2 从 WebGL 到 WebGPU 的跨越
* **WebGL：** 基于陈旧的状态机架构，CPU 开销巨大（Draw Call 限制）。在 2026 年已退居为“兼容性保留层”。
    ** WebGL (基于 OpenGL ES)： 它是 20 年前的技术架构。它的问题在于状态机模式——每画一个物体都要频繁地在 CPU 和 GPU 之间切换状态，这造成了极大的开销（CPU 瓶颈）。
    ** 目前还有大量的旧设备在使用 WebGL。
    ** WebGL 已经停止更新。

* **WebGPU：** 现代图形 API 标配。

* **优势：** 减少 CPU 负担，支持 **Compute Shader**（计算着色器），可用于 GPU 通用计算（Web AI）。

* **Three.js：** 核心虽是 JS，但已通过 `WebGPURenderer` 实现 WebGPU 支持，并能自动降级兼容 WebGL。
    ** Three.js 在 r171 版本之后，正式将 WebGPURenderer 提升为生产就绪状态。
    ** 无缝切换： 你只需要把传统的 WebGLRenderer 换成 WebGPURenderer，Three.js 会自动把你的材质和几何体转换成 WebGPU 指令。
    ** 混合模式： 如果用户的显卡太旧不支持 WebGPU，Three.js 还会自动降级回 WebGL。

==== 2.3 Three.js / Unity / UE 技术选型深度对比
在 2026 年的技术环境下，选择这三个工具本质上是在 **“网页原生性”**、**“全平台平衡性”** 与 **“极致视觉性能”** 之间做取舍。

===== 2.3.1 核心定位与技术栈概览
[cols="1,2,2,2", options="header"]
|===
| 特性 | Three.js | Unity | Unreal Engine (UE)

| **本质定位**
| 轻量级 Web 3D 渲染库
| 综合性跨平台游戏引擎
| 顶级高保真 AAA 级引擎

| **编程语言**
| JavaScript / TypeScript
| C#
| C++ / 蓝图 (Visual Scripting)

| **运行环境**
| 浏览器原生 (Web/WebGPU)
| 客户端 + WebGL 导出
| 客户端 (PC/主机/像素流)

| **学习曲线**
| **平缓** (前端开发者友好)
| **中等** (适合系统化开发)
| **陡峭** (硬件与底层要求高)
|===

===== 2.3.2 三者深度解析


====== 2.3.2.1 Three.js：网页端的“无冕之王”
如果您追求的是 **网站交互、数据可视化或轻量级 Web 应用**，它是最优解。

* **优势**：
    ** **零安装成本**：Bundle 极小（通常 < 1MB），用户即开即看。
    ** **前端生态融合**：与 React (R3F) 或 Svelte (Threlte) 完美结合。
    ** **WebGPU 原生支持**：在 2026 年已全面普及，能榨干浏览器渲染性能。
* **劣势**：它仅是渲染库，物理引擎、碰撞检测等核心功能需依赖第三方插件拼凑。

====== 2.3.2.2 Unity：全能的“斜杠青年”
Unity 是 **中小团队、移动端游戏和跨平台应用** 的标准答案。

* **优势**：
    ** **多端通吃**：一套代码发布至 iOS、Android、PC 及 VR 设备。
    ** **资产商店 (Asset Store)**：丰富的成品模型与逻辑插件，极大缩短开发周期。
    ** **XR 领跑者**：在 AR/VR 领域的成熟度依然稳居行业首位。
* **劣势**：**WebGL 导出较重**。导出的 Web 版本通常体积庞大（数十 MB），且在移动端浏览器上兼容性不稳定。

====== 2.3.2.3 Unreal Engine：极致的视觉天花板
追求 **照片级写实、超大场景或 AAA 级表现力** 时的不二之选。

* **优势**：
    ** **影视级画质**：Lumen (动态光照) 与 Nanite (微多边形) 技术带来了无与伦比的震撼力。
    ** **工业级工具**：蓝图系统极强，逻辑构建逻辑严密且可视化程度高。
* **劣势**：**完全不适合分发普通网页**。虽然支持像素流，但需要昂贵的服务器 GPU 资源支持，不适合大众化 Web 场景。

===== 2.3.3 场景决策指南
[cols="1,2", options="header"]
|===
| 应用场景 | 推荐方案与建议

| *场景 A：前端开发*
想给官网或 Web 应用加 3D 展示
| **选 Three.js**。加载最快，前端组件化开发最顺手。

| *场景 B：独立游戏开发*
开发一款跨手机、电脑及网页的游戏
| **选 Unity**。开发效率极高，多端发布逻辑最为成熟。

| *场景 C：数字孪生/元宇宙*
大场景且对画质有偏执要求
| **选 Unreal Engine**。提供最接近现实的视觉反馈。

| *场景 D：重度网页游戏*
2D/3D 混合开发
| **选 Unity (配合 Needle Engine)**。利用 2026 年成熟工具链，兼顾开发效率与 Web 运行环境。
|===

=== 3. 类型系统的深度工程化


==== 3.1 类型的本质与负担
* **Java(名义类型)：** 类型是程序的物理骨架，不可剥离。

* **Python：** 运行过程中根本不看类型。
    ** 现状： 现在的 Python 开发者（尤其是后端和 AI 工程师）大量使用 Type Hints。虽然 Python 解释器运行时依然忽略这些类型，但开发者会配合 mypy 或 PyCharm 这种工具进行静态检查。
    ** 为什么用？ 就像你说的，Python 太灵活了。如果没有类型标注，过三个月你自己都不知道这个函数返回的是列表还是字典。
    ** 库的标配： 像 FastAPI 或 Pydantic 这种现代库，完全是基于类型标注构建的。如果你不写类型，这些库甚至无法工作。

* **TypeScript (TS)：** 编译时进行**类型擦除**，转换后的 JS 代码通常比源码更简洁（去掉了 interface 等声明），运行效率由 JS 引擎决定。

==== 3.2 零编译的类型方案：JSDoc + .d.ts
##心智 vs 体力：写 TS 有思考负担，写 JSDoc 有体力负担（注释冗长）##

* **实践：** 利用 `.d.ts` 定义复杂 Interface，在纯 `.js` 中用 JSDoc 引用。

* **环境：** 开启全量类型监测，配合 js 文件顶部的 `// @ts-check` 或者在 jsconfig.json / tsconfig.json 中配置为 		"checkJs": true

    ** 低负担： 简单的类型直接靠 TS 的类型推导。只有复杂的对象，才在外部定义一个 .d.ts 文件（用 TS 语法定义类型），然后在 JS 中通过 JSDoc 引用它。**(全局的不用引用，直接可以使用)**
    ** 优势： 你不需要编译步骤（直接跑 JS），但 IDE 依然能给你提供 TS 级别的报错提示。

---

1. 代码写 js 文件，不写复杂的类型标注。
2. 配置 tsconfig or jsconfig （tsconfig.json 应该会被优先读取）
3. 写 global.d.ts 全局类型

---

jsconfig.json 与 global.d.ts 的协同

* **jsconfig.json：** 控制编辑器的“扫描范围”。关键参数包括 `"checkJs": true` 和路径别名 `paths`。
+
[source,json]
----
{
	"extends": "./.svelte-kit/tsconfig.json",
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "checkJs": true,  // 这是在 JS 项目中开启类型检查的关键！
    "allowJs": true,
    "strict": false
  },
  "include": [
    "src/**/*.js",
    "src/**/*.d.ts",  // 包含 src 下的所有声明文件
    "global.d.ts",     // 包含根目录下的声明文件
  ]
  "exclude": ["node_modules", "dist"]
}
----

* **global.d.ts 类型定义的可见性：**
    ** 类型定义写在该文件中，比用 jsdoc 写要清爽。
    ** 一般在项目根目录放一个 global.d.ts 文件，用 TS 语法定义复杂的对象接口。做成全局自动导入，LSP 会读取它。
    ** **declare：** 建议都写上这个关键字。
    ** **规则：** 若该文件中不含 `import/export`，则为**全局脚本**，里面的类型全项目可见，无需手动导入。
    ** **强制全局：** 若必须在该文件中声明 `import`，则需将内容包裹在 `declare global { ... }` 中。
+
[source,javascript]
----
// global.d.ts
// 定义一个全局的用户类型
interface User {
  id: number;
  name: string;
  role: 'admin' | 'user';
}

// 声明全局变量
declare var __VERSION__: string;
----
+
如果使用了 import or export，则必须使用 declare global 才能成为全局类型，例子如下：
+
[source,javascript]
----
// global.d.ts
import { SomeType } from 'some-library'; // 只要写了这一句，文件就不再是全局脚本

declare global {
  // 必须包裹在 declare global 块里，才能在 JavaScript 中直接访问
  interface User extends SomeType {
    id: number;
  }
}
----
+
.Example: 在 main.js 中使用类型
[source,javascript]
----
/** @type {User} */
const currentUser = { id: 1, name: "Gemini", role: "admin" };
----

+
.SvelteKit 举例
====
**SvelteKit：** SvelteKit 自动生成的 `.svelte-kit/types` 目录是类型补全的核心，Neovim 需配置 `jsconfig.json` 来索引这些目录。

实际上引用 `"extends": "./.svelte-kit/tsconfig.json"` 就可以了。
====

=== 4. 商业版权与开源治理


==== 甲骨文 (Oracle) 与 Java 诉讼
* **核心矛盾：** 尽管 Java 开源，但 Oracle 拥有商标权及特定商业组件所有权。其官司重心在于**“API 的组织结构和命名”**是否受版权保护（如 Oracle vs. Google）。

==== Python (PSF) 的自由之路
* **管理模式：** 归属于非营利基金会（PSF）。其许可证极其开放（PSF License），鼓励连接一切而不设商业关卡。

