:source-highlighter: pygments
:icons: font
:scripts: cjk
:stem: latexmath
:experimental:
:toc:
:toc: right
:toc-title: 目录
:toclevels: 3
:tip-caption: ⚡
:note-caption: ❕
:important-caption: ❗
:warning-caption: ‼️
:caution-caption: ⚠️

= LazyVim 快捷键

++++
<button id="toggleButton">目录开关</button>
<script>
    // 获取按钮和 div 元素
    const toggleButton = document.getElementById('toggleButton');
    const contentDiv = document.getElementById('toc');
    contentDiv.style.display = 'block';

    // 添加点击事件监听器
    toggleButton.addEventListener('click', () => {
        // 切换 div 的显示状态
        // if (contentDiv.style.display === 'none' || contentDiv.style.display === '') {
        if (contentDiv.style.display === 'none') {
            contentDiv.style.display = 'block';
        } else {
            contentDiv.style.display = 'none';
        }
    });
</script>
++++

== LazyVim 搜索快捷键


=== Telescope 搜索
LazyVim 默认使用 *Telescope* 作为其搜索引擎的核心，提供强大的模糊搜索和实时检索功能。
[cols="2,5", options="header"]
|===
| 快捷键 | 功能描述
| `[space] [space]` | *Find Files*: 搜索当前项目中的文件名。
| `[space] s g` | *Live Grep*: 在当前项目中搜索字符串内容（实时匹配）。
| `[space] s w` | *Search Word*: 搜索光标下的单词。
| `[space] s R` | *Resume*: 呼出上一次搜索的列表及光标位置（非常重要）。
| `[space] s /` | *Search History*: 查看并搜索你的搜索历史记录。
|===

=== 解决“搜索列表消失”的痛点
在进行代码重构（如 `write_black_sentinels` 清理）时，频繁进入文件后丢失搜索结果是最常见的问题。

[upperalpha]
. 方案：使用 Resume 命令（推荐）
+
这是最快的方法。当进入某个文件查看完代码，想要回到刚才的搜索结果列表时：
+
[lowergreek]
1. 按下 `[space] s R`。
2. 之前的 Telescope 窗口会**原封不动**地弹出。
3. 你可以继续选择下一个匹配项。



. 方案：发送至 Quickfix 列表
+
如果希望搜索列表像 Leo 的 `cff` 结果一样持久化在屏幕底部：
+
[lowergreek]
1. 在 Telescope 搜索结果窗口中，按下 `Ctrl + q`。
2. 所有的结果会被发送到 Neovim 的 *Quickfix List* 中。
3. 使用 `:copen` 命令打开列表窗口。
4. 使用 `[q` 和 `]q` 在结果之间快速跳转，无需再次呼出窗口。
// 这个方法我没有试，因为我把 `Ctrl + q` 绑定到微信上了

=== 全局替换神器：Spectre
当需要像 IDE 一样在全项目范围内批量修改代码（例如将所有 `write_black_sentinels` 相关的逻辑重命名）时，Spectre 是最佳选择。

* **触发快捷键**: `[space] s r`
* **底层动力**: 由 `ripgrep` 提供搜索支持，速度极快。

Spectre 内部操作流

1. **输入搜索词**: 在第一行输入你要查找的内容。
2. **输入替换词**: 在第二行输入你想要替换成的内容。
3. **预览结果**: 界面下方会实时显示受影响的文件和具体的代码行对比。
4. **执行替换**:
    * 按下 `leader + R` (通常是 `\R` 或 `,R`): 替换**当前光标所在文件**中的所有匹配项。
    * 按下 `leader + A` (通常是 `\A` 或 `,A`): 替换**全项目**中所有的匹配项。
5. **确认**: 替换完成后，Spectre 会自动保存这些修改后的文件。

[CAUTION]
批量替换具有破坏性。在执行 `leader + A` 之前，务必确保你的 Git 工作区是干净的，以便随时回滚。


为什么它显示 "ripgrep"? 这是因为：

1. **ripgrep (rg)** 是目前世界上最快的文本搜索工具。
2. **Spectre** 本身只是一个“壳”，它负责把 `ripgrep` 搜索出来的结果以可视化的方式呈现出来，并提供替换逻辑。 
3. **Telescope (`<space>sg`)** 同样使用 `ripgrep`，但它更偏向于“跳转”；而 **Spectre (`<space>sr`)** 更偏向于“修改”。

=== 与 Leo-Editor `cff` 的逻辑对比
对于习惯 Leo-Editor 的用户，理解这两种工具的差异有助于提升效率：

* **Leo `cff`**: 直接在 *Outline* 中创建物理克隆节点。结果是持久的，修改克隆即修改原始代码。
* **LazyVim Telescope**: 提供一个 *Virtual Overlay*（虚拟浮层）。列表通过 `[space] s R` 实现逻辑上的持久。

== LazyVim 函数跳转
在 LazyVim（以及大多数现代 Neovim 配置）中，跳转到下一个或上一个函数主要依赖于 **LSP (Language Server Protocol)** 或 **Treesitter**。

这里有几种最常用的方式，你可以根据习惯选择：

=== 1. 使用 Treesitter 快捷键 (推荐)
LazyVim 默认集成了 `nvim-treesitter-textobjects`，这是最精准的跳转方式，因为它能理解代码的语法结构。

* **跳转到下一个函数：** `]m`
* **跳转到上一个函数：** `[m`
* **跳转到下一个类的开始：** `]]`
* **跳转到上一个类的开始：** `[[`

> **提示：** 这里的 `m` 可以理解为 "Method"（方法/函数）。如果你想跳转到函数的**结尾**，可以使用 `]M`。

=== 2. 使用符号搜索 (Symbol Search)
如果你想跳转到特定的函数，而不是仅仅“下一个”，可以使用符号导航：

* **当前文件符号：** 输入 `<leader>ss` (Search Symbol)。
* 这会打开一个列表，输入函数名即可快速定位。


* **全局项目符号：** 输入 `<leader>sS`。

=== 3. 使用符号大纲 (Symbols Outline)
如果你喜欢在侧边栏看到整个文件的函数结构：

* **打开/关闭大纲：** `<leader>cs` (Symbols Outline)。
* 在大纲中使用 `j/k` 选择，回车即可跳转。

=== 4. 基础 Vim 跳转 (兜底方案)
如果当前文件没有配置 LSP 或 Treesitter，你可以使用 Vim 自带的正则跳转，虽然不够智能，但胜在通用：

* **跳转到下一个 `}` 开头的行（通常是函数开头）：** `]]`
* **跳转到上一个 `{` 开头的行：** `[[`

=== 5. 总结表
[caption=]
[cols="1,1,1",options="header"]
|===
| 操作 | 快捷键 | 备注
| **下一个函数**   | `]m`    | 基于 Treesitter，最常用
| **上一个函数**   | `[m`    | 基于 Treesitter
| **下一个类**    | `]]`     | 适用于 Python/Java 等
| **模糊搜索函数** | `<leader>ss` | 适合知道名字的跳转
|===

== LazyVim 诊断与报错（Diagnostics）
在 LazyVim 中，代码报错和警告被称为 *Diagnostics*（诊断）。
可以通过以下快捷键在文件内快速跳转或查看详细错误。

=== 1. 基础跳转 (Basic Navigation)
这些快捷键用于在文件内的报错点之间快速切换。

[cols="1,2,2", options="header"]
|===
| 功能 | 快捷键 | 英文对照 (Keybinding)
| 下一个诊断 | kbd:[\]d] | Next Diagnostic
| 上一个诊断 | kbd:[[d] | Prev Diagnostic
| 下一个错误 | kbd:[\]e] | Next Error
| 上一个错误 | kbd:[[e] | Prev Error
| 下一个警告 | kbd:[\]w] | Next Warning
| 上一个警告 | kbd:[[w] | Prev Warning
|===

=== 2. 查看详细诊断信息 (Inspection)
当你停留在报错行时，可以使用以下命令查看具体错误描述。

* **显示行诊断浮窗**：使用 kbd:[<leader> + c + d]
+
[TIP]
====
`c` 代表 **Code**，`d` 代表 **Diagnostics**。这会弹出一个浮窗显示完整的错误堆栈或提示信息。
====

=== 3. 批量处理 (Trouble 插件)
LazyVim 默认集成了 `Trouble.nvim`，类似于 VS Code 的底部 "Problems" 面板。

* **打开当前文件诊断列表**：kbd:[<leader> + x + x]
* **打开全项目诊断列表**：kbd:[<leader> + x + X]
* **关闭列表面板**：kbd:[q] 或再次按 kbd:[<leader> + x + x]

[IMPORTANT]
====
在 Trouble 面板中，你可以使用 kbd:[j] / kbd:[k] 移动，按 kbd:[Enter] 直接跳转到对应的代码行。
====

=== 4. 快速修复 (Quick Fix)
如果你跳转到了报错位置，可以尝试让 LSP 自动修复：

* **代码操作 (Code Action)**：kbd:[<leader> + c + a]
+
这会列出所有可能的修复方案（如自动导入、删除未使用变量等）。

== LazyVim 代码重构 (Refactoring) 
在 LazyVim 中，代码重构主要依赖于 LSP (Language Server Protocol)。
通过这些快捷键，可以高效地重命名变量、提取函数或执行自动修复。

=== 1. 核心重构操作 (Core Refactoring)
[cols="1,1,1,3", options="header"]
|===
| 功能 | 快捷键 | 英文对照 (Keybinding) | 说明
| **重命名符号**           | kbd:[<leader>cr] | Rename | 最常用的重构功能，它会同步修改项目中所有引用了该变量的地方。
| **代码操作/快速修复**     | kbd:[<leader>ca] | Code Action | 局部当前行相关。重构的“万金油”，LSP 提供的绝大多数重构建议（如提取、移动）都藏在这里面。
| **源操作 (如优化导入)**   | kbd:[<leader>cA] | Source Action | 文件级别。通常是预定义的“批处理”任务。
|===

=== 2. 导航与搜索 (Navigation)
重构前确认引用范围非常重要。

[cols="1,2,2", options="header"]
|===
| 功能 | 快捷键 | 英文对照 (Keybinding)
| **跳转到定义**     | kbd:[gd] | Go to Definition
| **查看所有引用**   | kbd:[gr] | Go to References
| **查看类型定义**   | kbd:[gy] | Go to Type Definition
| **查看实现**      | kbd:[gI] | Go to Implementation
|===

=== 3. 高级重构 (Refactoring.nvim)
如果你启用了 LazyVim 的 `coding.refactoring` 额外选项，可以使用以下高级功能（通常在可视化模式下选择代码后使用）：

* **提取函数**：在选中模式下按 kbd:[<leader>re] (Extract Function)
* **提取变量**：在选中模式下按 kbd:[<leader>rv] (Extract Variable)
* **内联变量**：按 kbd:[<leader>ri] (Inline Variable)

[TIP]
====
即使没有安装特定的重构插件，针对许多语言（如 TypeScript, Python），直接在代码上按 kbd:[<leader>ca] 也会弹出诸如 "Move to new file" 或 "Extract method" 的建议。
====

=== 4. 格式化 (Formatting)
重构完成后通常需要统一代码风格。

* **格式化当前文件/选区**：kbd:[<leader>cf] (Format)
* **开关自动保存格式化**：kbd:[<leader>uf] (Toggle format on save)

